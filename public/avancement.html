<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Avancement Comparatif - EDT Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
    <style>
        :root {
            --bg-color: #f8f9fa; --primary-color: #0d6efd; --primary-light: #e7f1ff;
            --text-color: #212529; --text-muted: #6c757d; --card-bg: #ffffff;
            --border-color: #dee2e6; --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --border-radius: 12px;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; color: var(--text-color); line-height: 1.6; padding-top: 60px; }
        nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 60px;
      padding: 10px 20px;
      background:#fff;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      display: flex;
      align-items: center;
      z-index: 700;
      justify-content: space-between;
      border-bottom: 1px solid #dee2e6;
    } 
        nav a { text-decoration: none; color: #333; padding: 8px 16px; border-radius: 8px; transition: background-color 0.3s, color 0.3s; }
        nav a:hover { background-color: #f0f4ff; color: #1d4ed8; font-weight: 600; }
        nav a.active { background-color: #f0f4ff; color: #1d4ed8; font-weight: 600; }
        .nav-links { display: flex; align-items: center; gap: 10px; }
        
        .profile-menu-container { position: relative; }
        .profile-button {
            display: flex; align-items: center; justify-content: center; text-decoration: none;
            width: 40px; height: 40px; border-radius: 50%; background-color: #e0eaff;
            color: #1d4ed8; border: 1px solid #e0eaff; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
        }
        .profile-dropdown {
            display: none; position: absolute; top: calc(100% + 12px); right: 0;
            width: 280px; background-color: white; border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); z-index: 1010; overflow: hidden;
            transform-origin: top right; animation: scale-up-and-fade-in 0.2s ease-out;
        }
        .profile-dropdown.show { display: block; }
        @keyframes scale-up-and-fade-in { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .dropdown-profile-header { display: flex; align-items: center; gap: 12px; padding: 16px; border-bottom: 1px solid #f3f4f6; }
        .profile-pic {
            width: 48px; height: 48px; border-radius: 50%; background-color: #f3f4f6;
            display: flex; align-items: center; justify-content: center; font-size: 24px; color: #6b7280;
        }
        .profile-info strong { display: block; font-size: 1rem; font-weight: 600; color: #111827; }
        .profile-info small { font-size: 0.875rem; color: #6b7280; }
        .dropdown-menu-list { list-style: none; padding: 8px; margin: 0; }
        .dropdown-link {
            display: flex; align-items: center; width: 100%; padding: 10px 12px;
            border-radius: 8px; text-decoration: none; color: #374151;
            font-weight: 500; transition: background-color 0.2s, color 0.2s;
        }
        .dropdown-link:hover { background-color: #f3f4f6; }
        .dropdown-link .icon { width: 32px; font-size: 16px; color: #6b7280; }
        .dropdown-link .text { flex-grow: 1; }
        .dropdown-link .chevron { font-size: 12px; color: #9ca3af; }
        .dropdown-divider { margin: 0 8px; border: none; border-top: 1px solid #f3f4f6; }
        .dropdown-link.logout { margin: 8px; width: calc(100% - 16px); color: #ef4444; }
        .dropdown-link.logout .icon { color: #ef4444; }
        .dropdown-link.logout:hover { background-color: #fee2e2; }

        .main-container { max-width: 1800px; margin: 0 auto; padding: 24px; }
        .section-title { font-size: 1.75rem; font-weight: 700; color: var(--text-color); margin-bottom: 24px; padding-bottom: 12px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 12px; }
        .info-banner { text-align: left; color: var(--text-muted); font-size: 1rem; margin-bottom: 15px; background-color: var(--primary-light); padding: 10px 15px; border-radius: var(--border-radius); border: 1px solid #bde0fe; display: flex; align-items: center; gap: 10px; }
        .info-banner::before { font-family: "Font Awesome 6 Free"; font-weight: 900; content: "\f05a"; color: var(--primary-color); font-size: 1.2rem; }
        .info-banner a { color: var(--primary-color); font-weight: 600; text-decoration: none; }
        .info-banner .file-info { font-weight: 600; color: #0a58ca; }
        .stats-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 15px; }
        .stat-card { background: var(--card-bg); padding: 16px; border-radius: var(--border-radius); border: 1px solid var(--border-color); display: flex; flex-direction: column; align-items: flex-start; justify-content: space-between; min-height: 70px; }
        .stat-card .stat-header { display: flex; align-items: center; gap: 12px; color: var(--text-muted); font-weight: 500; }
        .stat-card .icon-wrapper { width: 32px; height: 32px; border-radius: 8px; display: grid; place-items: center; font-size: 1rem; }
        .stat-card .icon-wrapper.formateurs { background-color: #e7f1ff; color: #0d6efd; }
        .stat-card .icon-wrapper.groupes { background-color: #e6f7ff; color: #0ca6e9; }
        .stat-card .icon-wrapper.progress { background-color: #fff0e6; color: #fd7e14; }
        .stat-card .icon-wrapper.modules { background-color: #e6f9f1; color: #20c997; }
        .stat-card .value { font-size: 2rem; font-weight: 700; color: var(--text-color); line-height: 1.1; margin-top: 5px; }
        /* Image Comparison Slider */
        .comparison-container {
            position: relative;
            width: 100%;
            height: auto;
        }
        .chart-wrapper {
    position: relative;
    width: 100%;
    /* Augmentation de la hauteur minimale pour donner plus d'espace pour la légende et aux badges */
    min-height: 650px;
    background-color: var(--card-bg);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    overflow: visible;
}
        .chart-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 10px;
        }
        .real-progress {
            clip-path: inset(0 50% 0 0);
        }
        .planned-progress {
            clip-path: inset(0 0 0 50%);
        }
        .slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: #dee2e600;
            position: absolute;
            top: 50%;
            left: 0;
            z-index: 10;
            margin-top: -2px;
            cursor: col-resize;
            display: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: col-resize;
            border: none;
            box-shadow: 0 2px 6px rgba(13, 110, 253, 0.4);
        }
        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: col-resize;
            border: none;
            box-shadow: 0 2px 6px rgba(13, 110, 253, 0.4);
        }
        .drag {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #000;
    border: 2px solid hsl(0 0% 40%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
            cursor: col-resize;
            box-shadow: 0 2px 6px rgba(13, 110, 253, 0.4);
            transition: transform 0.2s;
        }
        .drag:hover, .slider:active + .drag {
            transform: translate(-50%, -50%) scale(1.1);
        }
        .drag:active {
            transform: translate(-50%, -50%) scale(0.95);
        }
        /* Bouton switch - conservé pour le style */
        #flip-button {
            position: absolute;
            top: -70px;
            right: 0;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            box-shadow: 0 4px 15px rgba(13, 110, 253, 0.4);
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s ease;
        }
        #flip-button:hover {
            transform: scale(1.1);
        }
        #flip-button:active {
            transform: scale(0.95);
        }
.controls-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
    padding: 4px 20px; /* Réduction du padding-top de 8px à 4px */
    background-color: var(--card-bg);
    border-radius: var(--border-radius);
}
        .chart-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-color);
        }
        .view-switcher {
            position: relative;
            display: flex;
            align-items: flex-start;
            padding: 2px;
            background-color: #f0f0f0;
            border-radius: 9px;
            width: 392px;
            margin: 0 auto;
            height: 45px;
        }
        .view-switcher-btn {
            width: 130px;
            height: 40px;
            position: relative;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.95rem;
            color: #333;
            cursor: pointer;
            transition: color 0.3s ease;
            font-weight: 500;
            background: transparent;
            border: none;
        }
        .view-switcher-btn.active {
            color: var(--primary-color);
            font-weight: 600;
        }
        .view-switcher-indicator {
            content: "";
            width: 130px;
            height: 40px;
            background: white;
            position: absolute;
            top: 2px;
            left: 2px;
            z-index: 1;
            border-radius: 7px;
            transition: left 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 1px 5px rgba(0,0,0,0.1);
        }
        .module-filter-container {
            display: none;
            width: 100%;
            padding: 1px 0 0;
            margin-top: 1px;
            flex-direction: column;
            align-items: center;
            gap: 1px;
        }
        .filter-label {
            font-weight: 600;
            color: var(--text-color);
            font-size: 1rem;
        }
.group-filter-container {
    display: flex;
    /* Permettre le retour à la ligne dans le popup */
    flex-wrap: wrap;
    /* Assure que le conteneur prend toute la largeur */
    width: 100%;
    /* Aligne les boutons au début (à gauche) */
    justify-content: flex-start;
    gap: 8px;
    /* Pas de padding spécial, géré par le popup */
    padding: 0;
}
        .group-filter-btn, .formateur-filter-btn {
            padding: 6px 12px;
            font-size: 0.8rem;
            font-weight: 500;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: var(--text-muted);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            white-space: nowrap;
            user-select: none;
            position: relative;
        }
        .group-filter-btn:hover, .formateur-filter-btn:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }
        .group-filter-btn.selected, .formateur-filter-btn.selected {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            font-weight: 600;
        }
        .group-filter-btn.active, .formateur-filter-btn.active {
            background-color: #34495e;
            color: white;
            border-color: #34495e;
            font-weight: 600;
        }
        /* Indication visuelle pour les relations */
        .filter-section-info {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 4px;
            font-style: italic;
        }
        .chart-container {
    background-color: var(--card-bg);
    /* Padding par défaut pour les vues formateur et groupe */
    padding: 20px 24px 20px 24px;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow);
    border: 1px solid var(--border-color);
    width: 100%;
    min-height: 650px;
    overflow: visible;
}
        /* Padding spécifique pour la vue module (plus d'espace pour les badges) */
        .chart-container.module-view {
            padding: 20px 24px 70px 24px;
        }
        @media (max-width: 1200px) {
            .stats-container { grid-template-columns: 1fr 1fr; }
            .doughnut-card { grid-column: span 2; }
        }
        @media (max-width: 768px) {
            body { padding-top: 50px; }
            nav { padding: 5px 16px; height: auto; }
            .nav-links { display: none; }
            .main-container { padding: 16px; }
            .stats-container { grid-template-columns: 1fr; }
            .doughnut-card { grid-column: span 1; }
            .view-switcher { width: 100%; }
            .view-switcher-btn { width: 33.33%; font-size: 0.9rem; }
            .view-switcher-indicator { width: 33.33%; }
        }
        /* --- Styles pour le filtre à bascule --- */
/* Conteneur de l'en-tête du filtre (label + icône) */
.filter-header {
    display: flex;
    align-items: center;
    justify-content: space-between; /* Sépare le titre et l'icône */
    gap: 10px; /* Espace entre le titre et l'icône */
    width: 100%;
}
/* Style du bouton-icône de filtre */
.filter-toggle-btn {
    background: none;
    border: 2px solid var(--border-color);
    cursor: pointer;
    color: var(--text-muted);
    font-size: 1rem; /* Taille de l'icône */
    padding: 8px;
    border-radius: 8px;
    transition: all 0.2s ease;
    min-width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
}
.filter-toggle-btn:hover {
    color: var(--primary-color);
    background-color: var(--primary-light);
    border-color: var(--primary-color);
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(13, 110, 253, 0.2);
}
/* --- Styles pour le panneau popup de filtre --- */
.filter-popup {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 8px;
    min-width: 350px;
    max-width: 450px;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    display: none;
    padding: 20px;
    animation: popupFadeIn 0.2s ease-out;
    max-height: 500px;
    overflow-y: auto;
}
.filter-popup.show {
    display: block;
}
@keyframes popupFadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
.filter-popup-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid var(--border-color);
}
.filter-popup-title {
    font-weight: 600;
    color: var(--text-color);
    font-size: 1.1rem;
}
.filter-popup-close {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 1.1rem;
    padding: 4px;
    border-radius: 4px;
    transition: all 0.2s ease;
}
.filter-popup-close:hover {
    color: var(--text-color);
    background-color: #f8f9fa;
}
.filter-section {
    margin-bottom: 20px;
}
.filter-section:last-of-type {
    margin-bottom: 16px;
}
.filter-section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
}
.filter-section-title {
    font-weight: 600;
    color: var(--text-color);
    font-size: 0.95rem;
}
.filter-clear-btn {
    background: none;
    border: 1px solid #dc3545;
    color: #dc3545;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.2s ease;
}
.filter-clear-btn:hover {
    background-color: #dc3545;
    color: white;
}
.filter-buttons-container {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    max-height: 120px;
    overflow-y: auto;
    padding: 8px;
    background-color: #f8f9fa;
    border-radius: 6px;
    border: 1px solid #e9ecef;
}
.filter-buttons-container::-webkit-scrollbar {
    width: 6px;
}
.filter-buttons-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
}
.filter-buttons-container::-webkit-scrollbar-thumb {
    background: #ccc;
    border-radius: 3px;
}
.filter-buttons-container::-webkit-scrollbar-thumb:hover {
    background: #999;
}
.filter-actions {
    display: flex;
    justify-content: center;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
}
.filter-apply-btn {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
}
.filter-apply-btn:hover {
    background-color: #0b5ed7;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(13, 110, 253, 0.3);
}
/* Position relative pour le conteneur parent */
.view-switcher-container {
    position: relative;
}
/* Amélioration de la lisibilité des étiquettes de graphique */
.chart-container canvas {
    font-family: inherit;
}

/* --- Base commune pour les cellules de module --- */


/* --- Badge Numérique (Carré + Chiffre) via ::after --- */
.auto-resize-cell.module-s1::after,
.auto-resize-cell.module-s2::after,
.auto-resize-cell.module-annual::after,
.auto-resize-cell.module-regional::after {
    /* Propriétés du texte (Numéro/Lettre) */
    color: white;
    font-size: 10px;
    font-weight: 700;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    text-shadow: 0 0.5px 1px rgba(0,0,0,0.3);

    /* Propriétés de la boîte (Carré) */
    position: absolute;
    top: 4px;
    right: 4px; /* Aligné à droite avec 2px de padding selon la spécification */
    width: 14px;
    height: 14px;
    border-radius: 3px;
    box-shadow:
        0 0 0 1px rgba(255,255,255,0.8) inset,
        0 1px 2px rgba(0,0,0,0.1);

    /* Centrage du texte dans la boîte */
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    pointer-events: none;
}

/* Contenu et couleur spécifiques à chaque type de badge */
.auto-resize-cell.module-s1::after {
content: "1";
background-color: #1B9AF0;
}

.auto-resize-cell.module-s2::after {
content: "2";
background-color: #2BB673;
}

.auto-resize-cell.module-annual::after {
content: "A";
background-color: #FF6D00;
}

/* Badge régional (étoile dorée) via ::before */
.auto-resize-cell.module-regional::before {
content: "⭐";
position: absolute;
top: 4px;
left: 4px;
font-size: 10px;
color: #FFD700;
text-shadow: 0 0.5px 1px rgba(0,0,0,0.3);
z-index: 3;
pointer-events: none;
}
    </style>
</head>
<body>
    <nav>
      <img src="assets/images/logo_edtpro.png" style="height: 80px; width: auto;" id="logo" alt="Logo">
      <div class="nav-links">
          <a href="emploi.html" id="nav-emploi" class="active">Emploi globale</a>
          <a href="edition.html" id="nav-edition">Edition</a>
          <a href="avancement.html" id="nav-avancement">Avancement</a>
          <div class="profile-menu-container" id="profile-menu-container">
            <button id="profile-button" class="profile-button">
              <span id="profile-initials">--</span>
            </button>
            <div id="profile-dropdown" class="profile-dropdown">
              <div class="dropdown-profile-header">
                  <div class="profile-pic"><i class="fas fa-user"></i></div>
                  <div class="profile-info">
                      <strong id="dropdown-user-name">Chargement...</strong>
                      <small id="dropdown-user-email">...</small>
                  </div>
              </div>
              <ul class="dropdown-menu-list">
                  <li>
                      <a href="profile.html" class="dropdown-link">
                          <i class="fas fa-user-edit icon"></i>
                          <span class="text">Mon Profil</span>
                          <i class="fas fa-chevron-right chevron"></i>
                      </a>
                  </li>
              </ul>
              <hr class="dropdown-divider">
              <a href="../api/auth/logout.php" class="dropdown-link logout">
                  <i class="fas fa-sign-out-alt icon"></i>
                  <span class="text">Déconnexion</span>
              </a>
            </div>
      </div>
  </nav>
    <div class="main-container">
        <main> 
            <div class="section">
                <p class="info-banner" id="infoBanner">Chargement des données...</p>
                <div class="stats-container" id="stats-container">
                    <div class="stat-card">
                        <div class="stat-header"><div class="icon-wrapper formateurs"><i class="fas fa-chalkboard-teacher"></i></div><span>Formateurs Uniques</span></div>
                        <div id="stats-formateurs" class="value">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-header"><div class="icon-wrapper groupes"><i class="fas fa-users"></i></div><span>Groupes Actifs</span></div>
                        <div id="stats-groupes" class="value">0</div>
                    </div>
                                        <div class="stat-card" style="grid-column: span 2;">
                        <div class="stat-header">
                            <div class="icon-wrapper modules"><i class="fas fa-cubes"></i></div>
                            <span>Affectation des Modules</span>
                        </div>
                        <div id="affectation-progress-container" style="width: 100%; margin-top: 5px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 0.9rem;">
                                <div>
                                    <span id="legend-affectes-value" style="font-weight: 600; color: #20c997;">0</span> Affectés | 
                                    <span id="legend-non-affectes-value" style="font-weight: 600; color: #dc3545;">0</span> Non Affectés | 
                                    <span id="legend-total-value" style="color: var(--text-muted);">0</span> Total
                                </div>
                                <span id="doughnut-percent" style="font-weight: 700; color: var(--primary-color);">0%</span>
                            </div>
                            <div id="progress-bar-bg" style="width: 100%; background-color: #e9ecef; border-radius: 8px; height: 12px; overflow: hidden;">
                                <div id="progress-bar-fill" style="width: 0%; height: 100%; background-color: #20c997; border-radius: 8px; transition: width 0.5s ease-out;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-header"><div class="icon-wrapper progress"><i class="fas fa-tasks"></i></div><span>Taux d'Avancement Réel</span></div>
                        <div id="global-progress-rate" class="value">0%</div>
                    </div>
                </div>
                <!-- Comparaison avec slider -->
                <div class="comparison-container">
                    <!-- Bouton switch conservé pour le style (mais caché) -->
                    <button id="flip-button" title="Comparer avec les données planifiées" style="display: none;"><i class="fas fa-exchange-alt"></i></button>
                    <input class="slider" type="range" min="0" max="100" value="50" />
                    <div class="drag">
                        <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke-width="1.5"
            stroke="currentColor"
            class="size-6"
            style="transform: rotate(90deg);"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              d="M8.25 15 12 18.75 15.75 15m-7.5-6L12 5.25 15.75 9"
            />
          </svg>
                    </div>
                    <div class="chart-wrapper">
                        <div class="chart-container real-progress">
                            <div class="controls-container">
                                <h3 class="chart-title">Avancement E-note</h3>
                                <div class="view-switcher-container" style="display: flex; align-items: center; gap: 16px; justify-content: center;">
                                    <div class="view-switcher">
                                        <button id="viewByFormateurBtn" class="view-switcher-btn active">Par Formateur</button>
                                        <button id="viewByGroupeBtn" class="view-switcher-btn">Par Groupe</button>
                                        <button id="viewByModuleBtn" class="view-switcher-btn">Par Module</button>
                                        <div class="view-switcher-indicator" id="viewSwitcherIndicator1"></div>
                                    </div>
                                    <button id="toggleFilterBtn" class="filter-toggle-btn" title="Filtrer les modules par groupe et formateur" style="display: none;">
                                        <i class="fas fa-filter"></i>
                                    </button>
                                    <!-- Panneau popup de filtre -->
                                    <div id="filterPopup" class="filter-popup">
                                        <div class="filter-popup-header">
                                            <span class="filter-popup-title">Filtres par Module (Intersection)</span>
                                            <button id="closeFilterPopup" class="filter-popup-close">
                                                <i class="fas fa-times"></i>
                                            </button>
                                        </div>
                                        <div class="filter-popup-content">
                                            <!-- Section Filtre par Groupe -->
                                            <div class="filter-section">
                                                <div class="filter-section-header">
                                                    <span class="filter-section-title">Filtrer par Groupe</span>
                                                    <button class="filter-clear-btn" id="clearGroupFilters">Effacer</button>
                                                </div>
                                                <div class="filter-section-info">Sélectionnez un ou plusieurs groupes</div>
                                                <div id="groupFilterButtons" class="filter-buttons-container"></div>
                                            </div>
                                            <!-- Section Filtre par Formateur -->
                                            <div class="filter-section">
                                                <div class="filter-section-header">
                                                    <span class="filter-section-title">Filtrer par Formateur</span>
                                                    <button class="filter-clear-btn" id="clearFormateurFilters">Effacer</button>
                                                </div>
                                                <div class="filter-section-info">Modules enseignés par ces formateurs ET assignés aux groupes</div>
                                                <div id="formateurFilterButtons" class="filter-buttons-container"></div>
                                            </div>
                                            <!-- Section Filtre par Semestre -->
                                            <div class="filter-section">
                                                <div class="filter-section-header">
                                                    <span class="filter-section-title">Filtrer par Semestre</span>
                                                    <button class="filter-clear-btn" id="clearSemestreFilters">Effacer</button>
                                                </div>
                                                <div id="semestreFilterButtons" class="filter-buttons-container"></div>
                                            </div>
                                            <!-- Section Filtre par Régional -->
                                            <div class="filter-section">
                                                <div class="filter-section-header">
                                                    <span class="filter-section-title">Filtrer par Régional</span>
                                                    <button class="filter-clear-btn" id="clearRegionalFilters">Effacer</button>
                                                </div>
                                                <div id="regionalFilterButtons" class="filter-buttons-container"></div>
                                            </div>
                                            <!-- Actions -->
                                            <div class="filter-actions">
                                                <button id="applyFilters" class="filter-apply-btn">
                                                    <i class="fas fa-check"></i> Appliquer
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <canvas id="globalAvancementChart"></canvas>
                        </div>
                        <div class="chart-container planned-progress">
                            <div class="controls-container">
                                <h3 class="chart-title">Avancement eDTpro</h3>
                                <div class="view-switcher-container" style="display: flex; align-items: center; gap: 16px; justify-content: center;">
                                    <div class="view-switcher">
                                        <button id="viewPlannedByFormateurBtn" class="view-switcher-btn">Par Formateur</button>
                                        <button id="viewPlannedByGroupeBtn" class="view-switcher-btn active">Par Groupe</button>
                                        <button id="viewPlannedByModuleBtn" class="view-switcher-btn">Par Module</button>
                                        <div class="view-switcher-indicator" id="viewSwitcherIndicator2"></div>
                                    </div>
                                    <button id="togglePlannedFilterBtn" class="filter-toggle-btn" title="Filtrer les modules par groupe et formateur" style="display: none;">
                                        <i class="fas fa-filter"></i>
                                    </button>
                                    <!-- Panneau popup de filtre pour l'avancement planifié -->
                                    <div id="plannedFilterPopup" class="filter-popup">
                                        <div class="filter-popup-header">
                                            <span class="filter-popup-title">Filtres par Module (Intersection) - Planifié</span>
                                            <button id="closePlannedFilterPopup" class="filter-popup-close">
                                                <i class="fas fa-times"></i>
                                            </button>
                                        </div>
                                        <div class="filter-popup-content">
                                            <!-- Section Filtre par Groupe -->
                                            <div class="filter-section">
                                                <div class="filter-section-header">
                                                    <span class="filter-section-title">Filtrer par Groupe</span>
                                                    <button class="filter-clear-btn" id="clearPlannedGroupFilters">Effacer</button>
                                                </div>
                                                <div class="filter-section-info">Sélectionnez un ou plusieurs groupes</div>
                                                <div id="plannedGroupFilterButtons" class="filter-buttons-container"></div>
                                            </div>
                                            <!-- Section Filtre par Formateur -->
                                            <div class="filter-section">
                                                <div class="filter-section-header">
                                                    <span class="filter-section-title">Filtrer par Formateur</span>
                                                    <button class="filter-clear-btn" id="clearPlannedFormateurFilters">Effacer</button>
                                                </div>
                                                <div class="filter-section-info">Modules enseignés par ces formateurs ET assignés aux groupes</div>
                                                <div id="plannedFormateurFilterButtons" class="filter-buttons-container"></div>
                                            </div>
                                            <!-- Section Filtre par Semestre -->
                                            <div class="filter-section">
                                                <div class="filter-section-header">
                                                    <span class="filter-section-title">Filtrer par Semestre</span>
                                                    <button class="filter-clear-btn" id="clearPlannedSemestreFilters">Effacer</button>
                                                </div>
                                                <div id="plannedSemestreFilterButtons" class="filter-buttons-container"></div>
                                            </div>
                                            <!-- Section Filtre par Régional -->
                                            <div class="filter-section">
                                                <div class="filter-section-header">
                                                    <span class="filter-section-title">Filtrer par Régional</span>
                                                    <button class="filter-clear-btn" id="clearPlannedRegionalFilters">Effacer</button>
                                                </div>
                                                <div id="plannedRegionalFilterButtons" class="filter-buttons-container"></div>
                                            </div>
                                            <!-- Actions -->
                                            <div class="filter-actions">
                                                <button id="applyPlannedFilters" class="filter-apply-btn">
                                                    <i class="fas fa-check"></i> Appliquer
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div id="plannedModuleFilterContainer" class="module-filter-container">
                                    <span class="filter-label">Filtrer par Groupe :</span>
                                    <div id="oldPlannedGroupFilterButtons" class="group-filter-container"></div>
                                </div>
                            </div>
                            <canvas id="plannedProgressChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
    <script>
        // --- VARIABLES GLOBALES ---
        let baseData = {}, avancementData = {};
        let dataByFormateur = {}, dataByGroupe = {}, dataByModule = {};
        let currentView = 'formateur', currentPlannedView = 'groupe';
        let statutaryHoursByFormateur = {}, plannedData = {};
        let affectationDoughnutChart = null;
        // Variables pour les filtres avancés - Avancement Réel
        let selectedGroups = new Set();
        let selectedFormateurs = new Set();
        let selectedSemestres = new Set();
        let selectedRegional = new Set();
        let isFilterActive = false;
        // Variables pour les filtres avancés - Avancement Planifié (indépendants)
        let plannedSelectedGroups = new Set();
        let plannedSelectedFormateurs = new Set();
        let plannedSelectedSemestres = new Set();
        let plannedSelectedRegional = new Set();
        let isPlannedFilterActive = false;
        // Variables pour les relations groupe-formateur
        let groupeFormateurRelations = {}; // groupe -> [formateurs]
        let formateurGroupeRelations = {}; // formateur -> [groupes]
        let moduleRelations = {}; // module -> {groupes: [], formateurs: []}
        let groupeModuleRelations = {}; // groupe -> [modules]
        let formateurModuleRelations = {}; // formateur -> [modules]
        // --- GESTION DE LA PAGE ---
        document.addEventListener('DOMContentLoaded', checkSessionAndLoad);
        async function checkSessionAndLoad() {
            try {
                const response = await fetch('../api/auth/verify_session.php');
                const result = await response.json();
                if (!result.success) { window.location.href = 'login.html'; return; }
                populateUserInfo(result.userData);
                setupProfileMenu();
                loadPageData(); 
            } catch (error) { console.error("Erreur de session:", error); window.location.href = 'login.html'; }
        }
        function setupEventListeners() {
            document.getElementById('viewByFormateurBtn').addEventListener('click', () => switchView('formateur'));
            document.getElementById('viewByGroupeBtn').addEventListener('click', () => switchView('groupe'));
            document.getElementById('viewByModuleBtn').addEventListener('click', () => switchView('module'));
            document.getElementById('viewPlannedByFormateurBtn').addEventListener('click', () => switchPlannedView('formateur'));
            document.getElementById('viewPlannedByGroupeBtn').addEventListener('click', () => switchPlannedView('groupe'));
            document.getElementById('viewPlannedByModuleBtn').addEventListener('click', () => switchPlannedView('module'));
            const toggleFilterBtn = document.getElementById('toggleFilterBtn');
            const filterPopup = document.getElementById('filterPopup');
            const closeFilterPopup = document.getElementById('closeFilterPopup');
            const clearGroupFilters = document.getElementById('clearGroupFilters');
            const clearFormateurFilters = document.getElementById('clearFormateurFilters');
            const clearSemestreFilters = document.getElementById('clearSemestreFilters');
            const clearRegionalFilters = document.getElementById('clearRegionalFilters');
            const applyFilters = document.getElementById('applyFilters');
            
            // Event listeners pour les filtres de l'avancement réel
            if (toggleFilterBtn && filterPopup) {
                toggleFilterBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    filterPopup.classList.toggle('show');
                });
                closeFilterPopup.addEventListener('click', () => {
                    filterPopup.classList.remove('show');
                });
                // Effacer les filtres de groupe
                clearGroupFilters.addEventListener('click', () => {
                    selectedGroups.clear();
                    isFilterActive = selectedGroups.size > 0 || selectedFormateurs.size > 0 || 
                                   selectedSemestres.size > 0 || selectedRegional.size > 0;
                    updateAvailableFilters();
                    updateFilterButtons();
                    if (currentView === 'module') {
                        renderCurrentView();
                    }
                });
                // Effacer les filtres de formateur
                clearFormateurFilters.addEventListener('click', () => {
                    selectedFormateurs.clear();
                    isFilterActive = selectedGroups.size > 0 || selectedFormateurs.size > 0 || 
                                   selectedSemestres.size > 0 || selectedRegional.size > 0;
                    updateAvailableFilters();
                    updateFilterButtons();
                    if (currentView === 'module') {
                        renderCurrentView();
                    }
                });
                // Effacer les filtres de semestre
                clearSemestreFilters.addEventListener('click', () => {
                    selectedSemestres.clear();
                    isFilterActive = selectedGroups.size > 0 || selectedFormateurs.size > 0 || 
                                   selectedSemestres.size > 0 || selectedRegional.size > 0;
                    updateAvailableFilters();
                    updateFilterButtons();
                    if (currentView === 'module') {
                        renderCurrentView();
                    }
                });
                // Effacer les filtres régional
                clearRegionalFilters.addEventListener('click', () => {
                    selectedRegional.clear();
                    isFilterActive = selectedGroups.size > 0 || selectedFormateurs.size > 0 || 
                                   selectedSemestres.size > 0 || selectedRegional.size > 0;
                    updateAvailableFilters();
                    updateFilterButtons();
                    if (currentView === 'module') {
                        renderCurrentView();
                    }
                });
                // Appliquer les filtres
                applyFilters.addEventListener('click', () => {
                    applyAdvancedFilters();
                    filterPopup.classList.remove('show');
                });
                // Fermer le popup en cliquant à l'extérieur
                document.addEventListener('click', (e) => {
                    // Fermer le popup de filtre réel si on clique à l'extérieur
                    if (filterPopup && !filterPopup.contains(e.target) && !toggleFilterBtn.contains(e.target)) {
                        filterPopup.classList.remove('show');
                    }
                    // Fermer le popup de filtre planifié si on clique à l'extérieur
                    if (plannedFilterPopup && !plannedFilterPopup.contains(e.target) && !togglePlannedFilterBtn.contains(e.target)) {
                        plannedFilterPopup.classList.remove('show');
                    }
                });
            }
            
            // Event listeners pour les filtres de l'avancement planifié (indépendants)
            const togglePlannedFilterBtn = document.getElementById('togglePlannedFilterBtn');
            const plannedFilterPopup = document.getElementById('plannedFilterPopup');
            const closePlannedFilterPopup = document.getElementById('closePlannedFilterPopup');
            const clearPlannedGroupFilters = document.getElementById('clearPlannedGroupFilters');
            const clearPlannedFormateurFilters = document.getElementById('clearPlannedFormateurFilters');
            const clearPlannedSemestreFilters = document.getElementById('clearPlannedSemestreFilters');
            const clearPlannedRegionalFilters = document.getElementById('clearPlannedRegionalFilters');
            const applyPlannedFilters = document.getElementById('applyPlannedFilters');
            
            if (togglePlannedFilterBtn && plannedFilterPopup) {
                togglePlannedFilterBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    plannedFilterPopup.classList.toggle('show');
                });
                closePlannedFilterPopup.addEventListener('click', () => {
                    plannedFilterPopup.classList.remove('show');
                });
                // Effacer les filtres de groupe planifié
                clearPlannedGroupFilters.addEventListener('click', () => {
                    plannedSelectedGroups.clear();
                    isPlannedFilterActive = plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0 || 
                                           plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0;
                    updatePlannedAvailableFilters();
                    updatePlannedFilterButtons();
                    if (currentPlannedView === 'module') {
                        renderPlannedView();
                    }
                });
                // Effacer les filtres de formateur planifié
                clearPlannedFormateurFilters.addEventListener('click', () => {
                    plannedSelectedFormateurs.clear();
                    isPlannedFilterActive = plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0 || 
                                           plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0;
                    updatePlannedAvailableFilters();
                    updatePlannedFilterButtons();
                    if (currentPlannedView === 'module') {
                        renderPlannedView();
                    }
                });
                // Effacer les filtres de semestre planifié
                clearPlannedSemestreFilters.addEventListener('click', () => {
                    plannedSelectedSemestres.clear();
                    isPlannedFilterActive = plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0 || 
                                           plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0;
                    updatePlannedAvailableFilters();
                    updatePlannedFilterButtons();
                    if (currentPlannedView === 'module') {
                        renderPlannedView();
                    }
                });
                // Effacer les filtres régional planifié
                clearPlannedRegionalFilters.addEventListener('click', () => {
                    plannedSelectedRegional.clear();
                    isPlannedFilterActive = plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0 || 
                                           plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0;
                    updatePlannedAvailableFilters();
                    updatePlannedFilterButtons();
                    if (currentPlannedView === 'module') {
                        renderPlannedView();
                    }
                });
                // Appliquer les filtres planifiés
                applyPlannedFilters.addEventListener('click', () => {
                    applyPlannedAdvancedFilters();
                    plannedFilterPopup.classList.remove('show');
                });
            }
            // Positionner les indicateurs des switchers
            document.getElementById('viewSwitcherIndicator1').style.left = '2px';
            document.getElementById('viewSwitcherIndicator2').style.left = document.getElementById('viewPlannedByGroupeBtn').offsetLeft + 'px';
        }
        function getInitials(name) { 
            return name ? (name.trim().split(' ').length > 1 ? 
                (name.split(' ')[0][0] + name.split(' ').slice(-1)[0][0]).toUpperCase() : 
                name.substring(0, 2).toUpperCase()) : '--'; 
        }
        function populateUserInfo(userData) { 
            if (!userData) return; 
            document.getElementById('profile-initials').textContent = getInitials(userData.nom); 
            document.getElementById('dropdown-user-name').textContent = userData.nom; 
            document.getElementById('dropdown-user-email').textContent = userData.email; 
        }
        function setupProfileMenu() { 
            const btn = document.getElementById('profile-button'); 
            const menu = document.getElementById('profile-dropdown'); 
            btn?.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                menu.classList.toggle('show'); 
            }); 
            window.addEventListener('click', () => menu.classList.remove('show')); 
        }
        async function loadPageData() {
            const infoBanner = document.getElementById('infoBanner');
            try {
                const [baseRes, avancementRes, plannedRes, statutaryRes] = await Promise.all([
                    fetch('../api/data/get_base_data.php'), 
                    fetch('../api/data/get_avancement_data.php'),
                    fetch('../api/data/get_planned_progress.php'), 
                    fetch('../api/data/get_statutary_hours.php')
                ]);
                const statutaryData = await statutaryRes.json();
                if (statutaryData.success) {
                    statutaryData.data.forEach(item => {
                        const key = getFormattedName(item.nom_formateur);
                        statutaryHoursByFormateur[key] = parseFloat(String(item.masse_horaire_statutaire).replace(',', '.')) || 0;
                    });
                }
                const baseResult = await baseRes.json(), 
                      avancementResult = await avancementRes.json(), 
                      plannedResult = await plannedRes.json();
                if (!baseResult.success || !avancementResult.success) {
                    infoBanner.innerHTML = `Données manquantes. Veuillez finaliser la <a href="setup.html">configuration</a> ou réimporter un fichier.`;
                    document.querySelector('.comparison-container').style.display = 'none';
                    document.getElementById('stats-container').style.display = 'none';
                    return;
                }
                baseData = baseResult.data;
                avancementData = avancementResult.data;
                // Extract date from column A of the data
                const extractedDate = extractDateFromData(avancementData);
                const dateInfo = extractedDate ? ` (Date: ${extractedDate})` : '';
                infoBanner.innerHTML = `Analyse basée sur le fichier : <span class="file-info">${avancementResult.fileName}</span>${dateInfo}.`;
                dataByFormateur = processDataByFormateur(avancementData);
                dataByGroupe = processDataByGroupe(avancementData);
                dataByModule = processDataByModule(avancementData);
                if (plannedResult.success) {
                    plannedData = plannedResult.data;
                    mergePlannedData(dataByFormateur, dataByGroupe, dataByModule, plannedData);
                }
                calculateAndDisplayCardStats(baseData.formateurs, baseData.groupes);
                calculateAndDisplayOverallProgress();
                createAffectationDoughnut(avancementData);
                populateAdvancedFilters();
                renderCurrentView();
                if (plannedResult.success) {
                    renderPlannedView();
                }
                // Initialiser le slider de comparaison
                initComparisonSlider();
                setupEventListeners();
            } catch (error) {
                console.error("Erreur de chargement:", error);
                infoBanner.innerHTML = `Erreur de communication avec le serveur.`;
            }
        }
        function initComparisonSlider() {
            const slider = document.querySelector('.slider');
            const drag = document.querySelector('.drag');
            const realProgress = document.querySelector('.real-progress');
            const plannedProgress = document.querySelector('.planned-progress');
            // Mettre à jour la position du slider
            function updateSliderPosition(value) {
                const position = value + '%';
                realProgress.style.clipPath = `inset(0 ${100 - value}% 0 0)`;
                plannedProgress.style.clipPath = `inset(0 0 0 ${value}%)`;
                drag.style.left = position;
                slider.value = value;
            }
            // Événement pour le slider
            slider.addEventListener('input', function() {
                updateSliderPosition(this.value);
            });
            // Événement pour le drag handle
            let isDragging = false;
            drag.addEventListener('mousedown', function(e) {
                isDragging = true;
                e.preventDefault();
            });
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                const containerRect = document.querySelector('.chart-wrapper').getBoundingClientRect();
                let x = e.clientX - containerRect.left;
                let percent = (x / containerRect.width) * 100;
                // Limiter entre 0 et 100
                percent = Math.max(0, Math.min(100, percent));
                updateSliderPosition(percent);
            });
            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
            // Pour les écrans tactiles
            drag.addEventListener('touchstart', function(e) {
                isDragging = true;
                e.preventDefault();
            });
            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                const containerRect = document.querySelector('.chart-wrapper').getBoundingClientRect();
                const touch = e.touches[0];
                let x = touch.clientX - containerRect.left;
                let percent = (x / containerRect.width) * 100;
                // Limiter entre 0 et 100
                percent = Math.max(0, Math.min(100, percent));
                updateSliderPosition(percent);
                e.preventDefault();
            });
            document.addEventListener('touchend', function() {
                isDragging = false;
            });
            // Initialiser à 50%
            updateSliderPosition(50);
        }
        function mergePlannedData(formateurData, groupeData, moduleData, plannedStats) {
            // Initialize planned hours for formateur and groupe data
            Object.values(formateurData).forEach(d => {
                d.planifieG = 0;
                d.planifiePresentiel = 0;
                d.planifieSynchrone = 0;
            });
            Object.values(groupeData).forEach(d => {
                d.planifieG = 0;
                d.planifiePresentiel = 0;
                d.planifieSynchrone = 0;
            });
            
            // Use detailed progress data if available, otherwise fall back to simple totals
            const detailedFormateurData = plannedStats.detailedProgressByFormateur || {};
            const detailedGroupeData = plannedStats.detailedProgressByGroup || {};
            const moduleProgressData = plannedStats.progressByModule || {};
            
            // Process formateur planned data
            for (const rawName in plannedStats.progressByFormateur) {
                const formattedName = getFormattedName(rawName);
                let targetFormateur = null;
                
                if (formateurData[formattedName]) {
                    targetFormateur = formateurData[formattedName];
                } else {
                    const matchingKey = Object.keys(formateurData).find(key => key.includes(formattedName));
                    if (matchingKey) targetFormateur = formateurData[matchingKey];
                }
                
                if (targetFormateur) {
                    targetFormateur.planifieG = plannedStats.progressByFormateur[rawName];
                    
                    // Use detailed data if available
                    if (detailedFormateurData[rawName]) {
                        targetFormateur.planifiePresentiel = detailedFormateurData[rawName].presentiel || 0;
                        targetFormateur.planifieSynchrone = detailedFormateurData[rawName].synchrone || 0;
                    } else {
                        // Fallback: distribute planned hours based on assigned ratios
                        if (targetFormateur.affecteG > 0) {
                            const presentielRatio = (targetFormateur.affectePresentiel || 0) / targetFormateur.affecteG;
                            const synchroneRatio = (targetFormateur.affecteSynchrone || 0) / targetFormateur.affecteG;
                            
                            targetFormateur.planifiePresentiel = targetFormateur.planifieG * presentielRatio;
                            targetFormateur.planifieSynchrone = targetFormateur.planifieG * synchroneRatio;
                        }
                    }
                }
            }
            
            // Process groupe planned data
            for (const rawName in plannedStats.progressByGroup) {
                const formattedName = getFormattedName(rawName);
                if (groupeData[formattedName]) {
                    const targetGroupe = groupeData[formattedName];
                    targetGroupe.planifieG = plannedStats.progressByGroup[rawName];
                    
                    // Use detailed data if available
                    if (detailedGroupeData[rawName]) {
                        targetGroupe.planifiePresentiel = detailedGroupeData[rawName].presentiel || 0;
                        targetGroupe.planifieSynchrone = detailedGroupeData[rawName].synchrone || 0;
                    } else {
                        // Fallback: distribute planned hours based on assigned ratios
                        if (targetGroupe.affecteG > 0) {
                            const presentielRatio = (targetGroupe.affectePresentiel || 0) / targetGroupe.affecteG;
                            const synchroneRatio = (targetGroupe.affecteSynchrone || 0) / targetGroupe.affecteG;
                            
                            targetGroupe.planifiePresentiel = targetGroupe.planifieG * presentielRatio;
                            targetGroupe.planifieSynchrone = targetGroupe.planifieG * synchroneRatio;
                        }
                    }
                }
            }
            
            // Process module planned data
            for (const moduleCode in moduleData) {
                let totalPlanifieModule = 0;
                let totalPlanifiePresentiel = 0;
                let totalPlanifieSynchrone = 0;
                
                for (const groupName in moduleData[moduleCode]) {
                    if (groupName === 'tous_les_groupes') continue;
                    
                    const moduleInGroup = moduleData[moduleCode][groupName];
                    
                    // Initialize planned hours
                    moduleInGroup.planifieG = 0;
                    moduleInGroup.planifiePresentiel = 0;
                    moduleInGroup.planifieSynchrone = 0;
                    
                    // Use direct module progress data if available
                    if (moduleProgressData[moduleCode] && moduleProgressData[moduleCode][groupName]) {
                        const moduleGroupData = moduleProgressData[moduleCode][groupName];
                        moduleInGroup.planifieG = moduleGroupData.total || 0;
                        moduleInGroup.planifiePresentiel = moduleGroupData.presentiel || 0;
                        moduleInGroup.planifieSynchrone = moduleGroupData.synchrone || 0;
                    } else {
                        // Fallback: proportional distribution based on group data
                        const groupTotals = groupeData[groupName];
                        if (groupTotals && groupTotals.affecteG > 0) {
                            const proportion = moduleInGroup.affecteG / groupTotals.affecteG;
                            const totalPlannedForGroup = groupTotals.planifieG || 0;
                            moduleInGroup.planifieG = totalPlannedForGroup * proportion;
                            
                            // Distribute planned hours between presentiel and synchrone based on assigned ratios from Excel data
                            if (moduleInGroup.affecteG > 0) {
                                const presentielRatio = (moduleInGroup.affectePresentiel || 0) / moduleInGroup.affecteG;
                                const synchroneRatio = (moduleInGroup.affecteSynchrone || 0) / moduleInGroup.affecteG;
                                
                                moduleInGroup.planifiePresentiel = moduleInGroup.planifieG * presentielRatio;
                                moduleInGroup.planifieSynchrone = moduleInGroup.planifieG * synchroneRatio;
                            }
                        }
                    }
                    
                    moduleInGroup.tauxPlanification = moduleInGroup.affecteG > 0 ? (moduleInGroup.planifieG / moduleInGroup.affecteG) * 100 : 0;
                    totalPlanifieModule += moduleInGroup.planifieG;
                    totalPlanifiePresentiel += moduleInGroup.planifiePresentiel || 0;
                    totalPlanifieSynchrone += moduleInGroup.planifieSynchrone || 0;
                }
                
                moduleData[moduleCode]['tous_les_groupes'].planifieG = totalPlanifieModule;
                moduleData[moduleCode]['tous_les_groupes'].planifiePresentiel = totalPlanifiePresentiel;
                moduleData[moduleCode]['tous_les_groupes'].planifieSynchrone = totalPlanifieSynchrone;
                
                const totalAffecteModule = moduleData[moduleCode]['tous_les_groupes'].affecteG;
                moduleData[moduleCode]['tous_les_groupes'].tauxPlanification = totalAffecteModule > 0 ? (totalPlanifieModule / totalAffecteModule) * 100 : 0;
            }
            Object.values(formateurData).forEach(d => d.tauxPlanification = d.affecteG > 0 ? (d.planifieG / d.affecteG) * 100 : 0);
            Object.values(groupeData).forEach(d => d.tauxPlanification = d.affecteG > 0 ? (d.planifieG / d.affecteG) * 100 : 0);
            for (const moduleCode in moduleData) {
                let totalPlanifieModule = 0;
                let totalPlanifiePresentiel = 0;
                let totalPlanifieSynchrone = 0;
                
                for (const groupName in moduleData[moduleCode]) {
                    if (groupName === 'tous_les_groupes') continue;
                    const groupTotals = groupeData[groupName];
                    const moduleInGroup = moduleData[moduleCode][groupName];
                    
                    // Initialize planned hours
                    moduleInGroup.planifieG = 0;
                    moduleInGroup.planifiePresentiel = 0;
                    moduleInGroup.planifieSynchrone = 0;
                    
                    if (groupTotals && groupTotals.affecteG > 0) {
                        const proportion = moduleInGroup.affecteG / groupTotals.affecteG;
                        const totalPlannedForGroup = (groupTotals.planifieG || 0) * proportion;
                        moduleInGroup.planifieG = totalPlannedForGroup;
                        
                        // Distribute planned hours between presentiel and synchrone based on assigned ratios from Excel data
                        if (moduleInGroup.affecteG > 0) {
                            const presentielRatio = (moduleInGroup.affectePresentiel || 0) / moduleInGroup.affecteG;
                            const synchroneRatio = (moduleInGroup.affecteSynchrone || 0) / moduleInGroup.affecteG;
                            
                            moduleInGroup.planifiePresentiel = totalPlannedForGroup * presentielRatio;
                            moduleInGroup.planifieSynchrone = totalPlannedForGroup * synchroneRatio;
                        }
                    }
                    
                    moduleInGroup.tauxPlanification = moduleInGroup.affecteG > 0 ? (moduleInGroup.planifieG / moduleInGroup.affecteG) * 100 : 0;
                    totalPlanifieModule += moduleInGroup.planifieG;
                    totalPlanifiePresentiel += moduleInGroup.planifiePresentiel || 0;
                    totalPlanifieSynchrone += moduleInGroup.planifieSynchrone || 0;
                }
                
                moduleData[moduleCode]['tous_les_groupes'].planifieG = totalPlanifieModule;
                moduleData[moduleCode]['tous_les_groupes'].planifiePresentiel = totalPlanifiePresentiel;
                moduleData[moduleCode]['tous_les_groupes'].planifieSynchrone = totalPlanifieSynchrone;
                
                const totalAffecteModule = moduleData[moduleCode]['tous_les_groupes'].affecteG;
                moduleData[moduleCode]['tous_les_groupes'].tauxPlanification = totalAffecteModule > 0 ? (totalPlanifieModule / totalAffecteModule) * 100 : 0;
            }
            
            // Calculate rates for formateur and groupe data
            Object.keys(formateurData).forEach(n => {
                const data = formateurData[n];
                data.tauxAvancement = data.affecteG > 0 ? (data.realiseG / data.affecteG) * 100 : 0;
                data.tauxPlanification = data.affecteG > 0 ? (data.planifieG / data.affecteG) * 100 : 0;
            });
            
            Object.keys(groupeData).forEach(n => {
                const data = groupeData[n];
                data.tauxAvancement = data.affecteG > 0 ? (data.realiseG / data.affecteG) * 100 : 0;
                data.tauxPlanification = data.affecteG > 0 ? (data.planifieG / data.affecteG) * 100 : 0;
            });
        }
        function extractDateFromData(data) {
            // Extract date from first row, column A (index 0)
            if (data && Array.isArray(data) && data.length > 0 && Array.isArray(data[0]) && data[0][0]) {
                const dateValue = data[0][0];
                // Handle different date formats
                if (dateValue instanceof Date) {
                    return dateValue.toLocaleDateString('fr-FR');
                } else if (typeof dateValue === 'string' || typeof dateValue === 'number') {
                    // Try to parse the date
                    const date = new Date(dateValue);
                    if (!isNaN(date.getTime())) {
                        return date.toLocaleDateString('fr-FR');
                    }
                }
                // If parsing fails, return the raw value as string
                return String(dateValue);
            }
            return null;
        }
        // Function to get formateur name for a module based on current filter context
        function getModuleFormateur(moduleName, selectedGroup = null, isPlanned = false) {
            if (!baseData || !baseData.affectations) {
                return null;
            }
            
            // Use the appropriate filter selections based on whether it's planned or real progress
            const currentSelectedGroups = isPlanned ? plannedSelectedGroups : selectedGroups;
            const currentSelectedFormateurs = isPlanned ? plannedSelectedFormateurs : selectedFormateurs;
            
            // If a specific group is provided, use it
            let targetGroup = selectedGroup;
            
            // Otherwise, try to get the group from current filter context
            if (!targetGroup && currentSelectedGroups.size > 0) {
                targetGroup = Array.from(currentSelectedGroups)[0];
            }
            
            // If formateur is selected in filters, prefer that formateur
            if (currentSelectedFormateurs.size > 0) {
                const selectedFormateur = Array.from(currentSelectedFormateurs)[0];
                
                // Find affectation that matches the module and selected formateur
                const affectation = baseData.affectations.find(a => {
                    const formateurMatch = getFormattedName(a.formateur) === selectedFormateur;
                    const moduleMatch = a.module === moduleName;
                    
                    if (targetGroup) {
                        const groupeMatch = getFormattedName(a.groupe) === targetGroup;
                        return formateurMatch && moduleMatch && groupeMatch;
                    }
                    
                    return formateurMatch && moduleMatch;
                });
                
                if (affectation) {
                    return getFormattedName(affectation.formateur);
                }
            }
            
            // Fallback: find any formateur for this module and group combination
            const affectation = baseData.affectations.find(a => {
                const moduleMatch = a.module === moduleName;
                
                if (targetGroup) {
                    const groupeMatch = getFormattedName(a.groupe) === targetGroup;
                    return moduleMatch && groupeMatch;
                }
                
                return moduleMatch;
            });
            
            if (affectation) {
                return getFormattedName(affectation.formateur);
            }
            
            return null;
        }
        
        // Function to get module semester from base data - following emploi.html proven approach
        function getModuleSemester(formateur, groupe, module) {
            if (!baseData || !baseData.affectations || !module) {
                return null;
            }

            // If formateur and groupe are provided, use exact match logic like emploi.html
            if (formateur && groupe) {
                const subGroups = groupe.trim().split(/\s+/).filter(Boolean);
                for (const subGroup of subGroups) {
                    const affectation = baseData.affectations.find(a =>
                        a.formateur === formateur &&
                        a.groupe === subGroup &&
                        a.module === module
                    );

                    if (affectation) {
                        // Use parseFloat for consistency with emploi.html approach
                        const s1Hours = parseFloat(affectation.s1_heures) || 0;
                        const s2Hours = parseFloat(affectation.s2_heures) || 0;

                        if (s1Hours > 0 && s2Hours > 0) return 'Annual';
                        if (s1Hours > 0) return 'S1';
                        if (s2Hours > 0) return 'S2';
                    }
                }
            } else {
                // Fallback: Find any affectation for this module (dashboard view flexibility)
                const affectation = baseData.affectations.find(a => a.module === module);

                if (affectation) {
                    const s1Hours = parseFloat(affectation.s1_heures) || 0;
                    const s2Hours = parseFloat(affectation.s2_heures) || 0;

                    if (s1Hours > 0 && s2Hours > 0) return 'Annual';
                    if (s1Hours > 0) return 'S1';
                    if (s2Hours > 0) return 'S2';
                }
            }
            return null;
        }

        // Function to check if module is regional - context-aware logic
        function isModuleRegional(formateur, groupe, module) {
            if (!baseData || !baseData.affectations || !module) {
                return false;
            }

            // If formateur and groupe are provided, use exact match logic
            if (formateur && groupe) {
                const subGroups = groupe.trim().split(/\s+/).filter(Boolean);
                for (const subGroup of subGroups) {
                    const affectation = baseData.affectations.find(a =>
                        a.formateur === formateur &&
                        a.groupe === subGroup &&
                        a.module === module
                    );

                    if (affectation && affectation.hasOwnProperty('est_regional')) {
                        const value = affectation.est_regional;
                        return value === true || value == 1 || String(value).toLowerCase() === 'true';
                    }
                }
                return false;
            }
            
            // For dashboard view: if we have a selected group context, use it
            if (selectedGroups.size > 0) {
                const contextGroup = Array.from(selectedGroups)[0];
                const contextAffectations = baseData.affectations.filter(a => 
                    a.module === module && getFormattedName(a.groupe) === contextGroup
                );
                
                if (contextAffectations.length > 0) {
                    // Use the first affectation for this group
                    const affectation = contextAffectations[0];
                    if (affectation.hasOwnProperty('est_regional')) {
                        const value = affectation.est_regional;
                        return value === true || value == 1 || String(value).toLowerCase() === 'true';
                    }
                }
            }
            
            // Fallback: majority-based logic across all affectations
            const moduleAffectations = baseData.affectations.filter(a => a.module === module);
            if (moduleAffectations.length > 0) {
                let regionalCount = 0;
                let totalCount = 0;
                
                moduleAffectations.forEach(affectation => {
                    if (affectation.hasOwnProperty('est_regional')) {
                        totalCount++;
                        const value = affectation.est_regional;
                        const isRegional = value === true || value == 1 || String(value).toLowerCase() === 'true';
                        if (isRegional) regionalCount++;
                    }
                });
                
                return totalCount > 0 && (regionalCount / totalCount) > 0.5;
            }
            
            return false;
        }
        // Function to create module labels (only the module name, no badges)
        function createModuleLabel(moduleName) {
            if (!moduleName) return '';
            // Supprimer les parties de nom de module qui pourraient interférer avec l'affichage
            return moduleName.toString().trim();
        }
        const getFormattedName = (name) => name ? name.trim().toUpperCase().split(/\s+/).filter(Boolean).join(' ') : '';
        const parseHour = (val) => parseFloat(String(val).replace(',', '.')) || 0;
        function processDataByFormateur(rows) {
            const data = {};
            rows.forEach(r => {
                if (!Array.isArray(r)) return;
                new Set([getFormattedName(r[20]), getFormattedName(r[22])].filter(Boolean)).forEach(n => {
                    if (!data[n]) {
                        data[n] = { 
                            affecteG: 0, realiseG: 0,
                            affectePresentiel: 0, realisePresentiel: 0,
                            affecteSynchrone: 0, realiseSynchrone: 0
                        };
                    }
                    
                    // Extract hours from specific Excel columns
                    const affectePresentiel = parseHour(r[35]);  // Column AJ (MH Affectée Présentiel)
                    const affecteSynchrone = parseHour(r[36]);   // Column AK (MH Affectée Sync)
                    const realisePresentiel = parseHour(r[38]);  // Column AM (MH Réalisée Présentiel)
                    const realiseSynchrone = parseHour(r[39]);   // Column AN (MH Réalisée Sync)
                    
                    // Accumulate the detailed hours
                    data[n].affectePresentiel += affectePresentiel;
                    data[n].affecteSynchrone += affecteSynchrone;
                    data[n].realisePresentiel += realisePresentiel;
                    data[n].realiseSynchrone += realiseSynchrone;
                    
                    // Also keep the total for backward compatibility
                    data[n].affecteG += parseHour(r[37]);
                    data[n].realiseG += parseHour(r[40]);
                });
            });
            Object.keys(data).forEach(n => data[n].tauxAvancement = data[n].affecteG > 0 ? (data[n].realiseG / data[n].affecteG) * 100 : 0);
            return data;
        }
        function processDataByGroupe(rows) { 
            const data = {}; 
            rows.forEach(r => { 
                const n = getFormattedName(r[8]); 
                if (!n || !Array.isArray(r)) return; 
                if (!data[n]) {
                    data[n] = { 
                        affecteG: 0, realiseG: 0,
                        affectePresentiel: 0, realisePresentiel: 0,
                        affecteSynchrone: 0, realiseSynchrone: 0
                    }; 
                }
                
                // Extract hours from specific Excel columns
                const affectePresentiel = parseHour(r[35]);  // Column AJ (MH Affectée Présentiel)
                const affecteSynchrone = parseHour(r[36]);   // Column AK (MH Affectée Sync)
                const realisePresentiel = parseHour(r[38]);  // Column AM (MH Réalisée Présentiel)
                const realiseSynchrone = parseHour(r[39]);   // Column AN (MH Réalisée Sync)
                
                // Accumulate the detailed hours
                data[n].affectePresentiel += affectePresentiel;
                data[n].affecteSynchrone += affecteSynchrone;
                data[n].realisePresentiel += realisePresentiel;
                data[n].realiseSynchrone += realiseSynchrone;
                
                // Also keep the total for backward compatibility
                data[n].affecteG += parseHour(r[37]); 
                data[n].realiseG += parseHour(r[40]); 
            }); 
            return data; 
        }
        function processDataByModule(rows) { 
            const data = {}; 
            
            // First, initialize all modules from baseData.affectations with zero values
            if (baseData && baseData.affectations) {
                baseData.affectations.forEach(affectation => {
                    const module = affectation.module;
                    const groupe = getFormattedName(affectation.groupe);
                    
                    if (module && groupe) {
                        // Initialize module if it doesn't exist
                        if (!data[module]) {
                            data[module] = { 'tous_les_groupes': { 
                                affecteG: 0, realiseG: 0,
                                affectePresentiel: 0, realisePresentiel: 0,
                                affecteSynchrone: 0, realiseSynchrone: 0
                            } };
                        }
                        // Initialize group for this module if it doesn't exist
                        if (!data[module][groupe]) {
                            data[module][groupe] = { 
                                affecteG: 0, realiseG: 0,
                                affectePresentiel: 0, realisePresentiel: 0,
                                affecteSynchrone: 0, realiseSynchrone: 0
                            };
                        }
                    }
                });
            }
            
            // Process the advancement data to extract hours from specific Excel columns
            rows.forEach(r => { 
                const m = r[16], g = getFormattedName(r[8]); 
                if (!m || !g || !Array.isArray(r)) return; 
                
                // Initialize module if it doesn't exist (fallback for modules not in baseData)
                if (!data[m]) data[m] = { 'tous_les_groupes': { 
                    affecteG: 0, realiseG: 0,
                    affectePresentiel: 0, realisePresentiel: 0,
                    affecteSynchrone: 0, realiseSynchrone: 0
                } }; 
                if (!data[m][g]) data[m][g] = { 
                    affecteG: 0, realiseG: 0,
                    affectePresentiel: 0, realisePresentiel: 0,
                    affecteSynchrone: 0, realiseSynchrone: 0
                }; 
                
                // Extract hours from specific Excel columns
                const affectePresentiel = parseHour(r[35]);  // Column AJ (MH Affectée Présentiel)
                const affecteSynchrone = parseHour(r[36]);   // Column AK (MH Affectée Sync)
                const realisePresentiel = parseHour(r[38]);  // Column AM (MH Réalisée Présentiel)
                const realiseSynchrone = parseHour(r[39]);   // Column AN (MH Réalisée Sync)
                
                // Total hours (for backward compatibility)
                const totalAffecte = affectePresentiel + affecteSynchrone;
                const totalRealise = realisePresentiel + realiseSynchrone;
                
                // Update group-specific data
                data[m][g].affectePresentiel += affectePresentiel;
                data[m][g].affecteSynchrone += affecteSynchrone;
                data[m][g].realisePresentiel += realisePresentiel;
                data[m][g].realiseSynchrone += realiseSynchrone;
                data[m][g].affecteG += totalAffecte;
                data[m][g].realiseG += totalRealise;
                
                // Update global totals for this module
                data[m]['tous_les_groupes'].affectePresentiel += affectePresentiel;
                data[m]['tous_les_groupes'].affecteSynchrone += affecteSynchrone;
                data[m]['tous_les_groupes'].realisePresentiel += realisePresentiel;
                data[m]['tous_les_groupes'].realiseSynchrone += realiseSynchrone;
                data[m]['tous_les_groupes'].affecteG += totalAffecte;
                data[m]['tous_les_groupes'].realiseG += totalRealise;
            }); 
            return data; 
        }
        function calculateAndDisplayCardStats(formateurs, groupes) { 
            document.getElementById('stats-formateurs').textContent = (formateurs || []).length; 
            document.getElementById('stats-groupes').textContent = (groupes || []).length; 
        }
        function calculateAndDisplayOverallProgress() { 
            let totalA = 0, totalR = 0; 
            Object.values(dataByGroupe).forEach(g => { 
                totalA += g.affecteG || 0; 
                totalR += g.realiseG || 0; 
            }); 
            const globalRate = totalA > 0 ? (totalR / totalA) * 100 : 0; 
            document.getElementById('global-progress-rate').textContent = `${globalRate.toFixed(1)}%`; 
        }
                function createAffectationDoughnut(rows) {
            let affectesCount = 0; 
            const total = rows.length;
            rows.forEach(r => { 
                if (Array.isArray(r) && r[20] && String(r[20]).trim() !== '') affectesCount++; 
            }); 
            const nonAffectesCount = total - affectesCount;
            const affectationRate = total > 0 ? (affectesCount / total * 100) : 0;
            // Mettre à jour les textes
            document.getElementById('doughnut-percent').textContent = `${affectationRate.toFixed(1)}%`;
            document.getElementById('legend-affectes-value').textContent = affectesCount;
            document.getElementById('legend-non-affectes-value').textContent = nonAffectesCount;
            document.getElementById('legend-total-value').textContent = total; // Nouveau champ pour le total
            // Mettre à jour la barre de progression
            const progressBarFill = document.getElementById('progress-bar-fill');
            if(progressBarFill) {
                progressBarFill.style.width = `${affectationRate}%`;
            }
            // Plus besoin de créer un graphique Chart.js
            if (affectationDoughnutChart) {
                affectationDoughnutChart.destroy();
                affectationDoughnutChart = null;
            }
        }
        function switchView(view) { 
            currentView = view; 
            const btns = document.querySelectorAll('.view-switcher-btn'); 
            btns.forEach(btn => btn.classList.remove('active')); 
            const activeBtn = document.getElementById(`viewBy${view.charAt(0).toUpperCase() + view.slice(1)}Btn`); 
            activeBtn.classList.add('active'); 
            
            // Gérer le padding du conteneur selon la vue
            const realProgressContainer = document.querySelector('.chart-container.real-progress');
            if (view === 'module') {
                realProgressContainer.classList.add('module-view');
            } else {
                realProgressContainer.classList.remove('module-view');
            }
            
            // Show/hide filter button and close popup based on view
            const filterBtn = document.getElementById('toggleFilterBtn');
            const filterPopup = document.getElementById('filterPopup');
            if (view === 'module') {
                filterBtn.style.display = 'flex';
            } else {
                filterBtn.style.display = 'none';
                // Fermer le popup et réinitialiser les filtres quand on quitte la vue module
                filterPopup.classList.remove('show');
                selectedGroups.clear();
                selectedFormateurs.clear();
                selectedSemestres.clear();
                selectedRegional.clear();
                isFilterActive = false;
                updateFilterButtons();
            }
            document.getElementById('viewSwitcherIndicator1').style.left = activeBtn.offsetLeft + 'px'; 
            renderCurrentView(); 
        }
        function renderCurrentView() { 
            let data, title; 
            if (currentView === 'module') { 
                // Pour la vue module, appliquer les filtres avec intersection
                let selectedGroup = null;
                
                // Si des groupes sont sélectionnés via filtres, utiliser le premier
                if (selectedGroups.size > 0) {
                    selectedGroup = Array.from(selectedGroups)[0];
                } else {
                    // Sélectionner automatiquement le premier groupe disponible
                    const availableGroups = getAvailableGroupes();
                    if (availableGroups.length > 0) {
                        selectedGroup = availableGroups[0];
                        // Ajouter le premier groupe aux groupes sélectionnés pour maintenir la cohérence
                        selectedGroups.add(selectedGroup);
                        // Mettre à jour l'indicateur de filtre actif
                        isFilterActive = selectedGroups.size > 0 || selectedFormateurs.size > 0 || 
                                       selectedSemestres.size > 0 || selectedRegional.size > 0;
                        // Mettre à jour les filtres pour refléter cette sélection
                        updateAvailableFilters();
                        updateFilterButtons();
                    }
                }
                
                // Obtenir les modules qui sont à l'intersection des sélections (après avoir potentiellement ajouté un groupe)
                const intersectingModules = getIntersectingModules();
                
                if (selectedGroup && selectedGroup !== 'tous_les_groupes') {
                    title = `Avancement Réel par Module (${selectedGroup})`;
                    if (isFilterActive) {
                        const filterInfo = [];
                        if (selectedGroups.size > 0 || selectedFormateurs.size > 0) {
                            filterInfo.push(`${intersectingModules.length} module(s) à l'intersection`);
                        }
                        if (selectedSemestres.size > 0) {
                            filterInfo.push(`Semestre: ${Array.from(selectedSemestres).join(', ')}`);
                        }
                        if (selectedRegional.size > 0) {
                            filterInfo.push(`${Array.from(selectedRegional).join(', ')}`);
                        }
                        if (filterInfo.length > 0) {
                            title += ` - Filtré (${filterInfo.join(', ')})`;
                        }
                    }
                    
                    data = {};
                    // Utiliser les modules intersectants pour le groupe sélectionné
                    intersectingModules.forEach(moduleCode => {
                        if (dataByModule[moduleCode] && dataByModule[moduleCode][selectedGroup]) {
                            data[moduleCode] = dataByModule[moduleCode][selectedGroup];
                        } else if (dataByModule[moduleCode]) {
                            // Créer une entrée avec valeurs zéro pour les modules sans données
                            data[moduleCode] = { affecteG: 0, realiseG: 0, tauxAvancement: 0 };
                        }
                    });
                } else if (selectedGroup === 'tous_les_groupes') {
                    data = {};
                    // Agréger les données de tous les groupes pour chaque module
                    intersectingModules.forEach(moduleCode => {
                        if (dataByModule[moduleCode] && dataByModule[moduleCode]['tous_les_groupes']) {
                            data[moduleCode] = dataByModule[moduleCode]['tous_les_groupes'];
                        } else {
                            data[moduleCode] = { affecteG: 0, realiseG: 0, tauxAvancement: 0 };
                        }
                    });
                } else {
                    // Aucun groupe disponible
                    title = `Aucun groupe disponible`;
                    data = {};
                }
                
                // Si aucun module intersectant avec filtres actifs, afficher un message
                if (Object.keys(data).length === 0 && isFilterActive) {
                    title = `Aucun module à l'intersection des filtres sélectionnés`;
                }
            } else { 
                // Pour les autres vues, ne pas appliquer les filtres avancés
                data = currentView === 'groupe' ? dataByGroupe : dataByFormateur; 
                title = `Avancement Réel par ${currentView === 'groupe' ? 'Groupe' : 'Formateur'}`; 
            } 
            const metrics = { 
                totalKey: 'affecteG', 
                completedKey: 'realiseG', 
                rateKey: 'tauxAvancement', 
                totalLabel: 'MH Affectée', 
                completedLabel: 'MH Réalisée', 
                rateLabel: "Taux d'Avancement (%)", 
                totalColor: 'rgba(13, 110, 253, 0.6)', 
                completedColor: 'rgba(25, 135, 84, 0.6)', 
                rateColor: '#fd7e14' 
            }; 
            displayComparisonChart('globalAvancementChart', 'globalChart', data, title, currentView, metrics); 
        }
        function switchPlannedView(view) { 
            currentPlannedView = view; 
            const btns = document.querySelectorAll('.view-switcher-btn'); 
            btns.forEach(btn => btn.classList.remove('active')); 
            const activeBtn = document.getElementById(`viewPlannedBy${view.charAt(0).toUpperCase() + view.slice(1)}Btn`); 
            activeBtn.classList.add('active'); 
            
            // Gérer le padding du conteneur selon la vue
            const plannedProgressContainer = document.querySelector('.chart-container.planned-progress');
            if (view === 'module') {
                plannedProgressContainer.classList.add('module-view');
            } else {
                plannedProgressContainer.classList.remove('module-view');
            }
            
            // Show/hide filter button and close popup based on view
            const plannedFilterBtn = document.getElementById('togglePlannedFilterBtn');
            const plannedFilterPopup = document.getElementById('plannedFilterPopup');
            if (view === 'module') {
                plannedFilterBtn.style.display = 'flex';
            } else {
                plannedFilterBtn.style.display = 'none';
                // Fermer le popup et réinitialiser les filtres quand on quitte la vue module
                plannedFilterPopup.classList.remove('show');
                plannedSelectedGroups.clear();
                plannedSelectedFormateurs.clear();
                plannedSelectedSemestres.clear();
                plannedSelectedRegional.clear();
                isPlannedFilterActive = false;
                updatePlannedFilterButtons();
            }
            
            document.getElementById('viewSwitcherIndicator2').style.left = activeBtn.offsetLeft + 'px'; 
            renderPlannedView(); 
        }
        function renderPlannedView() { 
            if (!plannedData) {
                console.log('Planned data not available, showing message');
                // Afficher un message indiquant que les données planifiées ne sont pas disponibles
                const title = 'Données planifiées non disponibles';
                const data = {};
                const metrics = { 
                    totalKey: 'affecteG', 
                    completedKey: 'planifieG', 
                    rateKey: 'tauxPlanification', 
                    totalLabel: 'MH Totale', 
                    completedLabel: 'MH Planifiée', 
                    rateLabel: 'Taux de Planification (%)', 
                    totalColor: 'rgba(108, 117, 125, 0.6)', 
                    completedColor: 'rgba(13, 202, 240, 0.6)', 
                    rateColor: '#d63384' 
                }; 
                displayComparisonChart('plannedProgressChart', 'plannedChart', data, title, currentPlannedView, metrics);
                return;
            } 
            let data, title; 
            if (currentPlannedView === 'module') { 
                // Pour la vue module, appliquer les filtres avec intersection comme pour l'avancement réel
                let selectedGroup = null;
                
                // Si des groupes sont sélectionnés via filtres, utiliser le premier
                if (plannedSelectedGroups.size > 0) {
                    selectedGroup = Array.from(plannedSelectedGroups)[0];
                } else {
                    // Sélectionner automatiquement le premier groupe disponible
                    const availableGroups = Object.keys(dataByGroupe).sort();
                    if (availableGroups.length > 0) {
                        selectedGroup = availableGroups[0];
                        // Ajouter le premier groupe aux groupes sélectionnés pour maintenir la cohérence
                        plannedSelectedGroups.add(selectedGroup);
                        // Mettre à jour l'indicateur de filtre actif
                        isPlannedFilterActive = plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0 || 
                                              plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0;
                        // Mettre à jour les filtres pour refléter cette sélection
                        updatePlannedAvailableFilters();
                        updatePlannedFilterButtons();
                    }
                }
                
                // Obtenir les modules qui sont à l'intersection des sélections (après avoir potentiellement ajouté un groupe)
                const intersectingModules = getPlannedIntersectingModules();
                console.log('Planned view - Selected group:', selectedGroup);
                console.log('Planned view - Intersecting modules:', intersectingModules);
                console.log('Planned view - isPlannedFilterActive:', isPlannedFilterActive);
                
                if (selectedGroup && selectedGroup !== 'tous_les_groupes') {
                    title = `Avancement Planifié par Module (${selectedGroup})`;
                    if (isPlannedFilterActive) {
                        const filterInfo = [];
                        if (plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0) {
                            filterInfo.push(`${intersectingModules.length} module(s) à l'intersection`);
                        }
                        if (plannedSelectedSemestres.size > 0) {
                            filterInfo.push(`Semestre: ${Array.from(plannedSelectedSemestres).join(', ')}`);
                        }
                        if (plannedSelectedRegional.size > 0) {
                            filterInfo.push(`${Array.from(plannedSelectedRegional).join(', ')}`);
                        }
                        if (filterInfo.length > 0) {
                            title += ` - Filtré (${filterInfo.join(', ')})`;
                        }
                    }
                    
                    data = {};
                    // Utiliser les modules intersectants pour le groupe sélectionné
                    intersectingModules.forEach(moduleCode => {
                        if (dataByModule[moduleCode] && dataByModule[moduleCode][selectedGroup]) {
                            data[moduleCode] = dataByModule[moduleCode][selectedGroup];
                        } else if (dataByModule[moduleCode]) {
                            // Créer une entrée avec valeurs zéro pour les modules sans données
                            data[moduleCode] = { affecteG: 0, planifieG: 0, tauxPlanification: 0 };
                        }
                    });
                } else if (selectedGroup === 'tous_les_groupes') {
                    data = {};
                    // Agréger les données de tous les groupes pour chaque module
                    intersectingModules.forEach(moduleCode => {
                        if (dataByModule[moduleCode] && dataByModule[moduleCode]['tous_les_groupes']) {
                            data[moduleCode] = dataByModule[moduleCode]['tous_les_groupes'];
                        } else {
                            data[moduleCode] = { affecteG: 0, planifieG: 0, tauxPlanification: 0 };
                        }
                    });
                } else {
                    // Aucun groupe disponible
                    title = `Aucun groupe disponible`;
                    data = {};
                }
                
                // Si aucun module intersectant avec filtres actifs, afficher un message
                if (Object.keys(data).length === 0 && isPlannedFilterActive) {
                    title = `Aucun module à l'intersection des filtres sélectionnés`;
                }
            } else { 
                data = currentPlannedView === 'groupe' ? dataByGroupe : dataByFormateur; 
                title = `Avancement Planifié par ${currentPlannedView === 'groupe' ? 'Groupe' : 'Formateur'}`; 
            } 
            const metrics = { 
                totalKey: 'affecteG', 
                completedKey: 'planifieG', 
                rateKey: 'tauxPlanification', 
                totalLabel: 'MH Totale', 
                completedLabel: 'MH Planifiée', 
                rateLabel: 'Taux de Planification (%)', 
                totalColor: 'rgba(108, 117, 125, 0.6)', 
                completedColor: 'rgba(13, 202, 240, 0.6)', 
                rateColor: '#d63384' 
            }; 
            displayComparisonChart('plannedProgressChart', 'plannedChart', data, title, currentPlannedView, metrics); 
        }
        function buildGroupeFormateurRelations() {
            groupeFormateurRelations = {};
            formateurGroupeRelations = {};
            moduleRelations = {};
            groupeModuleRelations = {};
            formateurModuleRelations = {};
            
            // Initialiser les structures
            Object.keys(dataByGroupe).forEach(groupe => {
                groupeFormateurRelations[groupe] = new Set();
                groupeModuleRelations[groupe] = new Set();
            });
            Object.keys(dataByFormateur).forEach(formateur => {
                formateurGroupeRelations[formateur] = new Set();
                formateurModuleRelations[formateur] = new Set();
            });
            
            // Analyser les données de base pour établir les relations
            // Utiliser baseData.affectations si disponible pour des relations plus précises
            if (baseData.affectations && Array.isArray(baseData.affectations)) {
                baseData.affectations.forEach(affectation => {
                    const groupe = getFormattedName(affectation.groupe);
                    const formateur = getFormattedName(affectation.formateur);
                    const module = affectation.module;
                    
                    // Include all modules from affectations, regardless of hours
                    if (groupe && formateur && module) {
                        // Relations groupe-formateur
                        if (!groupeFormateurRelations[groupe]) {
                            groupeFormateurRelations[groupe] = new Set();
                        }
                        groupeFormateurRelations[groupe].add(formateur);
                        
                        if (!formateurGroupeRelations[formateur]) {
                            formateurGroupeRelations[formateur] = new Set();
                        }
                        formateurGroupeRelations[formateur].add(groupe);
                        
                        // Relations module - include all modules, even those with 0 hours
                        if (!moduleRelations[module]) {
                            moduleRelations[module] = { groupes: new Set(), formateurs: new Set() };
                        }
                        moduleRelations[module].groupes.add(groupe);
                        moduleRelations[module].formateurs.add(formateur);
                        
                        // Relations groupe-module - include all modules
                        if (!groupeModuleRelations[groupe]) {
                            groupeModuleRelations[groupe] = new Set();
                        }
                        groupeModuleRelations[groupe].add(module);
                        
                        // Relations formateur-module - include all modules
                        if (!formateurModuleRelations[formateur]) {
                            formateurModuleRelations[formateur] = new Set();
                        }
                        formateurModuleRelations[formateur].add(module);
                    }
                });
            } else if (avancementData && Array.isArray(avancementData)) {
                // Fallback vers avancementData si baseData.affectations n'est pas disponible
                avancementData.forEach(row => {
                    if (!Array.isArray(row)) return;
                    const groupe = getFormattedName(row[8]); // Colonne groupe
                    const formateur1 = getFormattedName(row[20]); // Formateur principal
                    const formateur2 = getFormattedName(row[22]); // Formateur secondaire
                    const module = row[16]; // Module
                    
                    if (groupe && module) {
                        // Relations groupe-module
                        if (groupeModuleRelations[groupe]) {
                            groupeModuleRelations[groupe].add(module);
                        }
                        // Relations module
                        if (!moduleRelations[module]) {
                            moduleRelations[module] = { groupes: new Set(), formateurs: new Set() };
                        }
                        moduleRelations[module].groupes.add(groupe);
                    }
                    
                    if (groupe && formateur1) {
                        if (groupeFormateurRelations[groupe]) {
                            groupeFormateurRelations[groupe].add(formateur1);
                        }
                        if (formateurGroupeRelations[formateur1]) {
                            formateurGroupeRelations[formateur1].add(groupe);
                        }
                        // Relations formateur-module
                        if (module && formateurModuleRelations[formateur1]) {
                            formateurModuleRelations[formateur1].add(module);
                        }
                        if (module && moduleRelations[module]) {
                            moduleRelations[module].formateurs.add(formateur1);
                        }
                    }
                    
                    if (groupe && formateur2) {
                        if (groupeFormateurRelations[groupe]) {
                            groupeFormateurRelations[groupe].add(formateur2);
                        }
                        if (formateurGroupeRelations[formateur2]) {
                            formateurGroupeRelations[formateur2].add(groupe);
                        }
                        // Relations formateur-module
                        if (module && formateurModuleRelations[formateur2]) {
                            formateurModuleRelations[formateur2].add(module);
                        }
                        if (module && moduleRelations[module]) {
                            moduleRelations[module].formateurs.add(formateur2);
                        }
                    }
                });
            }
            
            // Convertir les Sets en Arrays pour faciliter l'utilisation
            Object.keys(groupeFormateurRelations).forEach(groupe => {
                groupeFormateurRelations[groupe] = Array.from(groupeFormateurRelations[groupe]);
                if (groupeModuleRelations[groupe]) {
                    groupeModuleRelations[groupe] = Array.from(groupeModuleRelations[groupe]);
                }
            });
            Object.keys(formateurGroupeRelations).forEach(formateur => {
                formateurGroupeRelations[formateur] = Array.from(formateurGroupeRelations[formateur]);
                if (formateurModuleRelations[formateur]) {
                    formateurModuleRelations[formateur] = Array.from(formateurModuleRelations[formateur]);
                }
            });
            Object.keys(moduleRelations).forEach(module => {
                moduleRelations[module].groupes = Array.from(moduleRelations[module].groupes);
                moduleRelations[module].formateurs = Array.from(moduleRelations[module].formateurs);
            });
        }
        function getAvailableFormateurs() {
            if (selectedGroups.size === 0) {
                // Si aucun groupe sélectionné, retourner tous les formateurs
                return Object.keys(dataByFormateur).sort();
            }
            // Retourner les formateurs assignés aux groupes sélectionnés
            const availableFormateurs = new Set();
            selectedGroups.forEach(groupe => {
                if (groupeFormateurRelations[groupe]) {
                    groupeFormateurRelations[groupe].forEach(formateur => {
                        availableFormateurs.add(formateur);
                    });
                }
            });
            return Array.from(availableFormateurs).sort();
        }
        function getIntersectingModules() {
            // Start with all available modules if no specific filters are applied
            let candidateModules = new Set();
            
            // If both groups and formateurs are selected, use exact intersection like emploi.html
            if (selectedGroups.size > 0 && selectedFormateurs.size > 0) {
                // Use emploi.html style exact matching: a.formateur === formateur && subGroups.includes(a.groupe)
                selectedFormateurs.forEach(formateur => {
                    selectedGroups.forEach(groupe => {
                        // Handle both single groups and compound groups like emploi.html
                        const subGroups = groupe.trim().split(/\s+/).filter(Boolean);
                        baseData.affectations.forEach(affectation => {
                            // Format names from affectations to match the formatted names in our selections
                            const formateurFromAffectation = getFormattedName(affectation.formateur);
                            const groupeFromAffectation = getFormattedName(affectation.groupe);
                            
                            // Use exact matching like emploi.html: formatted names comparison
                            if (formateurFromAffectation === formateur && subGroups.includes(groupeFromAffectation)) {
                                candidateModules.add(affectation.module);
                            }
                        });
                    });
                });
            }
            // If only groups are selected
            else if (selectedGroups.size > 0) {
                selectedGroups.forEach(groupe => {
                    if (groupeModuleRelations[groupe]) {
                        groupeModuleRelations[groupe].forEach(module => {
                            candidateModules.add(module);
                        });
                    }
                });
            }
            // If only formateurs are selected
            else if (selectedFormateurs.size > 0) {
                selectedFormateurs.forEach(formateur => {
                    if (formateurModuleRelations[formateur]) {
                        formateurModuleRelations[formateur].forEach(module => {
                            candidateModules.add(module);
                        });
                    }
                });
            }
            // If only semester/regional filters are applied
            else if (selectedSemestres.size > 0 || selectedRegional.size > 0) {
                // Include all modules for filtering
                Object.keys(moduleRelations).forEach(module => {
                    candidateModules.add(module);
                });
            }
            else {
                // No filters at all - return empty to force user to select
                return [];
            }
            
            // Filter by semester if selected
            if (selectedSemestres.size > 0) {
                const semesterModules = new Set();
                candidateModules.forEach(module => {
                    const semester = getModuleSemester(null, null, module);
                    if (semester && selectedSemestres.has(semester)) {
                        semesterModules.add(module);
                    }
                });
                candidateModules = semesterModules;
            }
            
            // Filter by regional status if selected
            if (selectedRegional.size > 0) {
                const regionalModules = new Set();
                candidateModules.forEach(module => {
                    const isRegional = isModuleRegional(null, null, module);
                    const regionalStatus = isRegional ? 'Régional' : 'Non Régional';
                    if (selectedRegional.has(regionalStatus)) {
                        regionalModules.add(module);
                    }
                });
                candidateModules = regionalModules;
            }
            
            return Array.from(candidateModules).sort();
        }
        function getAvailableGroupes() {
            if (selectedFormateurs.size === 0) {
                // Si aucun formateur sélectionné, retourner tous les groupes
                return Object.keys(dataByGroupe).sort();
            }
            // Retourner les groupes assignés aux formateurs sélectionnés
            const availableGroupes = new Set();
            selectedFormateurs.forEach(formateur => {
                if (formateurGroupeRelations[formateur]) {
                    formateurGroupeRelations[formateur].forEach(groupe => {
                        availableGroupes.add(groupe);
                    });
                }
            });
            return Array.from(availableGroupes).sort();
        }

        function getAvailableSemestres() {
            const availableSemestres = new Set();

            // Parcourir toutes les affectations dans baseData
            if (baseData && baseData.affectations) {
                baseData.affectations.forEach(affectation => {
                    const semester = getModuleSemester(affectation.formateur, affectation.groupe, affectation.module);
                    if (semester) {
                        availableSemestres.add(semester);
                    }
                });
            }
            
            return Array.from(availableSemestres).sort();
        }
        
        function getAvailableRegional() {
            return ['Régional', 'Non Régional'];
        }
        
        // Fonction pour obtenir les modules qui intersectent les sélections planifiées
        function getPlannedIntersectingModules() {
            // Start with all available modules if no specific filters are applied
            let candidateModules = new Set();
            
            // If both groups and formateurs are selected, use exact intersection like emploi.html
            if (plannedSelectedGroups.size > 0 && plannedSelectedFormateurs.size > 0) {
                // Use emploi.html style exact matching: a.formateur === formateur && subGroups.includes(a.groupe)
                plannedSelectedFormateurs.forEach(formateur => {
                    plannedSelectedGroups.forEach(groupe => {
                        // Handle both single groups and compound groups like emploi.html
                        const subGroups = groupe.trim().split(/\s+/).filter(Boolean);
                        baseData.affectations.forEach(affectation => {
                            // Format names from affectations to match the formatted names in our selections
                            const formateurFromAffectation = getFormattedName(affectation.formateur);
                            const groupeFromAffectation = getFormattedName(affectation.groupe);
                            
                            // Use exact matching like emploi.html: formatted names comparison
                            if (formateurFromAffectation === formateur && subGroups.includes(groupeFromAffectation)) {
                                candidateModules.add(affectation.module);
                            }
                        });
                    });
                });
            }
            // If only groups are selected
            else if (plannedSelectedGroups.size > 0) {
                plannedSelectedGroups.forEach(groupe => {
                    if (groupeModuleRelations[groupe]) {
                        groupeModuleRelations[groupe].forEach(module => {
                            candidateModules.add(module);
                        });
                    }
                });
            }
            // If only formateurs are selected
            else if (plannedSelectedFormateurs.size > 0) {
                plannedSelectedFormateurs.forEach(formateur => {
                    if (formateurModuleRelations[formateur]) {
                        formateurModuleRelations[formateur].forEach(module => {
                            candidateModules.add(module);
                        });
                    }
                });
            }
            // If only semester/regional filters are applied
            else if (plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0) {
                // Include all modules for filtering
                Object.keys(moduleRelations).forEach(module => {
                    candidateModules.add(module);
                });
            }
            else {
                // No filters at all - return empty to force user to select
                return [];
            }
            
            // Filter by semester if selected
            if (plannedSelectedSemestres.size > 0) {
                const semesterModules = new Set();
                candidateModules.forEach(module => {
                    const semester = getModuleSemester(null, null, module);
                    if (semester && plannedSelectedSemestres.has(semester)) {
                        semesterModules.add(module);
                    }
                });
                candidateModules = semesterModules;
            }
            
            // Filter by regional status if selected
            if (plannedSelectedRegional.size > 0) {
                const regionalModules = new Set();
                candidateModules.forEach(module => {
                    const isRegional = isModuleRegional(null, null, module);
                    const regionalStatus = isRegional ? 'Régional' : 'Non Régional';
                    if (plannedSelectedRegional.has(regionalStatus)) {
                        regionalModules.add(module);
                    }
                });
                candidateModules = regionalModules;
            }
            
            return Array.from(candidateModules).sort();
        }
        
        function populateAdvancedFilters() {
            // Build relationships first
            buildGroupeFormateurRelations();
            
            // Populate real progress filters
            updateAvailableFilters();
            
            // Populate planned progress filters
            updatePlannedAvailableFilters();
        }
        
        function updateAvailableFilters() {
            const groupFilterContainer = document.getElementById('groupFilterButtons');
            const formateurFilterContainer = document.getElementById('formateurFilterButtons');
            const semestreFilterContainer = document.getElementById('semestreFilterButtons');
            const regionalFilterContainer = document.getElementById('regionalFilterButtons');
            
            if (!groupFilterContainer || !formateurFilterContainer || !semestreFilterContainer || !regionalFilterContainer) {
                return;
            }
            
            // Clear existing buttons
            groupFilterContainer.innerHTML = '';
            formateurFilterContainer.innerHTML = '';
            semestreFilterContainer.innerHTML = '';
            regionalFilterContainer.innerHTML = '';
            
            // Get available options based on current selections
            const availableGroups = getAvailableGroupes();
            const availableFormateurs = getAvailableFormateurs();
            const availableSemestres = getAvailableSemestres();
            const availableRegional = getAvailableRegional();
            
            // Populate group filters
            availableGroups.forEach(group => {
                const btn = createAdvancedFilterButton(group, 'group');
                if (selectedGroups.has(group)) {
                    btn.classList.add('selected');
                }
                groupFilterContainer.appendChild(btn);
            });
            
            // Populate formateur filters
            availableFormateurs.forEach(formateur => {
                const btn = createAdvancedFilterButton(formateur, 'formateur');
                if (selectedFormateurs.has(formateur)) {
                    btn.classList.add('selected');
                }
                formateurFilterContainer.appendChild(btn);
            });
            
            // Populate semester filters
            availableSemestres.forEach(semestre => {
                const btn = createAdvancedFilterButton(semestre, 'semestre');
                if (selectedSemestres.has(semestre)) {
                    btn.classList.add('selected');
                }
                semestreFilterContainer.appendChild(btn);
            });
            
            // Populate regional filters
            availableRegional.forEach(regional => {
                const btn = createAdvancedFilterButton(regional, 'regional');
                if (selectedRegional.has(regional)) {
                    btn.classList.add('selected');
                }
                regionalFilterContainer.appendChild(btn);
            });
        }
        
        function updatePlannedAvailableFilters() {
            const groupFilterContainer = document.getElementById('plannedGroupFilterButtons');
            const formateurFilterContainer = document.getElementById('plannedFormateurFilterButtons');
            const semestreFilterContainer = document.getElementById('plannedSemestreFilterButtons');
            const regionalFilterContainer = document.getElementById('plannedRegionalFilterButtons');
            
            if (!groupFilterContainer || !formateurFilterContainer || !semestreFilterContainer || !regionalFilterContainer) {
                return;
            }
            
            // Clear existing buttons
            groupFilterContainer.innerHTML = '';
            formateurFilterContainer.innerHTML = '';
            semestreFilterContainer.innerHTML = '';
            regionalFilterContainer.innerHTML = '';
            
            // Get available options based on current selections
            const availableGroups = getPlannedAvailableGroupes();
            const availableFormateurs = getPlannedAvailableFormateurs();
            const availableSemestres = getAvailableSemestres();
            const availableRegional = getAvailableRegional();
            
            // Populate group filters
            availableGroups.forEach(group => {
                const btn = createPlannedAdvancedFilterButton(group, 'group');
                if (plannedSelectedGroups.has(group)) {
                    btn.classList.add('selected');
                }
                groupFilterContainer.appendChild(btn);
            });
            
            // Populate formateur filters
            availableFormateurs.forEach(formateur => {
                const btn = createPlannedAdvancedFilterButton(formateur, 'formateur');
                if (plannedSelectedFormateurs.has(formateur)) {
                    btn.classList.add('selected');
                }
                formateurFilterContainer.appendChild(btn);
            });
            
            // Populate semester filters
            availableSemestres.forEach(semestre => {
                const btn = createPlannedAdvancedFilterButton(semestre, 'semestre');
                if (plannedSelectedSemestres.has(semestre)) {
                    btn.classList.add('selected');
                }
                semestreFilterContainer.appendChild(btn);
            });
            
            // Populate regional filters
            availableRegional.forEach(regional => {
                const btn = createPlannedAdvancedFilterButton(regional, 'regional');
                if (plannedSelectedRegional.has(regional)) {
                    btn.classList.add('selected');
                }
                regionalFilterContainer.appendChild(btn);
            });
        }
        
        function getPlannedAvailableFormateurs() {
            if (plannedSelectedGroups.size === 0) {
                // Si aucun groupe sélectionné, retourner tous les formateurs
                return Object.keys(dataByFormateur).sort();
            }
            // Retourner les formateurs assignés aux groupes sélectionnés
            const availableFormateurs = new Set();
            plannedSelectedGroups.forEach(groupe => {
                if (groupeFormateurRelations[groupe]) {
                    groupeFormateurRelations[groupe].forEach(formateur => {
                        availableFormateurs.add(formateur);
                    });
                }
            });
            return Array.from(availableFormateurs).sort();
        }
        
        function getPlannedAvailableGroupes() {
            if (plannedSelectedFormateurs.size === 0) {
                // Si aucun formateur sélectionné, retourner tous les groupes
                return Object.keys(dataByGroupe).sort();
            }
            // Retourner les groupes assignés aux formateurs sélectionnés
            const availableGroupes = new Set();
            plannedSelectedFormateurs.forEach(formateur => {
                if (formateurGroupeRelations[formateur]) {
                    formateurGroupeRelations[formateur].forEach(groupe => {
                        availableGroupes.add(groupe);
                    });
                }
            });
            return Array.from(availableGroupes).sort();
        }
        
        function createPlannedAdvancedFilterButton(text, type) {
            const btn = document.createElement('button');
            btn.className = type === 'group' ? 'group-filter-btn' : 'formateur-filter-btn';
            btn.textContent = text;
            btn.dataset.value = text;
            btn.dataset.type = type;
            btn.addEventListener('click', () => {
                if (type === 'group') {
                    if (plannedSelectedGroups.has(text)) {
                        plannedSelectedGroups.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        plannedSelectedGroups.add(text);
                        btn.classList.add('selected');
                    }
                } else if (type === 'formateur') {
                    if (plannedSelectedFormateurs.has(text)) {
                        plannedSelectedFormateurs.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        plannedSelectedFormateurs.add(text);
                        btn.classList.add('selected');
                    }
                } else if (type === 'semestre') {
                    if (plannedSelectedSemestres.has(text)) {
                        plannedSelectedSemestres.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        plannedSelectedSemestres.add(text);
                        btn.classList.add('selected');
                    }
                } else if (type === 'regional') {
                    if (plannedSelectedRegional.has(text)) {
                        plannedSelectedRegional.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        plannedSelectedRegional.add(text);
                        btn.classList.add('selected');
                    }
                }
                // Mettre à jour l'indicateur de filtre actif immédiatement
                isPlannedFilterActive = plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0 || 
                                       plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0;
                // Mettre à jour dynamiquement les filtres disponibles
                updatePlannedAvailableFilters();
                updatePlannedFilterButtons();
            });
            return btn;
        }
        
        function updatePlannedFilterButtons() {
            const filterBtn = document.getElementById('togglePlannedFilterBtn');
            if (filterBtn) {
                if (isPlannedFilterActive) {
                    filterBtn.classList.add('active');
                    filterBtn.title = 'Filtres actifs - cliquer pour modifier';
                } else {
                    filterBtn.classList.remove('active');
                    filterBtn.title = 'Aucun filtre actif - cliquer pour filtrer';
                }
            }
        }
        
        function applyPlannedAdvancedFilters() {
            // Les filtres avancés ne s'appliquent que dans la vue module planifié
            if (currentPlannedView !== 'module') {
                return;
            }
            isPlannedFilterActive = plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0 || 
                                   plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0;
            
            // Actualiser la vue planifiée
            renderPlannedView();
            
            // Feedback visuel sur le bouton de filtre
            const filterBtn = document.getElementById('togglePlannedFilterBtn');
            if (isPlannedFilterActive) {
                filterBtn.style.backgroundColor = 'var(--primary-color)';
                filterBtn.style.color = 'white';
                filterBtn.style.borderColor = 'var(--primary-color)';
            } else {
                filterBtn.style.backgroundColor = '';
                filterBtn.style.color = '';
                filterBtn.style.borderColor = '';
            }
        }
        
        function getAvailableSemestres() {
            const availableSemestres = new Set();

            // Parcourir toutes les affectations dans baseData
            if (baseData && baseData.affectations) {
                baseData.affectations.forEach(affectation => {
                    const s1Hours = parseFloat(affectation.s1_heures) || 0;
                    const s2Hours = parseFloat(affectation.s2_heures) || 0;

                    if (s1Hours > 0 && s2Hours > 0) {
                        availableSemestres.add('Annual');
                    } else if (s1Hours > 0) {
                        availableSemestres.add('S1');
                    } else if (s2Hours > 0) {
                        availableSemestres.add('S2');
                    }
                });
            }

            return Array.from(availableSemestres).sort();
        }

        function getAvailableRegional() {
            const availableRegional = new Set();

            // Parcourir toutes les affectations dans baseData
            if (baseData && baseData.affectations) {
                baseData.affectations.forEach(affectation => {
                    if (affectation.hasOwnProperty('est_regional')) {
                        const value = affectation.est_regional;
                        const isRegional = value === true || value == 1 || String(value).toLowerCase() === 'true';
                        if (isRegional) {
                            availableRegional.add('Régional');
                        } else {
                            availableRegional.add('Non Régional');
                        }
                    }
                });
            }

            return Array.from(availableRegional).sort();
        }

        // === FONCTIONS POUR LES FILTRES DE L'AVANCEMENT PLANIFIÉ (INDÉPENDANTS) ===
        
        function getPlannedIntersectingModules() {
            // Start with all available modules if no specific filters are applied
            let candidateModules = new Set();
            
            // If both groups and formateurs are selected, use exact intersection like emploi.html
            if (plannedSelectedGroups.size > 0 && plannedSelectedFormateurs.size > 0) {
                // Use emploi.html style exact matching: a.formateur === formateur && subGroups.includes(a.groupe)
                plannedSelectedFormateurs.forEach(formateur => {
                    plannedSelectedGroups.forEach(groupe => {
                        // Handle both single groups and compound groups like emploi.html
                        const subGroups = groupe.trim().split(/\s+/).filter(Boolean);
                        baseData.affectations.forEach(affectation => {
                            // Format names from affectations to match the formatted names in our selections
                            const formateurFromAffectation = getFormattedName(affectation.formateur);
                            const groupeFromAffectation = getFormattedName(affectation.groupe);
                            
                            // Use exact matching like emploi.html: formatted names comparison
                            if (formateurFromAffectation === formateur && subGroups.includes(groupeFromAffectation)) {
                                candidateModules.add(affectation.module);
                            }
                        });
                    });
                });
            }
            // If only groups are selected
            else if (plannedSelectedGroups.size > 0) {
                plannedSelectedGroups.forEach(groupe => {
                    if (groupeModuleRelations[groupe]) {
                        groupeModuleRelations[groupe].forEach(module => {
                            candidateModules.add(module);
                        });
                    }
                });
            }
            // If only formateurs are selected
            else if (plannedSelectedFormateurs.size > 0) {
                plannedSelectedFormateurs.forEach(formateur => {
                    if (formateurModuleRelations[formateur]) {
                        formateurModuleRelations[formateur].forEach(module => {
                            candidateModules.add(module);
                        });
                    }
                });
            }
            // If only semester/regional filters are applied
            else if (plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0) {
                // Include all modules for filtering
                Object.keys(moduleRelations).forEach(module => {
                    candidateModules.add(module);
                });
            }
            else {
                // No filters at all - return empty to force user to select
                return [];
            }
            
            // Filter by semester if selected
            if (plannedSelectedSemestres.size > 0) {
                const semesterModules = new Set();
                candidateModules.forEach(module => {
                    const semester = getModuleSemester(null, null, module);
                    if (semester && plannedSelectedSemestres.has(semester)) {
                        semesterModules.add(module);
                    }
                });
                candidateModules = semesterModules;
            }
            
            // Filter by regional status if selected
            if (plannedSelectedRegional.size > 0) {
                const regionalModules = new Set();
                candidateModules.forEach(module => {
                    const isRegional = isModuleRegional(null, null, module);
                    const regionalStatus = isRegional ? 'Régional' : 'Non Régional';
                    if (plannedSelectedRegional.has(regionalStatus)) {
                        regionalModules.add(module);
                    }
                });
                candidateModules = regionalModules;
            }
            
            return Array.from(candidateModules).sort();
        }
        
        function updatePlannedAvailableFilters() {
            console.log('Updating planned available filters');
            // Peupler les filtres de groupe
            const groupContainer = document.getElementById('plannedGroupFilterButtons');
            const availableGroupes = Object.keys(dataByGroupe).sort();
            console.log('Available groups for planned filters:', availableGroupes);
            groupContainer.innerHTML = '';
            availableGroupes.forEach(groupe => {
                const btn = createPlannedAdvancedFilterButton(groupe, 'group');
                if (plannedSelectedGroups.has(groupe)) {
                    btn.classList.add('selected');
                }
                groupContainer.appendChild(btn);
            });
            
            // Peupler les filtres de formateur
            const formateurContainer = document.getElementById('plannedFormateurFilterButtons');
            const availableFormateurs = Object.keys(dataByFormateur).sort();
            formateurContainer.innerHTML = '';
            availableFormateurs.forEach(formateur => {
                const btn = createPlannedAdvancedFilterButton(formateur, 'formateur');
                if (plannedSelectedFormateurs.has(formateur)) {
                    btn.classList.add('selected');
                }
                formateurContainer.appendChild(btn);
            });

            // Peupler les filtres de semestre
            const semestreContainer = document.getElementById('plannedSemestreFilterButtons');
            const availableSemestres = getAvailableSemestres();
            semestreContainer.innerHTML = '';
            availableSemestres.forEach(semestre => {
                const btn = createPlannedAdvancedFilterButton(semestre, 'semestre');
                if (plannedSelectedSemestres.has(semestre)) {
                    btn.classList.add('selected');
                }
                semestreContainer.appendChild(btn);
            });

            // Peupler les filtres régional
            const regionalContainer = document.getElementById('plannedRegionalFilterButtons');
            const availableRegional = getAvailableRegional();
            regionalContainer.innerHTML = '';
            availableRegional.forEach(regional => {
                const btn = createPlannedAdvancedFilterButton(regional, 'regional');
                if (plannedSelectedRegional.has(regional)) {
                    btn.classList.add('selected');
                }
                regionalContainer.appendChild(btn);
            });
        }
        
        function createPlannedAdvancedFilterButton(text, type) {
            const btn = document.createElement('button');
            btn.className = type === 'group' ? 'group-filter-btn' : 'formateur-filter-btn';
            btn.textContent = text;
            btn.dataset.value = text;
            btn.dataset.type = type;
            btn.addEventListener('click', () => {
                if (type === 'group') {
                    if (plannedSelectedGroups.has(text)) {
                        plannedSelectedGroups.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        plannedSelectedGroups.add(text);
                        btn.classList.add('selected');
                    }
                } else if (type === 'formateur') {
                    if (plannedSelectedFormateurs.has(text)) {
                        plannedSelectedFormateurs.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        plannedSelectedFormateurs.add(text);
                        btn.classList.add('selected');
                    }
                } else if (type === 'semestre') {
                    if (plannedSelectedSemestres.has(text)) {
                        plannedSelectedSemestres.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        plannedSelectedSemestres.add(text);
                        btn.classList.add('selected');
                    }
                } else if (type === 'regional') {
                    if (plannedSelectedRegional.has(text)) {
                        plannedSelectedRegional.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        plannedSelectedRegional.add(text);
                        btn.classList.add('selected');
                    }
                }
                // Mettre à jour l'indicateur de filtre actif immédiatement
                isPlannedFilterActive = plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0 || 
                                      plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0;
                // Mettre à jour dynamiquement les filtres disponibles
                updatePlannedAvailableFilters();
                updatePlannedFilterButtons();
            });
            return btn;
        }
        
        function updatePlannedFilterButtons() {
            const plannedFilterBtn = document.getElementById('togglePlannedFilterBtn');
            if (plannedFilterBtn) {
                if (isPlannedFilterActive) {
                    plannedFilterBtn.classList.add('active');
                    plannedFilterBtn.title = 'Filtres actifs - cliquer pour modifier';
                    plannedFilterBtn.style.backgroundColor = 'var(--primary-color)';
                    plannedFilterBtn.style.color = 'white';
                    plannedFilterBtn.style.borderColor = 'var(--primary-color)';
                } else {
                    plannedFilterBtn.classList.remove('active');
                    plannedFilterBtn.title = 'Aucun filtre actif - cliquer pour filtrer';
                    plannedFilterBtn.style.backgroundColor = '';
                    plannedFilterBtn.style.color = '';
                    plannedFilterBtn.style.borderColor = '';
                }
            }
            
            // Mettre à jour l'apparence des boutons individuels
            updatePlannedIndividualFilterButtons();
        }
        
        function updatePlannedIndividualFilterButtons() {
            // Mettre à jour l'apparence des boutons de groupe planifiés
            document.querySelectorAll('#plannedGroupFilterButtons .group-filter-btn').forEach(btn => {
                if (plannedSelectedGroups.has(btn.dataset.value)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            // Mettre à jour l'apparence des boutons de formateur planifiés
            document.querySelectorAll('#plannedFormateurFilterButtons .formateur-filter-btn').forEach(btn => {
                if (plannedSelectedFormateurs.has(btn.dataset.value)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            // Mettre à jour l'apparence des boutons de semestre planifiés
            document.querySelectorAll('#plannedSemestreFilterButtons .formateur-filter-btn').forEach(btn => {
                if (plannedSelectedSemestres.has(btn.dataset.value)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            // Mettre à jour l'apparence des boutons régional planifiés
            document.querySelectorAll('#plannedRegionalFilterButtons .formateur-filter-btn').forEach(btn => {
                if (plannedSelectedRegional.has(btn.dataset.value)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }
        
        function applyPlannedAdvancedFilters() {
            if (currentPlannedView !== 'module') {
                return;
            }
            isPlannedFilterActive = plannedSelectedGroups.size > 0 || plannedSelectedFormateurs.size > 0 || 
                                   plannedSelectedSemestres.size > 0 || plannedSelectedRegional.size > 0;
            
            updatePlannedFilterButtons();
            renderPlannedView();
        }
        
        // === FIN DES FONCTIONS POUR LES FILTRES DE L'AVANCEMENT PLANIFIÉ ===

        function populateAdvancedFilters() {
            // Construire les relations groupe-formateur
            buildGroupeFormateurRelations();
            // Peupler les filtres avec la logique dynamique
            updateAvailableFilters();
            // Peupler aussi les filtres planifiés indépendants
            updatePlannedAvailableFilters();
        }
        function updateAvailableFilters() {
            // Peupler les filtres de groupe
            const groupContainer = document.getElementById('groupFilterButtons');
            const availableGroupes = getAvailableGroupes();
            groupContainer.innerHTML = '';
            availableGroupes.forEach(groupe => {
                const btn = createAdvancedFilterButton(groupe, 'group');
                // Maintenir la sélection si le groupe était déjà sélectionné
                if (selectedGroups.has(groupe)) {
                    btn.classList.add('selected');
                }
                groupContainer.appendChild(btn);
            });
            // Peupler les filtres de formateur
            const formateurContainer = document.getElementById('formateurFilterButtons');
            const availableFormateurs = getAvailableFormateurs();
            formateurContainer.innerHTML = '';
            availableFormateurs.forEach(formateur => {
                const btn = createAdvancedFilterButton(formateur, 'formateur');
                // Maintenir la sélection si le formateur était déjà sélectionné
                if (selectedFormateurs.has(formateur)) {
                    btn.classList.add('selected');
                }
                formateurContainer.appendChild(btn);
            });

            // Peupler les filtres de semestre
            const semestreContainer = document.getElementById('semestreFilterButtons');
            const availableSemestres = getAvailableSemestres();
            semestreContainer.innerHTML = '';
            availableSemestres.forEach(semestre => {
                const btn = createAdvancedFilterButton(semestre, 'semestre');
                if (selectedSemestres.has(semestre)) {
                    btn.classList.add('selected');
                }
                semestreContainer.appendChild(btn);
            });

            // Peupler les filtres régional
            const regionalContainer = document.getElementById('regionalFilterButtons');
            const availableRegional = getAvailableRegional();
            regionalContainer.innerHTML = '';
            availableRegional.forEach(regional => {
                const btn = createAdvancedFilterButton(regional, 'regional');
                if (selectedRegional.has(regional)) {
                    btn.classList.add('selected');
                }
                regionalContainer.appendChild(btn);
            });

            // Nettoyer les sélections qui ne sont plus disponibles
            cleanupSelections(availableGroupes, availableFormateurs, availableSemestres, availableRegional);
        }
        function cleanupSelections(availableGroupes, availableFormateurs, availableSemestres, availableRegional) {
            // Supprimer les groupes sélectionnés qui ne sont plus disponibles
            const groupesToRemove = [];
            selectedGroups.forEach(groupe => {
                if (!availableGroupes.includes(groupe)) {
                    groupesToRemove.push(groupe);
                }
            });
            groupesToRemove.forEach(groupe => selectedGroups.delete(groupe));

            // Supprimer les formateurs sélectionnés qui ne sont plus disponibles
            const formateursToRemove = [];
            selectedFormateurs.forEach(formateur => {
                if (!availableFormateurs.includes(formateur)) {
                    formateursToRemove.push(formateur);
                }
            });
            formateursToRemove.forEach(formateur => selectedFormateurs.delete(formateur));

            // Supprimer les semestres sélectionnés qui ne sont plus disponibles
            const semestresToRemove = [];
            selectedSemestres.forEach(semestre => {
                if (!availableSemestres.includes(semestre)) {
                    semestresToRemove.push(semestre);
                }
            });
            semestresToRemove.forEach(semestre => selectedSemestres.delete(semestre));

            // Supprimer les statuts régional sélectionnés qui ne sont plus disponibles
            const regionalToRemove = [];
            selectedRegional.forEach(regional => {
                if (!availableRegional.includes(regional)) {
                    regionalToRemove.push(regional);
                }
            });
            regionalToRemove.forEach(regional => selectedRegional.delete(regional));
        }
        
        function applyAdvancedFilters() {
            // Determine if any filters are active
            isFilterActive = selectedGroups.size > 0 || selectedFormateurs.size > 0 || 
                           selectedSemestres.size > 0 || selectedRegional.size > 0;
            
            // Update filter button indication
            updateFilterButtons();
            
            // Re-render the current view with applied filters
            renderCurrentView();
        }
        function createAdvancedFilterButton(text, type) {
            const btn = document.createElement('button');
            btn.className = type === 'group' ? 'group-filter-btn' : 'formateur-filter-btn';
            btn.textContent = text;
            btn.dataset.value = text;
            btn.dataset.type = type;
            btn.addEventListener('click', () => {
                if (type === 'group') {
                    if (selectedGroups.has(text)) {
                        selectedGroups.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        selectedGroups.add(text);
                        btn.classList.add('selected');
                    }
                } else if (type === 'formateur') {
                    if (selectedFormateurs.has(text)) {
                        selectedFormateurs.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        selectedFormateurs.add(text);
                        btn.classList.add('selected');
                    }
                } else if (type === 'semestre') {
                    if (selectedSemestres.has(text)) {
                        selectedSemestres.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        selectedSemestres.add(text);
                        btn.classList.add('selected');
                    }
                } else if (type === 'regional') {
                    if (selectedRegional.has(text)) {
                        selectedRegional.delete(text);
                        btn.classList.remove('selected');
                    } else {
                        selectedRegional.add(text);
                        btn.classList.add('selected');
                    }
                }
                // Mettre à jour l'indicateur de filtre actif immédiatement
                isFilterActive = selectedGroups.size > 0 || selectedFormateurs.size > 0 || 
                               selectedSemestres.size > 0 || selectedRegional.size > 0;
                // Mettre à jour dynamiquement les filtres disponibles
                updateAvailableFilters();
                updateFilterButtons();
            });
            return btn;
        }
        function updateFilterButtons() {
            // Update main filter button state
            const filterBtn = document.getElementById('toggleFilterBtn');
            if (filterBtn) {
                if (isFilterActive) {
                    filterBtn.classList.add('active');
                    filterBtn.title = 'Filtres actifs - cliquer pour modifier';
                } else {
                    filterBtn.classList.remove('active');
                    filterBtn.title = 'Aucun filtre actif - cliquer pour filtrer';
                }
            }
            
            // Mettre à jour l'apparence des boutons de groupe
            document.querySelectorAll('.group-filter-btn').forEach(btn => {
                if (selectedGroups.has(btn.dataset.value)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            // Mettre à jour l'apparence des boutons de formateur
            document.querySelectorAll('.formateur-filter-btn').forEach(btn => {
                if (selectedFormateurs.has(btn.dataset.value)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            // Mettre à jour l'apparence des boutons de semestre
            document.querySelectorAll('[data-type="semestre"]').forEach(btn => {
                if (selectedSemestres.has(btn.dataset.value)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            // Mettre à jour l'apparence des boutons régional
            document.querySelectorAll('[data-type="regional"]').forEach(btn => {
                if (selectedRegional.has(btn.dataset.value)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }
        function getFilteredData(originalData, viewType, isPlanned = false) {
            const currentFilterActive = isPlanned ? isPlannedFilterActive : isFilterActive;
            const currentSelectedGroups = isPlanned ? plannedSelectedGroups : selectedGroups;
            const currentSelectedFormateurs = isPlanned ? plannedSelectedFormateurs : selectedFormateurs;
            const currentSelectedSemestres = isPlanned ? plannedSelectedSemestres : selectedSemestres;
            const currentSelectedRegional = isPlanned ? plannedSelectedRegional : selectedRegional;
            
            if (!currentFilterActive) return originalData;
            const filteredData = {};
            if (viewType === 'groupe') {
                // Filtrer par groupes sélectionnés
                if (currentSelectedGroups.size > 0) {
                    currentSelectedGroups.forEach(group => {
                        if (originalData[group]) {
                            filteredData[group] = originalData[group];
                        }
                    });
                } else {
                    Object.assign(filteredData, originalData);
                }
            } else if (viewType === 'formateur') {
                // Filtrer par formateurs sélectionnés
                if (currentSelectedFormateurs.size > 0) {
                    currentSelectedFormateurs.forEach(formateur => {
                        if (originalData[formateur]) {
                            filteredData[formateur] = originalData[formateur];
                        }
                    });
                } else {
                    Object.assign(filteredData, originalData);
                }
            } else if (viewType === 'module') {
                // Pour les modules, filtrer par groupes, formateurs, semestres et statut régional
                Object.assign(filteredData, originalData); // Commencer avec toutes les données

                // Si des groupes sont sélectionnés, filtrer par groupes d'abord
                if (currentSelectedGroups.size > 0) {
                    const moduleGroupFiltered = {};
                    for (const moduleCode in originalData) {
                        moduleGroupFiltered[moduleCode] = {};
                        currentSelectedGroups.forEach(group => {
                            if (originalData[moduleCode][group]) {
                                moduleGroupFiltered[moduleCode][group] = originalData[moduleCode][group];
                            }
                        });
                    }
                    Object.assign(filteredData, moduleGroupFiltered);
                }

                // Filtrer par semestre si sélectionné
                if (currentSelectedSemestres.size > 0) {
                    const modulesSemestreFiltered = {};
                    for (const moduleCode in filteredData) {
                        const semester = getModuleSemester(null, null, moduleCode);
                        if (semester && currentSelectedSemestres.has(semester)) {
                            modulesSemestreFiltered[moduleCode] = filteredData[moduleCode];
                        }
                    }
                    Object.assign(filteredData, {});
                    Object.assign(filteredData, modulesSemestreFiltered);
                }

                // Filtrer par statut régional si sélectionné
                if (currentSelectedRegional.size > 0) {
                    const modulesRegionalFiltered = {};
                    for (const moduleCode in filteredData) {
                        const isRegional = isModuleRegional(null, null, moduleCode);
                        const regionalStatus = isRegional ? 'Régional' : 'Non Régional';
                        if (currentSelectedRegional.has(regionalStatus)) {
                            modulesRegionalFiltered[moduleCode] = filteredData[moduleCode];
                        }
                    }
                    Object.assign(filteredData, {});
                    Object.assign(filteredData, modulesRegionalFiltered);
                }
            }
            return filteredData;
        }
        function createFilterButton(text, value, selector, callback) { 
            const btn = document.createElement('button'); 
            btn.className = 'group-filter-btn'; 
            btn.textContent = text; 
            btn.dataset.group = value; 
            btn.addEventListener('click', () => { 
                document.querySelectorAll(selector).forEach(b => b.classList.remove('active')); 
                btn.classList.add('active'); 
                callback(); 
            }); 
            return btn; 
        }
        function displayComparisonChart(canvasId, chartVar, data, title, type, metrics) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (window[chartVar]) window[chartVar].destroy();
            const sortedKeys = Object.keys(data).sort();
            // Create labels for modules (just the module name)
            let chartLabels = sortedKeys;
            if (type === 'module') {
                chartLabels = sortedKeys.map(moduleName => {
                    // Apply CSS classes for badges to elements if needed
                    const semester = getModuleSemester(null, null, moduleName);
                    const isRegional = isModuleRegional(null, null, moduleName);
                    
                    // Find elements with this module name and apply appropriate CSS classes
                    setTimeout(() => {
                        const moduleElements = document.querySelectorAll(`[data-module="${moduleName}"]`);
                        moduleElements.forEach(element => {
                            if (semester === 'S1') {
                                element.classList.add('module-s1');
                            } else if (semester === 'S2') {
                                element.classList.add('module-s2');
                            } else if (semester === 'Annual') {
                                element.classList.add('module-annual');
                            }
                            
                            if (isRegional) {
                                element.classList.add('module-regional');
                            }
                        });
                    }, 100);
                    
                    return createModuleLabel(moduleName);
                });
            }
            
            // Determine if this is a planned progress chart
            const isPlannedChart = canvasId === 'plannedProgressChart';
            
            // All views now show stacked bars to distinguish présentiel and synchrone hours
            let datasets;
            if (type === 'module') {
                // For module view, show stacked bars with assigned hours first, then realized/planned hours
                datasets = [
                    // First stack: Assigned hours - présentiel (light green) and synchrone (light blue)
                    { 
                        type: 'bar', 
                        label: 'MH Affectée Présentiel', 
                        data: sortedKeys.map(k => data[k]['affectePresentiel'] || 0), 
                        backgroundColor: 'rgba(34, 182, 115, 0.8)', // Light green for assigned présentiel
                        yAxisID: 'y_hours', 
                        borderRadius: 0,
                        stack: 'stack1', // First stack for assigned hours
                        order: 2
                    },
                    { 
                        type: 'bar', 
                        label: 'MH Affectée Synchrone', 
                        data: sortedKeys.map(k => data[k]['affecteSynchrone'] || 0), 
                        backgroundColor: 'rgba(27, 154, 240, 0.8)', // Light blue for assigned synchrone
                        yAxisID: 'y_hours', 
                        borderRadius: 0,
                        stack: 'stack1', // First stack for assigned hours
                        order: 2
                    },
                    // Second stack: Realized/Planned hours - présentiel (dark green) and synchrone (dark blue)
                    { 
                        type: 'bar', 
                        label: isPlannedChart ? 'MH Planifiée Présentiel' : 'MH Réalisée Présentiel', 
                        data: sortedKeys.map(k => {
                            if (isPlannedChart) {
                                return data[k]['planifiePresentiel'] || 0;
                            } else {
                                return data[k]['realisePresentiel'] || 0;
                            }
                        }), 
                        backgroundColor: 'rgba(34, 182, 115, 0.4)', // Pale green for realized/planned présentiel
                        yAxisID: 'y_hours', 
                        borderRadius: 0,
                        stack: 'stack2', // Second stack for realized/planned hours
                        order: 1
                    },
                    { 
                        type: 'bar', 
                        label: isPlannedChart ? 'MH Planifiée Synchrone' : 'MH Réalisée Synchrone', 
                        data: sortedKeys.map(k => {
                            if (isPlannedChart) {
                                return data[k]['planifieSynchrone'] || 0;
                            } else {
                                return data[k]['realiseSynchrone'] || 0;
                            }
                        }), 
                        backgroundColor: 'rgba(27, 154, 240, 0.4)', // Pale blue for realized/planned synchrone
                        yAxisID: 'y_hours', 
                        borderRadius: 0,
                        stack: 'stack2', // Second stack for realized/planned hours
                        order: 1
                    }
                ];
            } else {
                // For formateur and groupe views, also show stacked bars to distinguish présentiel/synchrone
                datasets = [
                    // Assigned hours stacked bars
                    { 
                        type: 'bar', 
                        label: 'MH Affectée Présentiel', 
                        data: sortedKeys.map(k => {
                            const total = data[k][metrics.totalKey] || 0;
                            // If we have separated data, use it; otherwise estimate 60% présentiel
                            return data[k]['affectePresentiel'] !== undefined ? 
                                   data[k]['affectePresentiel'] : total * 0.6;
                        }), 
                        backgroundColor: 'rgba(34, 182, 115, 0.8)', // Light green for assigned présentiel
                        yAxisID: 'y_hours', 
                        borderRadius: 0,
                        stack: 'stack1', // First stack for assigned hours
                        order: 2
                    },
                    { 
                        type: 'bar', 
                        label: 'MH Affectée Synchrone', 
                        data: sortedKeys.map(k => {
                            const total = data[k][metrics.totalKey] || 0;
                            // If we have separated data, use it; otherwise estimate 40% synchrone
                            return data[k]['affecteSynchrone'] !== undefined ? 
                                   data[k]['affecteSynchrone'] : total * 0.4;
                        }), 
                        backgroundColor: 'rgba(27, 154, 240, 0.8)', // Light blue for assigned synchrone
                        yAxisID: 'y_hours', 
                        borderRadius: 0,
                        stack: 'stack1', // First stack for assigned hours
                        order: 2
                    },
                    // Realized/Planned hours stacked bars
                    { 
                        type: 'bar', 
                        label: isPlannedChart ? 'MH Planifiée Présentiel' : 'MH Réalisée Présentiel', 
                        data: sortedKeys.map(k => {
                            if (isPlannedChart) {
                                return data[k]['planifiePresentiel'] || 0;
                            } else {
                                const total = data[k][metrics.completedKey] || 0;
                                // If we have separated data, use it; otherwise estimate 60% présentiel
                                return data[k]['realisePresentiel'] !== undefined ? 
                                       data[k]['realisePresentiel'] : total * 0.6;
                            }
                        }), 
                        backgroundColor: 'rgba(34, 182, 115, 0.4)', // Pale green for realized/planned présentiel
                        yAxisID: 'y_hours', 
                        borderRadius: 0,
                        stack: 'stack2', // Second stack for realized/planned hours
                        order: 1
                    },
                    { 
                        type: 'bar', 
                        label: isPlannedChart ? 'MH Planifiée Synchrone' : 'MH Réalisée Synchrone', 
                        data: sortedKeys.map(k => {
                            if (isPlannedChart) {
                                return data[k]['planifieSynchrone'] || 0;
                            } else {
                                const total = data[k][metrics.completedKey] || 0;
                                // If we have separated data, use it; otherwise estimate 40% synchrone
                                return data[k]['realiseSynchrone'] !== undefined ? 
                                       data[k]['realiseSynchrone'] : total * 0.4;
                            }
                        }), 
                        backgroundColor: 'rgba(27, 154, 240, 0.4)', // Pale blue for realized/planned synchrone
                        yAxisID: 'y_hours', 
                        borderRadius: 0,
                        stack: 'stack2', // Second stack for realized/planned hours
                        order: 1
                    }
                ];
            }
            if (type === 'formateur') {
                datasets.push({ 
                    type: 'line', 
                    label: metrics.rateLabel, 
                    data: sortedKeys.map(k => data[k][metrics.rateKey]), 
                    borderColor: metrics.rateColor, 
                    yAxisID: 'y_percent', 
                    fill: false, 
                    tension: 0.3 
                });
                datasets.push({ 
                    type: 'line', 
                    label: 'Masse Horaire Statutaire', 
                    data: sortedKeys.map(fullName => { 
                        const key = Object.keys(statutaryHoursByFormateur).find(lastName => fullName.includes(lastName)); 
                        return key ? statutaryHoursByFormateur[key] : null; 
                    }), 
                    borderColor: '#6f42c1', 
                    borderDash: [5, 5], 
                    fill: false, 
                    yAxisID: 'y_hours', 
                    pointRadius: 0, 
                    pointHitRadius: 10 
                });
            }
            
            // Plugin pour dessiner les badges et noms des formateurs sur les graphiques module
            const badgePlugin = {
                id: 'moduleBadges',
                afterDraw: function(chart) {
                    if (type !== 'module') {
                        return; // Ne dessiner que pour les vues module
                    }
                    
                    const ctx = chart.ctx;
                    const xScale = chart.scales.x;
                    const yScale = chart.scales.y_hours;
                    
                    if (!xScale || !yScale) {
                        return;
                    }
                    
                    // Get current filter context
                    let selectedGroup = null;
                    let isPlanned = false;
                    
                    // Determine if this is for planned progress or real progress
                    if (canvasId === 'plannedProgressChart') {
                        isPlanned = true;
                        if (plannedSelectedGroups.size > 0) {
                            selectedGroup = Array.from(plannedSelectedGroups)[0];
                        }
                    } else {
                        if (selectedGroups.size > 0) {
                            selectedGroup = Array.from(selectedGroups)[0];
                        }
                    }
                    
                    // Dessiner les noms des formateurs et les badges pour chaque module
                    sortedKeys.forEach((moduleName, index) => {
                        const semester = getModuleSemester(null, null, moduleName);
                        const isRegional = isModuleRegional(null, null, moduleName);
                        const formateurName = getModuleFormateur(moduleName, selectedGroup, isPlanned);
                        
                        // Position du label sur l'axe X
                        const xPos = xScale.getPixelForValue(index);
                        
                        // Dessiner le nom du formateur au-dessus de la barre (suivant la spécification mémoire)
                        if (formateurName) {
                            // Position au-dessus des barres - for module view with two separate stacks
                            let maxBarHeight;
                            if (type === 'module') {
                                // For two-stack module view, find the highest of the two stacks
                                // Stack 1: assigned hours (affectee)
                                const assignedStack = (data[moduleName]['affectePresentiel'] || 0) + (data[moduleName]['affecteSynchrone'] || 0);
                                // Stack 2: realized hours (realisee)
                                const realizedStack = (data[moduleName]['realisePresentiel'] || 0) + (data[moduleName]['realiseSynchrone'] || 0);
                                
                                // Get pixel positions for the highest of the two stacks
                                const maxStackValue = Math.max(assignedStack, realizedStack);
                                maxBarHeight = yScale.getPixelForValue(maxStackValue);
                            } else {
                                // For other views, use original logic
                                maxBarHeight = Math.max(
                                    ...[0, 1].map(datasetIndex => {
                                        const meta = chart.getDatasetMeta(datasetIndex);
                                        return meta.data[index] ? meta.data[index].y : yScale.top;
                                    })
                                );
                            }
                            
                            const formateurYPos = maxBarHeight - 35; // 25px au-dessus de la barre la plus haute
                            
                            // Style du texte selon la spécification mémoire
                            ctx.fillStyle = '#333';
                            ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'bottom';
                            
                            // Ombre pour améliorer la visibilité (spécification mémoire)
                            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                            ctx.shadowBlur = 2;
                            ctx.shadowOffsetX = 1;
                            ctx.shadowOffsetY = 1;
                            
                            ctx.fillText(formateurName, xPos, formateurYPos);
                            
                            // Réinitialiser l'ombre
                            ctx.shadowColor = 'transparent';
                            ctx.shadowBlur = 0;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                        }
                        
                        // Dessiner les badges (semester et regional) en bas selon la spécification existante
                        if (!semester && !isRegional) return;
                        
                        const yPos = xScale.bottom + 10; // Position plus bas sous l'axe X
                        
                        // Calculer le nombre de badges selon la spécification
                        const badgeWidth = 14;
                        const badgeGap = 2; // Réduit à 2px selon la spécification
                        let numBadges = 0;
                        if (semester) numBadges++;
                        if (isRegional) numBadges++;
                        
                        // Position des badges à droite du nom du module avec 2px de padding
                        let badgeStartX = xPos - 10; // Position à droite avec 2px de padding selon la spécification
                        
                        // Dessiner le badge de semestre
                        if (semester) {
                            let bgColor = '', content = '';
                            
                            if (semester === 'S1') {
                                bgColor = '#1B9AF0';
                                content = '1';
                            } else if (semester === 'S2') {
                                bgColor = '#2BB673';
                                content = '2';
                            } else if (semester === 'Annual') {
                                bgColor = '#FF6D00';
                                content = 'A';
                            }
                            
                            // Dessiner le carré avec coins arrondis
                            ctx.fillStyle = bgColor;
                            ctx.beginPath();
                            if (ctx.roundRect) {
                                ctx.roundRect(badgeStartX, yPos, 14, 14, 3);
                            } else {
                                ctx.rect(badgeStartX, yPos, 14, 14);
                            }
                            ctx.fill();
                            
                            // Bordure intérieure
                            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            if (ctx.roundRect) {
                                ctx.roundRect(badgeStartX + 0.5, yPos + 0.5, 13, 13, 2.5);
                            } else {
                                ctx.rect(badgeStartX + 0.5, yPos + 0.5, 13, 13);
                            }
                            ctx.stroke();
                            
                            // Texte dans le badge
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(content, badgeStartX + 7, yPos + 7);
                            
                            badgeStartX += badgeWidth + badgeGap; // Espace pour le badge suivant avec gap de 2px
                        }
                        
                        // Dessiner le badge régional
                        if (isRegional) {
                            // Carré avec coins arrondis
                            ctx.fillStyle = '#FFD700';
                            ctx.beginPath();
                            if (ctx.roundRect) {
                                ctx.roundRect(badgeStartX, yPos, 14, 14, 3);
                            } else {
                                ctx.rect(badgeStartX, yPos, 14, 14);
                            }
                            ctx.fill();
                            
                            // Bordure intérieure
                            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            if (ctx.roundRect) {
                                ctx.roundRect(badgeStartX + 0.5, yPos + 0.5, 13, 13, 2.5);
                            } else {
                                ctx.rect(badgeStartX + 0.5, yPos + 0.5, 13, 13);
                            }
                            ctx.stroke();
                            
                            // Étoile dans le badge
                            ctx.fillStyle = '#666';
                            ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('★', badgeStartX + 7, yPos + 7);
                        }
                    });
                }
            };
            
            // Registrer le plugin seulement pour les graphiques module
            let plugins = [];
            if (type === 'module') {
                plugins.push(badgePlugin);
            }
            
            window[chartVar] = new Chart(ctx, { 
                type: 'bar', 
                data: { labels: chartLabels, datasets }, 
                plugins: plugins,
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        intersect: true,
                    },
                    layout: {
                        padding: {
                            top: 20, // Increased space for formateur names in module view
                            bottom: 80,
                            left: 10,
                            right: 10
                        }
                    }, 
                    plugins: { 
                        title: { display: false }, 
                        legend: { 
                            position: 'top',
                            align: 'center',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12
                                }
                            },
                            display: true
                        },
                        tooltip: {
                            enabled: true,
                            mode: 'nearest',
                            intersect: true,
                            callbacks: {
                                title: function(context) {
                                    if (context[0] && context[0].label) {
                                        return context[0].label.replace(/<[^>]*>/g, '');
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        if (context.dataset.yAxisID === 'y_percent') {
                                            label += context.parsed.y.toFixed(1) + '%';
                                        } else {
                                            label += context.parsed.y.toFixed(1) + ' h';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    }, 
                    scales: { 
                        x: { 
                            grid: { display: false }, 
                            stacked: true, // Enable stacking for all views
                            ticks: { 
                                autoSkip: false, 
                                maxRotation: 90, 
                                minRotation: 45,
                                padding: 20,
                                callback: function(value, index) {
                                    return chartLabels[index];
                                }
                            } 
                        }, 
                        y_hours: { 
                            type: 'linear', 
                            position: 'left', 
                            stacked: true, // Enable stacking for all views
                            title: { display: true, text: 'Heures' }, 
                            grid: { color: '#e9ecef' } 
                        }, 
                        y_percent: { 
                            type: 'linear', 
                            position: 'right', 
                            min: 0, 
                            max: 100, 
                            display: type === 'formateur', 
                            grid: { drawOnChartArea: false }, 
                            title: { display: true, text: 'Taux (%)' } 
                        } 
                    } 
                } 
            });
        }
    </script>
</body>
</html>