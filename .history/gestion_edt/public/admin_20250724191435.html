<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Système d'Emploi du Temps avec Excel</title>
  <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <style>
    /* ... (tous les styles précédents restent ici, SAUF les styles pour .alert-box et .btn-save) ... */
    
    /* ============================================================== */
    /* ==   NOUVEAUX STYLES AMÉLIORÉS POUR LE CALENDRIER PERSONNALISÉ   == */
    /* ============================================================== */
    .week-selection {
      display: flex;
      justify-content: center;
      margin: auto;
      gap: 10px;
      align-items: center;
    }

    .week-import-btn {
      position: relative;
      display: inline-block;
    }

    .week-import-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      z-index: 1100;
      min-width: 250px;
      max-height: 300px;
      overflow-y: auto;
      padding: 10px;
      margin-top: 5px;
    }

    .week-import-menu.show {
      display: block;
      animation: fadeInScaleUp 0.2s ease-out;
    }

    .week-import-item {
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 0.95rem;
      margin-bottom: 3px;
    }

    .week-import-item:hover {
      background-color: #f0f4ff;
    }

    .week-import-item.selected {
      background-color: #3498db;
      color: white;
    }

    .btn-import {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 12px 8px 16px;
      gap: 8px;
      height: 43px;
      border: none;
      background: #000000d4;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .btn-import:hover {
      background: #0f0d0f4d;
    }

    .svg-icon-import {
      width: 20px;
      height: 20px;
      stroke: #ffffff;
    }

    .lable-import {
      margin-top: 1px;
      font-weight: bold;
      font-size: 15px;
      line-height: 22px;
      color: #ffffff;
      letter-spacing: 1px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }


    .custom-week-picker {
        position: relative;
        min-width: 250px;
        margin-left: 320px;
    }

    #customWeekDisplay {
        padding: 10px 15px;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 1.1rem;
        background-color: #fff;
        cursor: pointer;
        text-align: center;
        user-select: none;
        transition: all 0.2s ease-in-out;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        display: flex; /* Active Flexbox */
        align-items: center; /* Aligne verticalement l'icône et le texte */
        justify-content: center; /* Centre le contenu horizontalement */
        gap: 20px; /* Crée un espace entre l'icône et le texte */
        height: 43px;
    }

    #customWeekDisplay img {
        height: 25px;
        width: auto;
    }

    @keyframes fadeInScaleUp {
      from {
        opacity: 0;
        transform: translateX(-50%) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) scale(1);
      }
    }

    #calendarPopup {
        display: none;
        position: absolute;
        top: calc(100% + 5px);
        left: 50%;
        transform: translateX(-50%);
        width: 320px;
        background: #fff;
        border: 1px solid #e0e0e0;
        border-radius: 10px;
        box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        z-index: 1200;
        padding: 15px;
        animation: fadeInScaleUp 0.2s ease-out;
    }

    .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: 10px;
        margin-bottom: 10px;
        border-bottom: 1px solid #f0f0f0;
    }
    .calendar-header button {
        background: none;
        border: none;
        font-size: 1rem;
        cursor: pointer;
        color: #555;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
    }
    .calendar-header button:hover {
        background-color: #f0f4ff;
        color: #3498db;
    }
    .calendar-title {
        font-weight: 600;
        font-size: 1.1rem;
        color: #2c3e50;
    }

    .calendar-grid {
        width: 100%;
        border-collapse: collapse;
        text-align: center;
    }
    .calendar-grid th {
        font-size: 0.8rem;
        color: #95a5a6;
        padding-bottom: 10px;
        font-weight: 600;
        text-transform: uppercase;
    }
    .calendar-grid td {
        padding: 2px;
    }
    .calendar-day {
        width: 100%;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 0.95rem;
        border: 1px solid transparent;
    }
    .calendar-day:hover {
        background-color: #f0f4ff;
        transform: scale(1.05);
    }
    .calendar-day.other-month {
        opacity: 0.4;
    }
    .calendar-day.disabled-day {
        color: #bdc3c7;
        background-color: #f9f9f9;
        cursor: not-allowed;
    }
     .calendar-day.disabled-day:hover {
        background-color: #f9f9f9;
        transform: none;
    }
    .calendar-day.today {
        border-color: #3498db;
        color: #3498db;
        font-weight: bold;
    }
    
    /* Style pour la semaine sélectionnée */
    .calendar-day.selected-in-range {
        background-color: #eaf5ff;
        color: #2980b9;
        border-radius: 0;
    }
    .calendar-day.selected-start {
        background-color: #3498db;
        color: #fff;
        border-top-left-radius: 20px;
        border-bottom-left-radius: 20px;
    }
    .calendar-day.selected-end {
        background-color: #3498db;
        color: #fff;
        border-top-right-radius: 20px;
        border-bottom-right-radius: 20px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    body {
      background-color: #ffffff;
      padding-top: 60px;
      user-select: none;
    }

    .upload {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 30px;
      margin-left: 30px;
      margin-right: 30px;
      flex-wrap: wrap;
    }   

    .container-btn-file {
      display: flex;
      position: relative;
      justify-content: center;
      align-items: center;
      background-color: #307750;
      color: #fff;
      border-style: none;
      padding: 0.85em 0.85em;
      border-radius: 0.5em;
      overflow: hidden;
      z-index: 1;
      transition: all 250ms;
      font-weight: bold;
      min-width: 200px;
      margin-left: 10px;
    }

    .container-btn-file input[type="file"] {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    .container-btn-file > svg {
      margin-right: 1em;
    }
    .container-btn-file::before {
      content: "";
      position: absolute;
      height: 100%;
      width: 0;
      border-radius: 0.5em;
      background-color: #469b61;
      z-index: -1;
      transition: all 350ms;
    }
    .container-btn-file:hover::before {
      width: 100%;
    }

    .file-name {
      margin-top: 10px;
      font-size: 0.9rem;
      color: #333;
      background: #f0f7ff;
      padding: 5px 10px;
      border-radius: 5px;
      border: 1px dashed #3498db;
      max-width: 300px;
      word-break: break-all;
    }

    .week-selection {
      display: flex;
      justify-content: center;
      margin: auto;
    }

    .timetable-container {
      max-height: 80vh;
      overflow-y: auto;
      overflow-x: hidden;
      border-radius: 12px;
      margin: 5px;
      background: white;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    #timetable {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      font-size: 13px;
      color: #333;
      margin: 0 auto;
      background-color: #ffffff;
      border: 1px solid #ccc;
      min-width: 100%; /* Forcer le tableau à s'adapter à la largeur du conteneur */
    }

    #timetable thead {
      position: sticky;
      top: 0;
      background-color: #f1f1f1;
      z-index: 100;
      box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1);
      border: 1px solid #ccc;
    }

    #timetable th {
      padding: 10px 8px;
      text-align: center;
      font-weight: bold;
      color: #2c3e50;
      white-space: nowrap;
      border: 1px solid #ccc;
      font-size: 14px;
      white-space: normal;
    }

    #timetable td,
    #timetable th {
      padding: 0;
      word-wrap: break-word;
      border: 1px solid #c5c4c4;
      border-bottom: 1px solid #c5c4c4;
      transition: background-color 0.2s ease;
    }

    #timetable td,
    #timetable th {
      height: 30px;
    }

    #timetable .salle-row td {
  border-bottom: 4px solid #c5c4c4 !important;
}

    .formateur-cell {
      color: #fff;
      font-weight: bold;
      text-align: center;
      vertical-align: middle;
      border-right: 1px solid #4a6491;
      border-bottom: 3px solid #c5c4c4 !important;
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      white-space: nowrap;
      padding: 8px 4px;
      min-width: 120px !important;
      width: 120px !important;
    }

    .type-cell {
      background-color: #f5f5f5;
      font-weight: 300;
      font-size: 12px;
      min-width: 10px;
      max-width: 10px;
      text-align: center;
      width: 10px;
      padding: 4px 6px !important;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .formateur-green {
      background: linear-gradient(to right, #2e55cc, #3927ae);
    }

    .formateur-orange {
      background: linear-gradient(to right, #309654, #1a8139);
    }

    .formateur-red {
      background: linear-gradient(to right, #e74c3c, #c0392b);
    }

    .formateur-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
    }

    .formateur-name {
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
    }

    .formateur-hours {
      font-size: 0.85em;
      font-weight: normal;
      margin-top: 5px;
      background-color: rgba(255, 255, 255, 0.2);
      padding: 2px 5px;
      border-radius: 10px;
      writing-mode: horizontal-tb;
      transform: rotate(180deg);
    }

    .formateur-hours-genAuto {
      font-size: 0.85em;
      font-weight: normal;
      margin-top: 5px;
      background-color: rgba(255, 255, 255, 0.2);
      padding: 2px 5px;
      border-radius: 10px;
      writing-mode: horizontal-tb;
      transform: rotate(0deg);
    }
    
    #timetable tbody tr:hover td {
      background-color: #f9f9f9;
    }

    .day-header {
      font-size: 20px !important;
      color: #ffffff;
    }
    
    .day-header {
      font-size: 20px !important;
      color: #ffffff !important;
    }

    .day-header *,
    .day-header::before,
    .day-header::after {
      color: #ffffff !important;
    }

    .time-header {
      color: #ffffff !important; 
      font-weight: bold;
    }

    .weekend-row td {
      background-color: #fafafa;
    }
    
    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    .auto-resize-cell {
      width: 100%;
      padding: 0;
      height: 40px;
    }

    .auto-resize-select {
      width: 100%;
      font-size: 10px;
      border: none;
      outline: none;
      background: transparent;
      white-space: normal;
      overflow: visible;
      text-overflow: initial;
      height: 100%;
      line-height: 1.2;
      text-align: center;
      padding: 2px 4px;
      box-sizing: border-box;
      cursor: pointer;
    }

    .auto-resize-select option {
      text-align: center;
    }

    select::-ms-expand {
      display: none;
    }

    .save-section {
      text-align: center;
      padding: 20px;
      background-color: #f8f9fa;
      border-top: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .btn {
      padding: 9px 22px;
      font-size: 1.1rem;
      font-weight: 600;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 0 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    /* .btn-save a été supprimé */

    .btn-reset {
      background: linear-gradient(to right, #e74c3c, #c0392b);
      color: white;
    }

    .btn-history {
      background: linear-gradient(to right, #9b59b6, #8e44ad);
      color: white;
    }
    
    .btn-export {
      background: linear-gradient(to right, #3498db, #2980b9);
      color: white;
    }

    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
    }

    .btn:active {
      transform: translateY(-1px);
    }
    
    .conflict-highlight {
      background-color: #ffcdd2 !important;
      transition: background-color 0.3s;
    }

    .weekend-row {
      background-color: #f9f9f9;
    }

    .history-section {
      padding: 20px;
      background-color: #f8f9fa;
      border-top: 1px solid #e0e0e0;
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .history-title {
      font-size: 1.4rem;
      color: #2c3e50;
    }

    .history-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      max-height: 200px;
      overflow-y: auto;
      padding: 10px;
      background-color: white;
      border-radius: 8px;
      box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .week-card {
      background: linear-gradient(to right, #3498db, #2980b9);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 120px;
      text-align: center;
    }

    .week-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .week-card.active {
      background: linear-gradient(to right, #27ae60, #2ecc71);
      box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.3);
    }

    .week-card .week-label {
      font-weight: bold;
      font-size: 1.1rem;
    }

    .week-card .dates {
      font-size: 0.85rem;
      opacity: 0.9;
    }
    
    .legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      background: #f0f7ff;
      padding: 6px 12px;
      border-radius: 20px;
    }
    
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }
    
    .legend-green {
      background: linear-gradient(to right, #2ecc71, #27ae60);
    }
    
    .legend-orange {
      background: linear-gradient(to right, #f39c12, #e67e22);
    }
    
    .legend-red {
      background: linear-gradient(to right, #e74c3c, #c0392b);
    }
    
    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 60px;
      padding: 10px 20px;
      background:#fff;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      z-index: 700;
      justify-content: space-between;
    }


    
    .lundi-day-header { background: #007bff; }
    .mardi-day-header { background: #ae06cc; }
    .mercredi-day-header { background: #e74c3c; }
    .jeudi-day-header { background: #f39c12; }
    .vendredi-day-header { background: #27ae60; }
    .samedi-day-header { background: #ff00d9; }
    
    .lundi-session { background: #007bff; }
    .mardi-session { background: #ae06cc; }
    .mercredi-session { background: #e74c3c; }
    .jeudi-session { background: #f39c12; }
    .vendredi-session { background: #27ae60; }
    .samedi-session { background: #ff00d9; }
    
    .lundi-cell { background-color: #E0F0FF !important; }
    .mardi-cell { background-color: #f6d4ff !important; }
    .mercredi-cell { background-color: #ffe0e0 !important; }
    .jeudi-cell { background-color: #fff7e0 !important; }
    .vendredi-cell { background-color: #e0ffe0 !important; }
    .samedi-cell { background-color: #ffe0fd !important; }

    .selected-cell {
      background-color: #000000 !important;
      font-weight: bold !important;
      color: #ffffff !important;
    }

    .selected-cell * {
      color: #ffffff !important;
      font-weight: bold !important;
    }

    .selected-cell input,
    .selected-cell select {
      color: #ffffff !important;
      font-weight: bold !important;
      background-color: #000000 !important;
      border-color: #ffffff !important;
    }

    .draggable-cell {
      cursor: move;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .dragging {
      opacity: 0.5;
      transform: scale(0.95);
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }
    
    .drag-over {
      background-color: #e3f2fd !important;
      border: 2px dashed #2196F3 !important;
    }
    
    .drop-target {
      background-color: #e3f2fd !important;
      border: 2px dashed #2196F3 !important;
    }
    
    .drop-hint {
      position: absolute;
      background: #2196F3;
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      opacity: 0.9;
      transform: translateY(-100%);
    }
    
    .drag-indicator {
      position: absolute;
      top: 2px;
      right: -5px;
      font-size: 10px;
      opacity: 0;
      cursor: move;
      width: 20px;
      height: 20px;
      z-index: 10;
    }

    .draggable-cell:hover .drag-indicator {
      opacity: 0.5;
    }
    
    .group-highlight {
      animation: pulse 2s infinite;
      border: 2px solid #ff9800;
      box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(255, 152, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0); }
    }
    
    .excel-selection {
      position: absolute;
      border: 2px solid #2196F3;
      background-color: rgba(33, 150, 243, 0.1);
      pointer-events: none;
      z-index: 500;
    }
    
    .excel-selected {
      background-color: rgba(33, 150, 243, 0.3) !important;
      outline: 2px solid #2196F3 !important;
      position: relative;
      z-index: 50;
    }
    
    .excel-selected.select-focus {
      background-color: rgba(33, 150, 243, 0.4) !important;
    }
    
    .excel-toolbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: white;
      padding: 10px 20px;
      border-radius: 50px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      z-index: 600;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    
    .excel-toolbar.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    .excel-toolbar button {
      background: #f5f5f5;
      border: none;
      border-radius: 5px;
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: background 0.2s;
    }
    
    .excel-toolbar button:hover {
      background: #e0e0e0;
    }
    
    .keyboard-shortcut {
      background: #e0e0e0;
      border-radius: 3px;
      padding: 2px 4px;
      font-size: 0.8em;
      margin-left: 5px;
    }
    
    .tooltip {
      position: relative;
      display: inline-block;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 120px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    .paste-notification {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      z-index: 700;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .paste-notification.show {
      opacity: 1;
    }

    .conflict-highlight {
      background-color: #ffdddd !important;
    }

    td[data-salle="TEAMS"] .conflict-highlight {
      background-color: transparent !important;
    }
    
    /* Styles pour les espaces personnalisés */
    .espace-section {
      margin: 15px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .espace-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .espace-controls input {
      flex: 1;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    
    .espace-controls button {
      padding: 10px 15px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    
    .espace-controls button:hover {
      background: #2980b9;
    }
    
    .espaces-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .espace-tag {
      background: #3498db;
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .espace-tag button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-weight: bold;
    }
    
    /* Section d'export */
    .export-section {
      display: flex;
      justify-content: center;
      margin-top: 15px;
      gap: 10px;
    }

    .save-status {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 15px 25px;
      color: white;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      transform: translateX(150%);
      transition: transform 0.3s ease;
      background-color: #3498db;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .save-status.show {
      transform: translateX(0);
    }
    
    .save-status.error {
      background-color: #e74c3c;
    }
    
    .save-status.success {
      background-color: #2ecc71;
    }

    
    /* ======================================================= */
/* ==      NOUVEAU STYLE POUR LE LOADER ANIMÉ           == */
/* ======================================================= */

/* Ce conteneur gère l'arrière-plan et le centrage */
.loader-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(44, 62, 80, 0.235); /* Un fond sombre pour mieux voir l'animation */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

/* Le texte sous l'animation */
.loader-container p {
    color: white;
    font-weight: 500;
    margin-top: 20px;
    letter-spacing: 1px;
}

/* Votre code CSS pour l'animation (inchangé) */
.loader {
  position: relative;
  width: 33px;
  height: 33px;
  perspective: 67px;
}

.loader div {
  width: 100%;
  height: 100%;
  background: #fff;
  position: absolute;
  left: 50%;
  transform-origin: left;
  animation: loader 2s infinite;
}

.loader div:nth-child(1) {
  animation-delay: 0.15s;
}

.loader div:nth-child(2) {
  animation-delay: 0.3s;
}

.loader div:nth-child(3) {
  animation-delay: 0.45s;
}

.loader div:nth-child(4) {
  animation-delay: 0.6s;
}

.loader div:nth-child(5) {
  animation-delay: 0.75s;
}

@keyframes loader {
  0% {
    transform: rotateY(0deg);
  }

  50%, 80% {
    transform: rotateY(-180deg);
  }

  90%, 100% {
    opacity: 0;
    transform: rotateY(-180deg);
  }
}

    nav a {
      text-decoration: none;
      color: #333;
      padding: 8px 16px;
      border-radius: 8px;
      transition: background-color 0.3s, color 0.3s;
    }

    nav a:hover {
      background-color: #f0f4ff;
      color: #1d4ed8; /* Bleu foncé */
      font-weight: 600;
    }

    nav a.active {
      background-color: #f0f4ff;
      color: #1d4ed8; /* Bleu foncé */
      font-weight: 600;
    }

    /* AJOUTEZ CE BLOC CSS DANS VOS PAGES */

.nav-links {
    display: flex;
    align-items: center;
    gap: 10px; /* Espace entre les liens et le bouton de profil */
}

/* Conteneur principal pour le menu de profil */
/* AJOUTEZ/REMPLACEZ CE BLOC CSS DANS VOS PAGES */

.profile-menu-container {
    position: relative;
}

.profile-button {
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #e0eaff; /* Couleur similaire à un lien actif */
    color: #1d4ed8;
    border: 1px solid #e0eaff;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}


.profile-dropdown {
    display: none;
    position: absolute;
    top: calc(100% + 12px);
    right: 0;
    width: 280px;
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    z-index: 1010;
    overflow: hidden;
    transform-origin: top right;
    animation: scale-up-and-fade-in 0.2s ease-out;
}

.profile-dropdown.show {
    display: block; /* La classe .show le rend visible */
}

@keyframes scale-up-and-fade-in {
    from {
        transform: scale(0.95);
        opacity: 0;
    }
    to {
        transform: scale(1);
        opacity: 1;
    }
}


.dropdown-profile-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px;
    border-bottom: 1px solid #f3f4f6;
}

.profile-pic {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background-color: #f3f4f6;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    color: #6b7280;
}

.profile-info strong {
    display: block;
    font-size: 1rem;
    font-weight: 600;
    color: #111827;
}
.profile-info small {
    font-size: 0.875rem;
    color: #6b7280;
}

.dropdown-menu-list {
    list-style: none;
    padding: 8px;
    margin: 0;
}

.dropdown-link {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 10px 12px;
    border-radius: 8px;
    text-decoration: none;
    color: #374151;
    font-weight: 500;
    transition: background-color 0.2s, color 0.2s;
}
.dropdown-link:hover {
    background-color: #f3f4f6;
}

.dropdown-link .icon {
    width: 32px;
    font-size: 16px;
    color: #6b7280;
}
.dropdown-link .text {
    flex-grow: 1;
}
.dropdown-link .chevron {
    font-size: 12px;
    color: #9ca3af;
}

.dropdown-divider {
    margin: 0 8px;
    border: none;
    border-top: 1px solid #f3f4f6;
}

.dropdown-link.logout {
    margin: 8px;
    width: calc(100% - 16px);
    color: #ef4444; /* Rouge */
}
.dropdown-link.logout .icon {
    color: #ef4444;
}
.dropdown-link.logout:hover {
    background-color: #fee2e2;
}

    /* Styles pour le tableau des contraintes dans la modale */
    .constraints-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .constraints-table th, .constraints-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
      vertical-align: middle;
    }
    .constraints-table th {
      background-color: #f2f2f2;
      font-weight: 600;
    }
    .constraints-table .formateur-name-col {
      font-weight: bold;
      min-width: 150px;
    }
    .constraints-table input[type="number"] {
      width: 60px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .constraints-table select[multiple] {
      width: 100%;
      min-height: 80px;
    }

    .availability-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
    }
    .availability-grid label {
      font-size: 12px;
      display: flex;
      align-items: center;
    }
    .availability-grid input {
      margin-right: 4px;
    }


 /* NOUVEAUX STYLES SANS ASCENSEUR */
.spaces-checkbox-container {
  /* On a retiré max-height et overflow-y */
  border: 1px solid #ddd;
  padding: 8px;
  border-radius: 4px;
  background-color: #f9f9f9; /* Légère couleur de fond pour distinguer la zone */
}
.spaces-checkbox-container label {
  display: block; 
  padding: 3px 0;
  user-select: none;
  cursor: pointer;
}
.spaces-checkbox-container input {
  margin-right: 8px;
  vertical-align: middle;
}


/* ... (votre autre CSS) ... */

/* NOUVEAUX STYLES POUR LE BOUTON UIVERSE */

#voiceAssistantBtn {
  position: fixed;
  bottom: 30px;
  right: 30px;
  z-index: 1100;
}

.uiverse {
  --duration: 7s;
  --easing: linear;
  --c-color-1: rgba(255, 163, 26, 0.7);
  --c-color-2: #1a23ff;
  --c-color-3: #e21bda;
  --c-color-4: rgba(255, 232, 26, 0.7);
  --c-shadow: rgba(255, 223, 87, 0.5);
  --c-shadow-inset-top: rgba(255, 223, 52, 0.9);
  --c-shadow-inset-bottom: rgba(255, 250, 215, 0.8);
  --c-radial-inner: #ffd215;
  --c-radial-outer: #fff172;
  --c-color: #ffffff;
  -webkit-tap-highlight-color: transparent;
  -webkit-appearance: none;
  outline: none;
  position: relative;
  cursor: pointer;
  border: none;
  
  /* --- MODIFICATIONS CLÉS POUR LA FORME CIRCULAIRE --- */
  width: 60px; /* AJOUTÉ: Largeur fixe */
  height: 60px; /* AJOUTÉ: Hauteur fixe */
  border-radius: 50%; /* MODIFIÉ: Pour un cercle parfait */
  padding: 0; /* MODIFIÉ: Pas de padding sur le bouton lui-même */
  /* --- FIN DES MODIFICATIONS CLÉS --- */

  margin: 0;
  text-align: center;
  font-weight: 600;
  letter-spacing: 0.02em;
  line-height: 1.5;
  color: var(--c-color);
  background: radial-gradient(
    circle,
    var(--c-radial-inner),
    var(--c-radial-outer) 80%
  );
  box-shadow: 0 0 14px var(--c-shadow);
}

.uiverse:before {
  content: "";
  pointer-events: none;
  position: absolute;
  z-index: 3;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  border-radius: 50%; /* MODIFIÉ: Doit correspondre au bouton */
  box-shadow:
    inset 0 3px 12px var(--c-shadow-inset-top),
    inset 0 -3px 4px var(--c-shadow-inset-bottom);
}

.uiverse .wrapper {
  -webkit-mask-image: -webkit-radial-gradient(white, black);
  overflow: hidden;
  border-radius: 50%; /* MODIFIÉ: Doit correspondre au bouton */
  
  /* --- AJOUTS POUR CENTRER LE CONTENU --- */
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  /* --- FIN DES AJOUTS --- */
}

.uiverse .wrapper span {
  display: inline-block;
  position: relative;
  z-index: 1;
  font-size: 24px; /* AJOUTÉ: Pour une icône plus grande */
  line-height: 0; /* AJOUTÉ: Pour un centrage vertical parfait */
}

.uiverse:hover {
  --duration: 1400ms;
}

.uiverse.listening {
    --duration: 1s;
    box-shadow: 0 0 25px var(--c-color-2), 0 0 15px var(--c-shadow);
}
.uiverse.listening span i {
    animation: pulse-mic 1.5s infinite;
}

@keyframes pulse-mic {
    0% { transform: scale(1); color: #e74c3c; }
    50% { transform: scale(1.3); color: #1a23ff; }
    100% { transform: scale(1); color: #e74c3c; }
}

.uiverse .wrapper .circle {
  position: absolute;
  left: 0;
  top: 0;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  filter: blur(var(--blur, 8px));
  background: var(--background, transparent);
  transform: translate(var(--x, 0), var(--y, 0)) translateZ(0);
  animation: var(--animation, none) var(--duration) var(--easing) infinite;
}

/* ... (toutes les classes .circle et les @keyframes restent les mêmes) ... */
.uiverse .wrapper .circle.circle-1,
.uiverse .wrapper .circle.circle-9,
.uiverse .wrapper .circle.circle-10 {
  --background: var(--c-color-4);
}
.uiverse .wrapper .circle.circle-3,
.uiverse .wrapper .circle.circle-4 {
  --background: var(--c-color-2);
  --blur: 14px;
}
.uiverse .wrapper .circle.circle-5,
.uiverse .wrapper .circle.circle-6 {
  --background: var(--c-color-3);
  --blur: 16px;
}
.uiverse .wrapper .circle.circle-2,
.uiverse .wrapper .circle.circle-7,
.uiverse .wrapper .circle.circle-8,
.uiverse .wrapper .circle.circle-11,
.uiverse .wrapper .circle.circle-12 {
  --background: var(--c-color-1);
  --blur: 12px;
}
.uiverse .wrapper .circle.circle-1 { --x: 0; --y: -40px; --animation: circle-1; }
.uiverse .wrapper .circle.circle-2 { --x: 92px; --y: 8px; --animation: circle-2; }
.uiverse .wrapper .circle.circle-3 { --x: -12px; --y: -12px; --animation: circle-3; }
.uiverse .wrapper .circle.circle-4 { --x: 80px; --y: -12px; --animation: circle-4; }
.uiverse .wrapper .circle.circle-5 { --x: 12px; --y: -4px; --animation: circle-5; }
.uiverse .wrapper .circle.circle-6 { --x: 56px; --y: 16px; --animation: circle-6; }
.uiverse .wrapper .circle.circle-7 { --x: 8px; --y: 28px; --animation: circle-7; }
.uiverse .wrapper .circle.circle-8 { --x: 28px; --y: -4px; --animation: circle-8; }
.uiverse .wrapper .circle.circle-9 { --x: 20px; --y: -12px; --animation: circle-9; }
.uiverse .wrapper .circle.circle-10 { --x: 64px; --y: 16px; --animation: circle-10; }
.uiverse .wrapper .circle.circle-11 { --x: 4px; --y: 4px; --animation: circle-11; }
.uiverse .wrapper .circle.circle-12 { --blur: 14px; --x: 52px; --y: 4px; --animation: circle-12; }

@keyframes circle-1 { 33% { transform: translate(0px, 16px) translateZ(0); } 66% { transform: translate(12px, 64px) translateZ(0); } }
@keyframes circle-2 { 33% { transform: translate(80px, -10px) translateZ(0); } 66% { transform: translate(72px, -48px) translateZ(0); } }
@keyframes circle-3 { 33% { transform: translate(20px, 12px) translateZ(0); } 66% { transform: translate(12px, 4px) translateZ(0); } }
@keyframes circle-4 { 33% { transform: translate(76px, -12px) translateZ(0); } 66% { transform: translate(112px, -8px) translateZ(0); } }
@keyframes circle-5 { 33% { transform: translate(84px, 28px) translateZ(0); } 66% { transform: translate(40px, -32px) translateZ(0); } }
@keyframes circle-6 { 33% { transform: translate(28px, -16px) translateZ(0); } 66% { transform: translate(76px, -56px) translateZ(0); } }
@keyframes circle-7 { 33% { transform: translate(8px, 28px) translateZ(0); } 66% { transform: translate(20px, -60px) translateZ(0); } }
@keyframes circle-8 { 33% { transform: translate(32px, -4px) translateZ(0); } 66% { transform: translate(56px, -20px) translateZ(0); } }
@keyframes circle-9 { 33% { transform: translate(20px, -12px) translateZ(0); } 66% { transform: translate(80px, -8px) translateZ(0); } }
@keyframes circle-10 { 33% { transform: translate(68px, 20px) translateZ(0); } 66% { transform: translate(100px, 28px) translateZ(0); } }
@keyframes circle-11 { 33% { transform: translate(4px, 4px) translateZ(0); } 66% { transform: translate(68px, 20px) translateZ(0); } }
@keyframes circle-12 { 33% { transform: translate(56px, 0px) translateZ(0); } 66% { transform: translate(60px, -32px) translateZ(0); } }

    .assistant-status {
        position: fixed;
        bottom: 100px;
        right: 30px;
        background: rgba(0, 0, 0, 0.75);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        z-index: 1099;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none; /* Pour ne pas gêner les clics */
    }
    .assistant-status.visible {
        opacity: 1;
    }


    /* ======================================================= */
    /* ==      NOUVEAUX STYLES POUR LA NOTIFICATION         == */
    /* ======================================================= */
    :root {
      --notification-inset: 2rem;
      --animation-play-state: running;
    }

    .notification {
      color: rgba(0, 0, 0, 0.7);
      position: fixed;
      display: flex;
      font-size: 1.1rem; /* Taille de police ajustée */
      letter-spacing: 1px; /* Espacement ajusté */
      line-height: 1.4;
      gap: 1.25rem; /* Espace ajusté */
      top: 0;
      right: 0;
      margin: var(--notification-inset);
      width: 22rem; /* Largeur ajustée */
      background-color: white;
      box-shadow: 0 0 0.5rem rgba(0, 0, 0, 0.25);
      border-radius: 0.5rem;
      max-width: calc(100% - 4rem); /* Marge ajustée */
      z-index: 9999;
      padding: 1.25rem 1rem; /* Remplissage ajusté */
      overflow: hidden; /* changé de clip à hidden pour meilleure compatibilité */
      transform: translateX(calc(100% + var(--notification-inset)));
      animation: slideInOut 160s cubic-bezier(0.33, 0, 0.66, 1.33);
      animation-fill-mode: forwards; /* Pour que l'état final persiste */
    }

    .notification.show {
        transform: translateX(0);
        animation: slideIn 0.5s cubic-bezier(0.33, 0, 0.66, 1.33) forwards;
    }
    
    .notification.hide {
        animation: slideOut 0.5s cubic-bezier(0.33, 0, 0.66, 1.33) forwards;
    }

    .notification:before {
      content: "";
      display: block;
      position: absolute;
      inset: 0 auto auto 0;
      height: 0.35rem; /* Hauteur ajustée */
      background-color: var(--accent-color, #49a87d);
      transform-origin: left;
      animation: countdown 3.5s linear forwards;
      animation-delay: 0.5s;
    }

    .notification__text {
      margin: 0.2rem 0 0;
      font-size: 0.9rem;
    }

    .notification__header {
      color: black;
      margin: 0;
      font-size: 1.2rem; /* Taille ajustée */
      font-weight: 600;
    }

    .notification__action {
      margin-left: auto;
    }
    
    .notification__action .button {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
    }
    
    .notification__action .button:hover {
        background-color: rgba(0,0,0,0.1);
    }

    .notification__icon {
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 3rem; /* Taille ajustée */
      height: 3rem; /* Taille ajustée */
      background-color: var(--accent-color, #49a87d);
      flex-shrink: 0;
    }
    
    .notification__icon i {
        font-size: 1.5rem;
        color: white;
    }

    .button {
      appearance: none;
      background: none;
      border: none;
      font: inherit;
      margin: 0;
      color: currentColor;
      padding: 0;
      cursor: pointer;
    }

    @keyframes slideIn {
        from { transform: translateX(calc(100% + var(--notification-inset))); }
        to { transform: translateX(0); }
    }
    
    @keyframes slideOut {
        from { transform: translateX(0); }
        to { transform: translateX(calc(100% + var(--notification-inset))); }
    }

    @keyframes countdown {
      to {
        transform: scaleX(0);
      }
    }
    
    /* ======================================================= */
    /* ==      NOUVEAUX STYLES POUR LE BOUTON ENREGISTRER   == */
    /* ======================================================= */
    .button {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 12px 8px 16px;
      gap: 8px;
      height: 45px;
      width: 150px;
      border: none;
      background: #e6f0ff;
      border-radius: 20px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .button-reset {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 12px 8px 16px;
      gap: 8px;
      height: 45px;
      width: 150px;
      border: none;
      background: #ff362b34;
      border-radius: 20px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .button-autogen {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 12px 8px 16px;
      gap: 4px;
      height: 45px;
      width: 270px;
      border: none;
      background: #5e41de33;
      border-radius: 20px;
      cursor: pointer;
      transition: background 0.3s ease;
      margin-right: 10px;
    }

    .button:hover {
      background: #d2e3fd;
    }

    .button-reset:hover {
      background: #ff362b52;
    }

    .button-autogen:hover {
      background: #5e41de4d;
    }

    .svg-icon {
      width: 20px;
      height: 20px;
      stroke: #056dfa;
    }

    .svg-icon-autogen {
      width: 20px;
      height: 20px;
      stroke: #5d41de;
    }

    .lable {
      margin-top: 1px;
      font-weight: 600;
      font-size: 15px;
      line-height: 22px;
      color: #056dfa;
      letter-spacing: 1px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    .lable-reset {
      margin-top: 1px;
      font-weight: 600;
      font-size: 15px;
      line-height: 22px;
      color: #fa0505;
      letter-spacing: 1px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    .lable-autogen {
      margin-top: 1px;
      font-weight: 600;
      font-size: 15px;
      line-height: 22px;
      color: #5D41DE;
      letter-spacing: 1px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }




    .button#notificationClose{
      background-color: white;
    }

    .upload-section{
      margin-top: 35px;
    }



    .drop-possible {
      background-color: #e8f5e9 !important;
      border: 2px dashed #4CAF50 !important;
  outline-offset: -1px;
}
    

/* Styles pour distinguer les modules par semestre */
/* --- STYLES CSS POUR LES MODULES PAR SEMESTRE --- */
/* Vous pouvez modifier les couleurs et les styles selon vos préférences */

/* Bordure à gauche - vous pouvez aussi utiliser border-top, border-right, border-bottom */
/* --- STYLES CSS POUR LES MODULES PAR SEMESTRE (Étiquette Badge) --- */
/* Styles de base pour la cellule */
.auto-resize-cell.module-s1,
.auto-resize-cell.module-s2,
.auto-resize-cell.module-annual {
    position: relative; /* Nécessaire pour positionner le pseudo-élément */
    overflow: visible; /* Permet au pseudo-élément de dépasser légèrement si besoin */
}

/* Pseudo-élément pour le badge triangulaire */
.auto-resize-cell.module-s1::before,
.auto-resize-cell.module-s2::before,
.auto-resize-cell.module-annual::before {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    width: 0;
    height: 0;
    border-style: solid;
    z-index: 1; /* S'affiche au-dessus du select */
}

/* Badge S1 - Triangle Bleu */
.auto-resize-cell.module-s1::before {
    border-width: 0 15px 15px 0; /* Ajustez 20px pour changer la taille du triangle */
    border-color: transparent #1E90FF transparent transparent; /* Bleu DodgerBlue */
}

/* Badge S2 - Triangle Vert */
.auto-resize-cell.module-s1::before {
    border-width: 0 15px 15px 0;
    border-color: transparent #32CD32 transparent transparent; /* Vert LimeGreen */
}

/* Badge Annuel - Triangle Orange */
.auto-resize-cell.module-annual::before {
    border-width: 0 15px 20px 0;
    border-color: transparent #FF8C00 transparent transparent; /* Orange DarkOrange */
}

/* Optionnel : Ajouter un peu de padding en haut à droite pour éviter que le texte ne touche le triangle */
.auto-resize-cell.module-s1 select,
.auto-resize-cell.module-s2 select,
.auto-resize-cell.module-annual select {
    padding-top: 5px;
    padding-right: 5px;
}
/* --- FIN STYLES CSS (Étiquette Badge) --- */

/* --- FIN STYLES CSS --- */

/* Assurez-vous que ces styles s'appliquent même si d'autres classes sont présentes */
/* !important peut être nécessaire pour surcharger les styles par défaut */
  </style>
</head>

<body>
  <div class="container">
    <nav>
      <img src="assets/images/logo_edtpro.png" style="height: 80px; width: auto;" id="logo" alt="Logo">
      <div class="nav-links"> <!-- J'ai ajouté une classe pour mieux cibler les liens -->
          <a href="admin.html" id="nav-admin">Emploi globale</a>
          <a href="edition.html" id="nav-edition">Edition</a>
          <a href="avancement.html" id="nav-avancement">Avancement</a>
          <div class="profile-menu-container" id="profile-menu-container">
            <!-- Le bouton/lien principal reste le même -->
            <button id="profile-button" class="profile-button">
              <span id="profile-initials">--</span>
          </button>
        
            <!-- === NOUVELLE STRUCTURE SIMPLIFIÉE DU MENU DÉROULANT === -->
<div id="profile-dropdown" class="profile-dropdown">
  <!-- En-tête avec l'image et le nom -->
  <div class="dropdown-profile-header">
      <div class="profile-pic">
          <i class="fas fa-user"></i>
      </div>
      <div class="profile-info">
          <strong id="dropdown-user-name">Chargement...</strong>
          <small id="dropdown-user-email">...</small>
      </div>
  </div>

  <!-- Liste des liens (simplifiée) -->
  <ul class="dropdown-menu-list">
      <li>
          <a href="profile.html" class="dropdown-link">
              <i class="fas fa-user-edit icon"></i>
              <span class="text">Mon Profil</span>
              <i class="fas fa-chevron-right chevron"></i>
          </a>
      </li>
      <!-- Le lien "Paramètres" a été supprimé -->
  </ul>

  <!-- Séparateur et lien de déconnexion -->
  <hr class="dropdown-divider">
  <a href="../api/auth/logout.php" class="dropdown-link logout">
      <i class="fas fa-sign-out-alt icon"></i>
      <span class="text">Déconnexion</span>
  </a>
</div>
<!-- ======================================================== -->
      </div>
  </nav>
    
    <section class="upload-section">
      <div class="upload">
        <div class="file-input-container">
          <button class="container-btn-file">
            <svg fill="#fff" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 50 50">
              <path d="M28.8125 .03125L.8125 5.34375C.339844 5.433594 0 5.863281 0 6.34375L0 43.65625C0 
                44.136719 .339844 44.566406 .8125 44.65625L28.8125 
                49.96875C28.875 49.980469 28.9375 50 29 50C29.230469 
                50 29.445313 49.929688 29.625 49.78125C29.855469 49.589844 
                30 49.296875 30 49L30 1C30 .703125 29.855469 .410156 29.625 
                .21875C29.394531 .0273438 29.105469 -.0234375 28.8125 .03125ZM32 
                6L32 13L34 13L34 15L32 15L32 20L34 20L34 22L32 22L32 27L34 27L34 
                29L32 29L32 35L34 35L34 37L32 37L32 44L47 44C48.101563 44 49 
                43.101563 49 42L49 8C49 6.898438 48.101563 6 47 6ZM36 13L44 
                13L44 15L36 15ZM6.6875 15.6875L11.8125 15.6875L14.5 21.28125C14.710938 
                21.722656 14.898438 22.265625 15.0625 22.875L15.09375 22.875C15.199219 
                22.511719 15.402344 21.941406 15.6875 21.21875L18.65625 15.6875L23.34375 
                15.6875L17.75 24.9375L23.5 34.375L18.53125 34.375L15.28125 
                28.28125C15.160156 28.054688 15.035156 27.636719 14.90625 
                27.03125L14.875 27.03125C14.8125 27.316406 14.664063 27.761719 
                14.4375 28.34375L11.1875 34.375L6.1875 34.375L12.15625 25.03125ZM36 
                20L44 20L44 22L36 22ZM36 27L44 27L44 29L36 29ZM36 35L44 35L44 37L36 37Z">
              </path>
            </svg>
            Sélectionner fichier
            <input class="file" name="text" type="file" id="fileInput" accept=".xlsx, .xls" />
          </button>
          <div class="file-name" id="fileName" style="display: none;">Aucun fichier sélectionné</div>
        </div>

        <!-- ***** DÉBUT DE LA ZONE DU CALENDRIER PERSONNALISÉ ***** -->
        <div class="week-selection">
            <div class="custom-week-picker">
              <div id="customWeekDisplay">
                <img src="https://cdn-icons-png.flaticon.com/512/12887/12887924.png" alt="">
                <span id="weekDisplayText"></span>
              </div>
                <div id="calendarPopup">
                    <div class="calendar-header">
                        <button id="prevMonthBtn"><i class="fas fa-chevron-left"></i></button>
                        <span id="calendarTitle"></span>
                        <button id="nextMonthBtn"><i class="fas fa-chevron-right"></i></button>
                    </div>
                    <table class="calendar-grid">
                        <thead>
                            <tr><th>L</th><th>M</th><th>M</th><th>J</th><th>V</th><th>S</th><th>D</th></tr>
                        </thead>
                        <tbody id="calendarBody"></tbody>
                    </table>
                </div>
            </div>

            <div class="week-import-btn">
              <button class="btn-import" id="importWeekBtn">
                <svg class="svg-icon-import" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#9b59b6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24">
                  <path d="M3 15v4c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2v-4M17 8l-5-5-5 5M12 4.2v10.3"/>
                </svg>
                <span class="lable-import">Importer</span>
              </button>
              <div id="weekImportMenu" class="week-import-menu">
                <!-- Le contenu sera chargé dynamiquement -->
              </div>
            </div>
        </div>
        <!-- ***** FIN DE LA ZONE DU CALENDRIER PERSONNALISÉ ***** -->

        <!-- MODIFICATION : ANCIEN BOUTON REMPLACÉ PAR LE NOUVEAU -->
        <button class="button" id="saveTimetableBtn">
          <svg class="svg-icon" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#056dfa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24">
            <path d="M3 6H21V18a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6z"/>
            <path d="M3 6l3-4h6l3 4"/>
          </svg>
          <span class="lable">Enregistrer</span>
        </button>

        <button class="button-reset" id="resetBtn">
          <svg
    xmlns="http://www.w3.org/2000/svg"
    width="20"
    viewBox="0 0 20 20"
    height="20"
    fill="none"
    class="svg-icon-reset"
  >
    <g stroke-width="1.5" stroke-linecap="round" stroke="#ff342b">
      <path
        d="m3.33337 10.8333c0 3.6819 2.98477 6.6667 6.66663 6.6667 3.682 0 6.6667-2.9848 6.6667-6.6667 0-3.68188-2.9847-6.66664-6.6667-6.66664-1.29938 0-2.51191.37174-3.5371 1.01468"
      ></path>
      <path
        d="m7.69867 1.58163-1.44987 3.28435c-.18587.42104.00478.91303.42582 1.0989l3.28438 1.44986"
      ></path>
    </g>
  </svg>
          <span class="lable-reset">Réinitialiser</span>
        </button>

        <button class="button-autogen" id="autoGenerateBtn">
          <svg width="32px" height="32px" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><defs><style>.a{fill:none;stroke:#5D41DE;stroke-linecap:round;stroke-linejoin:round;}</style></defs><path class="a" d="M12,19.77a11.13,11.13,0,0,0-2.26.94L10,25.24,5.44,25a11.13,11.13,0,0,0-.94,2.26l3.37,3.05-3.37,3a10.68,10.68,0,0,0,.94,2.26L10,35.39l-.23,4.54a11.09,11.09,0,0,0,2.26.93l3.05-3.37,3,3.37a10.64,10.64,0,0,0,2.26-.93l-.23-4.54,4.54.23a10.64,10.64,0,0,0,.93-2.26l-3.37-3,3.37-3.05A11.09,11.09,0,0,0,24.66,25l-4.54.23.23-4.53a10.68,10.68,0,0,0-2.26-.94l-3,3.37Z"/><circle class="a" cx="15.05" cy="30.32" r="3.96"/><path class="a" d="M29.91,7.14a11,11,0,0,0-2.27.93l.24,4.54-4.54-.23a10.64,10.64,0,0,0-.93,2.26l3.36,3-3.36,3.05A11.09,11.09,0,0,0,23.34,23l4.54-.23-.24,4.53a11,11,0,0,0,2.27.94l3-3.37,3,3.37a11.13,11.13,0,0,0,2.26-.94L38,22.76l4.53.23a11.13,11.13,0,0,0,.94-2.26l-3.37-3.05,3.37-3a10.68,10.68,0,0,0-.94-2.26L38,12.61l.23-4.54A11,11,0,0,0,36,7.14l-3,3.37Z"/><circle class="a" cx="32.95" cy="17.68" r="3.96"/></svg>
          <span class="lable-autogen">Générer Automatiquement</span>
        </button>
    
    
    
    <section class="timetable-container" >
      <table id="timetable">
        <thead>
          <tr>
            <th rowspan="2" colspan="2"></th>
            <th colspan="4" class="day-header lundi-day-header">Lundi</th>
            <th colspan="4" class="day-header mardi-day-header">Mardi</th>
            <th colspan="4" class="day-header mercredi-day-header">Mercredi</th>
            <th colspan="4" class="day-header jeudi-day-header">Jeudi</th>
            <th colspan="4" class="day-header vendredi-day-header">Vendredi</th>
            <th colspan="4" class="day-header samedi-day-header">Samedi</th>
          </tr>
          <tr>
            <!-- Lundi -->
            <th class="time-header lundi-session">S1</th>
            <th class="time-header lundi-session">S2</th>
            <th class="time-header lundi-session">S3</th>
            <th class="time-header lundi-session">S4</th>
            <!-- Mardi -->
            <th class="time-header mardi-session">S1</th>
            <th class="time-header mardi-session">S2</th>
            <th class="time-header mardi-session">S3</th>
            <th class="time-header mardi-session">S4</th>
            <!-- Mercredi -->
            <th class="time-header mercredi-session">S1</th>
            <th class="time-header mercredi-session">S2</th>
            <th class="time-header mercredi-session">S3</th>
            <th class="time-header mercredi-session">S4</th>
            <!-- Jeudi -->
            <th class="time-header jeudi-session">S1</th>
            <th class="time-header jeudi-session">S2</th>
            <th class="time-header jeudi-session">S3</th>
            <th class="time-header jeudi-session">S4</th>
            <!-- Vendredi -->
            <th class="time-header vendredi-session">S1</th>
            <th class="time-header vendredi-session">S2</th>
            <th class="time-header vendredi-session">S3</th>
            <th class="time-header vendredi-session">S4</th>
            <!-- Samedi -->
            <th class="time-header samedi-session">S1</th>
            <th class="time-header samedi-session">S2</th>
            <th class="time-header samedi-session">S3</th>
            <th class="time-header samedi-session">S4</th>
          </tr>
        </thead>
        <tbody>
          <!-- Généré dynamiquement -->
        </tbody>
      </table>
    </section>
    
    
    
  </div>
  
  <div class="excel-toolbar" id="excelToolbar">
    <button id="copyBtn" class="tooltip">
      <i class="fas fa-copy"></i> Copier <span class="keyboard-shortcut">Ctrl+C</span>
      <span class="tooltiptext">Copier les cellules sélectionnées</span>
    </button>
    <button id="pasteBtn" class="tooltip">
      <i class="fas fa-paste"></i> Coller <span class="keyboard-shortcut">Ctrl+V</span>
      <span class="tooltiptext">Coller dans les cellules sélectionnées</span>
    </button>
    <button id="cutBtn" class="tooltip">
      <i class="fas fa-cut"></i> Couper <span class="keyboard-shortcut">Ctrl+X</span>
      <span class="tooltiptext">Couper les cellules sélectionnées</span>
    </button>
    <button id="deleteBtn" class="tooltip">
      <i class="fas fa-trash-alt"></i> Supprimer <span class="keyboard-shortcut">Suppr</span>
      <span class="tooltiptext">Effacer le contenu des cellules</span>
    </button>
    <button id="clearSelectionBtn" class="tooltip">
      <i class="fas fa-times"></i> Annuler sélection
      <span class="tooltiptext">Désélectionner les cellules</span>
    </button>
  </div>
  
  <div class="paste-notification" id="pasteNotification"></div>
  
  <!-- NOUVELLE STRUCTURE HTML POUR LA NOTIFICATION -->
  <div id="notification" class="notification" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="notification__icon" id="notificationIcon">
        <i class="fas fa-check"></i>
    </div>
    <div class="notification__body">
        <h2 class="notification__header" id="notificationHeader">Success</h2>
        <p class="notification__text" id="notificationText">Your changes have been saved</p>
    </div>
    <div class="notification__action">
        <button id="notificationClose" class="button" aria-label="dismiss this notification">
            <span aria-hidden="true">✕</span>
        </button>
    </div>
  </div>


  <div id="weekLoader" class="loader-container" style="display: none;">
    <div class="loader">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>
    <p>Chargement en cours...</p>
</div>

  <div id="autoGenModal" style="display: none; position: fixed; z-index: 1050; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);">
    <div style="background-color: #fefefe; margin: 30px auto; padding: 20px; border: 1px solid #888; width: 90%; height: 100%; max-width: 1600px; max-height: 1000px; border-radius: 10px;">
      <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 20px;">
         <!--<h2 style="font-size: 1.8rem; color: #333;">Configuration de la Génération Automatique</h2>-->
         <div style="text-align: right; padding-top: 0px;">
          <button id="runAutoGenerateBtn" class="btn btn-save">Lancer la Génération</button>
        </div>
        <button id="closeModalBtn" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">×</button>
      </div>

      <div style="margin-bottom: 20px; font-size: 1.1rem; display: none; align-items: center;">
        <input type="checkbox" id="prefer5hBlocks" checked style="width: 20px; height: 20px; margin-right: 10px;">
        <label for="prefer5hBlocks">Privilégier les blocs de 5h (2 séances consécutives)</label>
    </div>
      
      <div id="autoGenConstraintsContainer" style="max-height: 400px; overflow-y: auto; padding-right: 15px;">
        <!-- Le contenu sera généré par JS -->
      </div>

      
    </div>
  </div>

  <button class="uiverse" id="voiceAssistantBtn" title="Activer l'assistant vocal">
    <div class="wrapper">
      <span><i class="fas fa-microphone"></i></span>
      <div class="circle circle-12"></div>
      <div class="circle circle-11"></div>
      <div class="circle circle-10"></div>
      <div class="circle circle-9"></div>
      <div class="circle circle-8"></div>
      <div class="circle circle-7"></div>
      <div class="circle circle-6"></div>
      <div class="circle circle-5"></div>
      <div class="circle circle-4"></div>
      <div class="circle circle-3"></div>
      <div class="circle circle-2"></div>
      <div class="circle circle-1"></div>
    </div>
  </button>
<div class="assistant-status" id="assistantStatus"></div>



  <script>


const jours = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
    const seances = ['S1', 'S2', 'S3', 'S4'];
    const SEANCE_DURATION = 2.5;
    let autoGenConstraints = {};
    const dayClasses = {
      'Lundi': 'lundi-cell',
      'Mardi': 'mardi-cell',
      'Mercredi': 'mercredi-cell',
      'Jeudi': 'jeudi-cell',
      'Vendredi': 'vendredi-cell',
      'Samedi': 'samedi-cell'
    };
    let appData = { formateurs: [], groupes: [], fusionGroupes: [], espaces: [], affectations: [] };
    let timetableData = {};
    let groupHours = {};
    let clipboard = { type: null, data: [] };
    let selectedDate = new Date();
    let calendarCurrentDate = new Date();
    let currentWeekValue = '';
    
    
    
    

    

    function updateEspacesTags() {
        const container = document.getElementById('espacesContainer');
        if (!container) return;
        container.innerHTML = '';
        appData.espaces.forEach(espace => {
            const tag = document.createElement('div');
            tag.className = 'espace-tag';
            tag.innerHTML = `${espace}<button onclick="removeEspace('${espace}')">×</button>`;
            container.appendChild(tag);
        });
    }

    document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('notificationClose').addEventListener('click', () => {
        document.getElementById('notification').classList.add('hide');
    });
});

    // =========================================================================
    // ==     NOUVELLE SECTION : LOGIQUE DU CALENDRIER PERSONNALISÉ           ==
    // =========================================================================

    /**
     * Initialise les écouteurs d'événements pour le calendrier personnalisé.
     */
    function setupCustomCalendar() {
        const display = document.getElementById('customWeekDisplay');
        const popup = document.getElementById('calendarPopup');
        const prevBtn = document.getElementById('prevMonthBtn');
        const nextBtn = document.getElementById('nextMonthBtn');

        display.addEventListener('click', () => {
            const isVisible = popup.style.display === 'block';
            popup.style.display = isVisible ? 'none' : 'block';
            if (!isVisible) {
                calendarCurrentDate = new Date(selectedDate);
                generateCalendar(calendarCurrentDate);
            }
        });

        prevBtn.addEventListener('click', () => {
            calendarCurrentDate.setMonth(calendarCurrentDate.getMonth() - 1);
            generateCalendar(calendarCurrentDate);
        });

        nextBtn.addEventListener('click', () => {
            calendarCurrentDate.setMonth(calendarCurrentDate.getMonth() + 1);
            generateCalendar(calendarCurrentDate);
        });
        
        // Fermer le popup si on clique en dehors
        document.addEventListener('click', (e) => {
            if (!display.contains(e.target) && !popup.contains(e.target)) {
                popup.style.display = 'none';
            }
        });
    }
    
    /**
     * Génère et affiche le calendrier pour un mois donné.
     * @param {Date} date - Une date dans le mois à afficher.
     */
    function generateCalendar(date) {
        const calendarBody = document.getElementById('calendarBody');
        const calendarTitle = document.getElementById('calendarTitle');
        
        calendarBody.innerHTML = '';
        const month = date.getMonth();
        const year = date.getFullYear();

        const monthName = date.toLocaleDateString('fr-FR', { month: 'long' });
        calendarTitle.textContent = `${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${year}`;

        const firstDayOfMonth = new Date(year, month, 1);
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const dateOffset = (firstDayOfMonth.getDay() + 6) % 7; 

        const selectedWeekInfo = getWeekInfo(selectedDate);
        const { startOfWeek, endOfWeek } = selectedWeekInfo;

        let currentDay = 1;
        for (let i = 0; i < 6; i++) {
            const row = document.createElement('tr');
            for (let j = 0; j < 7; j++) {
                const cell = document.createElement('td');
                if (i === 0 && j < dateOffset) {
                    // Cellules vides avant
                } else if (currentDay > daysInMonth) {
                    // Cellules vides après
                } else {
                    const cellDate = new Date(year, month, currentDay);
                    cellDate.setHours(0,0,0,0);
                    const dayDiv = document.createElement('div');
                    dayDiv.className = 'calendar-day';
                    dayDiv.textContent = currentDay;

                    const today = new Date();
                    today.setHours(0,0,0,0);
                    if (cellDate.getTime() === today.getTime()) {
                        dayDiv.classList.add('today');
                    }
                    
                    if (cellDate.getMonth() === 7) { // Août
                        dayDiv.classList.add('disabled-day');
                    } else {
                        dayDiv.onclick = () => {
                           updateWeekSelection(cellDate);
                           document.getElementById('calendarPopup').style.display = 'none';
                        };
                    }
                    
                    // NOUVELLE LOGIQUE POUR LE STYLE DE LA SEMAINE SÉLECTIONNÉE
                    if (cellDate >= startOfWeek && cellDate <= endOfWeek) {
                        if (cellDate.getTime() === startOfWeek.getTime()) {
                            dayDiv.classList.add('selected-start');
                        } else if (cellDate.getTime() === endOfWeek.getTime()) {
                            dayDiv.classList.add('selected-end');
                        } else {
                            dayDiv.classList.add('selected-in-range');
                        }
                    }

                    cell.appendChild(dayDiv);
                    currentDay++;
                }
                row.appendChild(cell);
            }
            calendarBody.appendChild(row);
            if (currentDay > daysInMonth) break;
        }
    }
    
    /**
     * Met à jour l'affichage et charge les données pour la semaine d'une date donnée.
     * @param {Date} date - La date sélectionnée.
     */
    function updateWeekSelection(date) {
        selectedDate = date;
        const weekInfo = getWeekInfo(date);
        
        const display = document.getElementById('customWeekDisplay');
        const start = weekInfo.startOfWeek.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short' });
        const end = weekInfo.endOfWeek.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short' });
        
        document.getElementById('weekDisplayText').innerHTML = `<strong>S${weekInfo.weekNumber}</strong> <span style="font-size:0.9em; color: #555;">(${start} - ${end})</span>`;
        
        if (weekInfo.weekValue !== currentWeekValue) {
            currentWeekValue = weekInfo.weekValue;
            loadWeekData(currentWeekValue);
        }

        generateCalendar(calendarCurrentDate);
    }
    
    /**
     * Obtient l'année de début de l'année scolaire pour une date donnée.
     * @param {Date} date - La date à évaluer.
     * @returns {number} - L'année de début (ex: 2024 pour l'année 2024-2025).
     */
    function getSchoolYear(date) {
        return (date.getMonth() < 8) ? date.getFullYear() - 1 : date.getFullYear(); // 8 = Septembre
    }
    
    /**
     * Fonction principale qui calcule toutes les informations sur une semaine scolaire.
     * @param {Date} date - La date pour laquelle on veut les informations.
     * @returns {object} - Un objet contenant les détails de la semaine.
     */
    function getWeekInfo(date) {
        const schoolYear = getSchoolYear(date);
        
        let firstDayOfSeptember = new Date(schoolYear, 8, 1);
        let dayOfWeek = firstDayOfSeptember.getDay();
        let firstMonday = new Date(firstDayOfSeptember);
        if (dayOfWeek !== 1) {
            const offset = (dayOfWeek === 0) ? 1 : 8 - dayOfWeek;
            firstMonday.setDate(firstDayOfSeptember.getDate() + offset);
        }
        
        let startOfWeek = new Date(date);
        const day = startOfWeek.getDay();
        const diff = startOfWeek.getDate() - day + (day === 0 ? -6 : 1);
        startOfWeek.setDate(diff);
        startOfWeek.setHours(0, 0, 0, 0);
        firstMonday.setHours(0, 0, 0, 0);
        
        let weekNumber = 1;
        if (startOfWeek >= firstMonday) {
            const timeDiff = startOfWeek.getTime() - firstMonday.getTime();
            weekNumber = Math.floor(timeDiff / (1000 * 60 * 60 * 24 * 7)) + 1;
        }

        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6);
        
        return {
            schoolYear: schoolYear,
            weekNumber: weekNumber,
            startOfWeek: startOfWeek,
            endOfWeek: endOfWeek,
            weekValue: `${schoolYear}-W${weekNumber}`
        };
    }

    // =========================================================================
    // ==               FIN DE LA SECTION CALENDRIER                          ==
    // =========================================================================


    window.addEventListener('resize', () => {
        document.querySelectorAll('.auto-resize-select').forEach(resizeTextToFit);
    });

    function resizeTextToFit(select) {
        const cell = select.closest('td');
        if (!cell) return;
        select.style.fontSize = '10px';
        let fontSize = 10;
        while (select.scrollWidth > cell.offsetWidth && fontSize > 6) {
            fontSize -= 0.5;
            select.style.fontSize = fontSize + 'px';
        }
    }

    function getFormattedName(name) {
        if (!name) return '';
        const words = name.trim().split(/\s+/).filter(word => word.length > 0);
        if (words.length <= 1) return name;
        if (words.length === 2) return words[1];
        const avantDernier = words[words.length - 2];
        const dernier = words[words.length - 1];
        return avantDernier.length < 4 ? `${avantDernier} ${dernier}` : dernier;
    }

    function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        document.getElementById('fileName').textContent = file.name;
        document.getElementById('fileName').style.display = 'block';
        const formData = new FormData();
        formData.append('excelFile', file);
        document.getElementById('weekLoader').style.display = 'flex';
        fetch('../api/data/upload_base_data.php', { method: 'POST', body: formData })
            .then(response => {
                if (!response.ok) {
                    // Capture les erreurs HTTP comme 500, 404 etc.
                    return response.text().then(text => { 
                        // On essaie de ne pas afficher tout le HTML d'erreur dans l'alerte
                        const shortError = text.length > 300 ? text.substring(0, 300) + '...' : text;
                        throw new Error(`Erreur serveur (HTTP ${response.status}): ${shortError}`);
                    });
                }
                return response.json(); // Tente de parser en JSON
            })
            .then(result => {
                document.getElementById('weekLoader').style.display = 'none';
                if (result.success) {
                    showNotification("Fichier traité et données mises à jour !", "success");
                    loadInitialData(); // On recharge tout pour refléter les changements
                } else {
                    showNotification(result.message || "Erreur lors du traitement.", "error");
                }
            })
            .catch(error => {
                document.getElementById('weekLoader').style.display = 'none';
                console.error("Erreur détaillée de l'upload:", error);
                // Affiche une erreur plus informative
                if (error instanceof SyntaxError) {
                    showNotification("Erreur: La réponse du serveur n'est pas un JSON valide. Vérifiez les logs PHP.", "error");
                } else {
                    showNotification(error.message || "Erreur de communication lors de l'envoi.", "error");
                }
            });
    }

    function generateTimetable() {
      const tbody = document.querySelector('#timetable tbody');
      tbody.innerHTML = '';
      if (!appData.formateurs || appData.formateurs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="26" style="text-align:center; padding: 20px; font-size: 1.1rem; color: #777;">Aucun formateur à afficher. Veuillez charger un fichier Excel contenant les données de base.</td></tr>';
        return;
      }
      renderTimetableFromData(timetableData);
      const timetableElement = document.getElementById('timetable');
      timetableElement.removeEventListener('change', handleTableInteraction);
      timetableElement.addEventListener('change', handleTableInteraction);
    }

    function handleTableInteraction(e) {
        const target = e.target;
        if (target.tagName !== 'SELECT') return;
        const type = target.dataset.type;
        if (type === 'groupe') {
            handleGroupeChange(e);
            updateFormateurCell(target.dataset.formateur);
        } else if (type === 'module') {
            handleModuleChange(e);
        } else if (type === 'salle') {
            handleSalleChange(e);
        }
        const cell = target.closest('td');
        if (target.value) {
            cell.classList.add('selected-cell');
        } else {
            cell.classList.remove('selected-cell');
        }
        resizeTextToFit(target);
    }

    function createSelect(jour, seance, formateur, type, options, selectedValue = '') {
        const select = document.createElement('select');
        select.dataset.jour = jour;
        select.dataset.seance = seance;
        select.dataset.formateur = formateur;
        select.dataset.type = type;
        select.className = "auto-resize-select";
        const emptyOption = document.createElement('option');
        emptyOption.value = '';
        emptyOption.textContent = '';
        select.appendChild(emptyOption);
        options.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option;
            opt.textContent = option;
            if (option === selectedValue) {
                opt.selected = true;
            }
            select.appendChild(opt);
        });
        if (type === 'module') {
            select.disabled = !selectedValue;
        }
        return select;
    }


    function updateGroupeSelectOptions(formateur, jour, seance, salle, isTeams) {
        const groupeSelect = document.querySelector(
            `select[data-formateur="${formateur}"][data-jour="${jour}"][data-seance="${seance}"][data-type="groupe"]`
        );
        if (!groupeSelect) return;
        const currentGroupe = groupeSelect.value;
        groupeSelect.innerHTML = '';
        const emptyOption = document.createElement('option');
        emptyOption.value = '';
        groupeSelect.appendChild(emptyOption);
        const source = isTeams ? appData.fusionGroupes : appData.groupes;
        const typeAffection = isTeams ? 'synchrone' : 'presentiel';
        let foundCurrent = false;
        source.forEach(groupe => {
            if (appData.affectations.some(a => a.formateur === formateur && a.groupe === groupe && a.type === typeAffection)) {
                const option = document.createElement('option');
                option.value = groupe;
                option.textContent = groupe;
                groupeSelect.appendChild(option);
                if (groupe === currentGroupe) {
                    foundCurrent = true;
                }
            }
        });
        if (foundCurrent) {
            groupeSelect.value = currentGroupe;
        } else if (currentGroupe) {
            const option = document.createElement('option');
            option.value = currentGroupe;
            option.textContent = currentGroupe;
            option.style.color = 'red';
            groupeSelect.appendChild(option);
            groupeSelect.value = currentGroupe;
        }
    }

    function handleGroupeChange(e) {
      const select = e.target;
      const jour = select.dataset.jour;
      const seance = select.dataset.seance;
      const formateur = select.dataset.formateur;
      const groupe = select.value;
      const conflict = checkGroupConflict(jour, seance, groupe, select);
      if (conflict) {
        showNotification(`Conflit: Le groupe ${groupe} est déjà pris.`, "chevauchement");
        highlightConflict(jour, seance, 'groupe', groupe);
        select.value = '';
        const event = new Event('change');
        select.dispatchEvent(event);
        updateTimetableData(jour, seance, formateur, 'groupe', '');
        return;
      }
      const oldGroupe = timetableData[formateur][jour][seance].groupe;
      const moduleSelect = document.querySelector(`select[data-jour="${jour}"][data-seance="${seance}"][data-formateur="${formateur}"][data-type="module"]`);
      if (groupe) {
        moduleSelect.disabled = false;
        if (oldGroupe && oldGroupe !== groupe) {
          groupHours[oldGroupe] = (groupHours[oldGroupe] || 0) - SEANCE_DURATION;
          checkGroupHours(oldGroupe);
        }
        groupHours[groupe] = (groupHours[groupe] || 0) + SEANCE_DURATION;
        checkGroupHours(groupe);
        updateModuleOptions(formateur, jour, seance, groupe);
        const currentModule = moduleSelect.value;
        if (!moduleSelect.querySelector(`option[value="${currentModule}"]`)) {
          moduleSelect.value = '';
        }
      } else {
        if (oldGroupe) {
          groupHours[oldGroupe] = (groupHours[oldGroupe] || 0) - SEANCE_DURATION;
          checkGroupHours(oldGroupe);
        }
        moduleSelect.disabled = true;
        moduleSelect.value = '';
      }
      updateTimetableData(jour, seance, formateur, 'groupe', groupe);
      updateTimetableData(jour, seance, formateur, 'module', moduleSelect.value);
    }
    
    function checkGroupHours(groupe) {
        if (!groupe) return;
        const hours = groupHours[groupe] || 0;
        updateGroupCells(groupe);
        if (hours >= 40) {
            showNotification(`Le groupe ${groupe} a atteint ${hours.toFixed(1)}h.`, "warning");
            document.querySelectorAll(`select[data-type="groupe"] option[value="${groupe}"]:checked`).forEach(opt => {
                const cell = opt.closest('td');
                cell.classList.add('group-highlight');
                setTimeout(() => cell.classList.remove('group-highlight'), 3000);
            });
        }
    }
    
    function updateGroupCells(groupe) {
      if (!groupe) return;
      const hours = groupHours[groupe] || 0;
      document.querySelectorAll(`select[data-type="groupe"] option[value="${groupe}"]:checked`).forEach(opt => {
            const cell = opt.closest('td');
            if(cell){
                cell.classList.toggle('group-highlight', hours >= 40);
            }
        });
    }

    function getCurrentTimetableData() {
        return {
            semaine: currentWeekValue, // Utilise la variable globale du calendrier
            emploiDuTemps: timetableData
        };
    }

    function updateFormateurCell(formateur) {
      const formateurCell = document.querySelector(`td.formateur-cell[data-formateur="${formateur}"]`);
      if (!formateurCell) return;
      let count = 0;
      if (timetableData[formateur]) {
        for (const jour in timetableData[formateur]) {
            for (const seance in timetableData[formateur][jour]) {
                if (timetableData[formateur][jour][seance].groupe) {
                    count++;
                }
            }
        }
      }
      const heures = count * SEANCE_DURATION;
      const hoursElement = document.getElementById(`hours-${formateur}`);
      if (hoursElement) {
        hoursElement.textContent = `${heures.toFixed(1)}`;
      }
      formateurCell.classList.remove('formateur-green', 'formateur-orange', 'formateur-red');
      if (heures <= 22.5) {
        formateurCell.classList.add('formateur-green');
      } else if (heures <= 35) {
        formateurCell.classList.add('formateur-orange');
      } else {
        formateurCell.classList.add('formateur-red');
      }
    }

// --- FONCTION MODIFIEE : handleModuleChange (avec logs) ---
function handleModuleChange(e) {
    const select = e.target;
    const jour = select.dataset.jour;
    const seance = select.dataset.seance;
    const formateur = select.dataset.formateur;
    const module = select.value;

    console.log(`[handleModuleChange] Changement sur ${formateur}, ${jour}, ${seance}. Module sélectionné: '${module}'`); // LOG

    updateTimetableData(jour, seance, formateur, 'module', module);

    // --- Logique de Coloration par Semestre ---
    const cell = select.closest('td');
    if (cell) {
        console.log(`[handleModuleChange] Cellule trouvée. Suppression des classes de semestre.`); // LOG
        cell.classList.remove('module-s1', 'module-s2', 'module-annual');

        if (module) {
            const selectedOption = select.options[select.selectedIndex];
            const semester = selectedOption.dataset.semester;
            console.log(`[handleModuleChange] Option sélectionnée '${module}', data-semester='${semester}'`); // LOG

            if (semester) {
                const classNameToAdd = `module-${semester.toLowerCase()}`;
                console.log(`[handleModuleChange] Ajout de la classe CSS: ${classNameToAdd}`); // LOG
                cell.classList.add(classNameToAdd);
            } else {
                 console.warn(`[handleModuleChange] data-semester est manquant ou vide pour le module '${module}'`); // LOG WARNING
            }
            cell.classList.add('selected-cell');
        } else {
            console.log(`[handleModuleChange] Aucun module sélectionné, suppression de 'selected-cell'.`); // LOG
            cell.classList.remove('selected-cell');
        }
    } else {
         console.error(`[handleModuleChange] Cellule parente <td> introuvable pour le select.`); // LOG ERROR
    }
    // --- Fin Logique de Coloration ---
}
// --- FIN FONCTION MODIFIEE : handleModuleChange ---

    function handleSalleChange(e) {
        const select = e.target;
        const jour = select.dataset.jour;
        const seance = select.dataset.seance;
        const formateur = select.dataset.formateur;
        const salle = select.value;
        const cell = select.closest('td');
        cell.classList.toggle('selected-cell', !!salle);
        if (salle && checkRoomConflict(jour, seance, salle, select)) {
            showNotification(`La salle ${salle} est déjà occupée.`, "chevauchement");
            highlightConflict(jour, seance, 'salle', salle);
            select.value = '';
            cell.classList.remove('selected-cell');
            updateTimetableData(jour, seance, formateur, 'salle', '');
            return;
        }
        const isTeams = salle === "TEAMS";
        updateGroupeSelectOptions(formateur, jour, seance, salle, isTeams);
        const groupeSelect = document.querySelector(`select[data-jour="${jour}"][data-seance="${seance}"][data-formateur="${formateur}"][data-type="groupe"]`);
        if (groupeSelect) {
            const options = Array.from(groupeSelect.options).map(opt => opt.value);
            if (!options.includes(groupeSelect.value)) {
                groupeSelect.value = '';
                groupeSelect.dispatchEvent(new Event('change'));
            }
        }
        updateTimetableData(jour, seance, formateur, 'salle', salle);
    }

    function checkGroupConflict(jour, seance, groupe, currentSelect) {
        if (!groupe) return false;
        const newGroups = groupe.trim().split(/\s+/).filter(g => g);
        const allGroupeSelects = document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="groupe"]`);
        for (const select of allGroupeSelects) {
            if (select === currentSelect || !select.value) continue;
            const existingGroups = select.value.trim().split(/\s+/).filter(g => g);
            if (newGroups.some(ng => existingGroups.includes(ng))) {
                return true;
            }
        }
        return false;
    }

    function checkRoomConflict(jour, seance, salle, currentSelect) {
      if (salle === "TEAMS" || !salle) return false;
      const allSalleSelects = document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="salle"]`);
      for (const select of allSalleSelects) {
        if (select !== currentSelect && select.value === salle) {
            return true;
        }
      }
      return false;
    }

    function highlightConflict(jour, seance, type, value) {
      document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="${type}"]`).forEach(select => {
        const values = select.value.trim().split(/\s+/);
        if (values.includes(value)) {
            const cell = select.closest('td');
            cell.classList.add('conflict-highlight');
            setTimeout(() => cell.classList.remove('conflict-highlight'), 3000);
        }
      });
    }

    function initializeTimetableData() {
        timetableData = {};
        appData.formateurs.forEach(formateur => {
            timetableData[formateur] = {};
            jours.forEach(jour => {
                timetableData[formateur][jour] = {};
                seances.forEach(seance => {
                    timetableData[formateur][jour][seance] = { groupe: '', module: '', salle: '' };
                });
            });
        });
        groupHours = {};
    }

    function updateTimetableData(jour, seance, formateur, type, value) {
      if (timetableData[formateur] &&
          timetableData[formateur][jour] &&
          timetableData[formateur][jour][seance]) {
        timetableData[formateur][jour][seance][type] = value;
      }
    }

    async function saveTimetable() {
        const semaine = currentWeekValue;
        if (!semaine) {
            showNotification("Veuillez sélectionner une semaine.", "warning");
            return;
        }
        const dataToSave = getCurrentTimetableData();
        try {
            const saveResponse = await fetch('../api/data/save_timetable.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(dataToSave)
            });
            const saveResult = await saveResponse.json();
            if (saveResult.success) {
                showNotification("Emploi du temps enregistré avec succès", "success");
            } else {
                showNotification("Erreur: " + (saveResult.message || 'Erreur serveur'), "error");
            }
        } catch (error) {
            showNotification("Erreur réseau: " + error.message, "error");
        }
    }

    document.getElementById('saveTimetableBtn')?.addEventListener('click', saveTimetable);

    function resetTimetable() {
      if (confirm("Êtes-vous sûr de vouloir effacer l'emploi du temps affiché ?")) {
        initializeTimetableData();
        renderTimetableFromData(timetableData);
        showNotification("L'emploi du temps a été effacé.", "info");
      }
    }

    // =========================================================================
    // ==           NOUVELLE FONCTION DE NOTIFICATION                       ==
    // =========================================================================
    let notificationTimeout;
    function showNotification(message, type = "info") {
        const notification = document.getElementById('notification');
        const header = document.getElementById('notificationHeader');
        const text = document.getElementById('notificationText');
        const iconContainer = document.getElementById('notificationIcon');
        
        // Annuler le timeout précédent pour éviter une fermeture prématurée
        clearTimeout(notificationTimeout);

        // Définir les styles et le contenu en fonction du type
        const typeSettings = {
            success: { header: 'Succès', icon: 'fa-check', color: '#4CAF50' },
            error: { header: 'Erreur', icon: 'fa-times', color: '#f44336' },
            chevauchement:{ header: 'Chevauchement', icon: 'fa-exclamation-triangle', color: '#f44336' },
            warning: { header: 'Attention', icon: 'fa-exclamation-triangle', color: '#ff9800' },
            info: { header: 'Information', icon: 'fa-info-circle', color: '#2196F3' }
        };
        const settings = typeSettings[type] || typeSettings.info;

        header.textContent = settings.header;
        text.textContent = message;
        iconContainer.innerHTML = `<i class="fas ${settings.icon}"></i>`;
        notification.style.setProperty('--accent-color', settings.color);

        // Afficher la notification
        notification.classList.remove('hide');
        notification.classList.add('show');

        // La cacher après un délai
        notificationTimeout = setTimeout(() => {
            notification.classList.add('hide');
        }, 4000); // 4 secondes
    }
    
    function setupExcelSelection() {
      const table = document.getElementById('timetable');
      const selectionDiv = document.createElement('div');
      selectionDiv.className = 'excel-selection';
      selectionDiv.style.display = 'none';
      document.body.appendChild(selectionDiv);
      let isSelecting = false;
      let startCell = null;
      let startX, startY;
      table.addEventListener('mousedown', function(e) {
        if (!e.ctrlKey) {
          clearExcelSelection();
          return;
        }
        const cell = e.target.closest('td');
        if (!cell) return;
        if (cell.classList.contains('formateur-cell') || 
            cell.classList.contains('type-cell')) {
          return;
        }
        e.preventDefault();
        isSelecting = true;
        startCell = cell;
        startX = e.clientX;
        startY = e.clientY;
        const toolbar = document.getElementById('excelToolbar');
        toolbar.classList.add('visible');
        const rect = cell.getBoundingClientRect();
        selectionDiv.style.left = `${rect.left}px`;
        selectionDiv.style.top = `${rect.top}px`;
        selectionDiv.style.width = `${rect.width}px`;
        selectionDiv.style.height = `${rect.height}px`;
        selectionDiv.style.display = 'block';
        document.querySelectorAll('.excel-selected').forEach(c => {
          c.classList.remove('excel-selected');
        });
        cell.classList.add('excel-selected');
      });
      document.addEventListener('mousemove', function(e) {
        if (!isSelecting || !startCell) return;
        const currentCell = document.elementFromPoint(e.clientX, e.clientY)?.closest('td');
        if (!currentCell || currentCell === startCell) return;
        const startRect = startCell.getBoundingClientRect();
        const currentRect = currentCell.getBoundingClientRect();
        const minX = Math.min(startRect.left, currentRect.left);
        const maxX = Math.max(startRect.right, currentRect.right);
        const minY = Math.min(startRect.top, currentRect.top);
        const maxY = Math.max(startRect.bottom, currentRect.bottom);
        selectionDiv.style.left = `${minX}px`;
        selectionDiv.style.top = `${minY}px`;
        selectionDiv.style.width = `${maxX - minX}px`;
        selectionDiv.style.height = `${maxY - minY}px`;
        const allCells = document.querySelectorAll('tbody td');
        allCells.forEach(cell => {
          if (cell.classList.contains('formateur-cell') || 
              cell.classList.contains('type-cell')) {
            return;
          }
          const cellRect = cell.getBoundingClientRect();
          const isInSelection = 
            cellRect.left >= minX && 
            cellRect.right <= maxX && 
            cellRect.top >= minY && 
            cellRect.bottom <= maxY;
          if (isInSelection) {
            cell.classList.add('excel-selected');
          } else {
            cell.classList.remove('excel-selected');
          }
        });
      });
      document.addEventListener('mouseup', function() {
        isSelecting = false;
      });
      table.addEventListener('contextmenu', function(e) {
        if (isSelecting) {
          e.preventDefault();
        }
      });
    }

    function setupExcelToolbarListeners() {
      document.getElementById('copyBtn').addEventListener('click', copySelectedCells);
      document.getElementById('pasteBtn').addEventListener('click', pasteSelectedCells);
      document.getElementById('cutBtn').addEventListener('click', cutSelectedCells);
      document.getElementById('deleteBtn').addEventListener('click', deleteSelectedCells);
      document.getElementById('clearSelectionBtn').addEventListener('click', clearExcelSelection);
      document.addEventListener('keydown', function(e) {
        if (e.ctrlKey) {
          if (e.key === 'c') {
            e.preventDefault();
            copySelectedCells();
          } else if (e.key === 'v') {
            e.preventDefault();
            pasteSelectedCells();
          } else if (e.key === 'x') {
            e.preventDefault();
            cutSelectedCells();
          }
        } else if (e.key === 'Delete') {
          e.preventDefault();
          deleteSelectedCells();
        }
      });
      document.getElementById('clearSelectionBtn').addEventListener('click', clearExcelSelection);
    }
    
    function clearExcelSelection() {
      document.querySelectorAll('.excel-selected').forEach(c => {
        c.classList.remove('excel-selected');
      });
      const selectionDiv = document.querySelector('.excel-selection');
      if (selectionDiv) {
        selectionDiv.style.display = 'none';
      }
      const toolbar = document.getElementById('excelToolbar');
      toolbar.classList.remove('visible');
    }

    function showPasteNotification(message) {
      const notification = document.getElementById('pasteNotification');
      notification.textContent = message;
      notification.classList.add('show');
      setTimeout(() => notification.classList.remove('show'), 2000);
    }
    
    function copySelectedCells() {
      const selectedCells = document.querySelectorAll('.excel-selected');
      if (selectedCells.length === 0) {
        showNotification("Aucune cellule sélectionnée", "warning");
        return;
      }
      clipboard = {
        type: 'copy',
        data: [],
        matrix: []
      };
      const rows = {};
      selectedCells.forEach(cell => {
        const rowIndex = cell.closest('tr').rowIndex;
        const cellIndex = cell.cellIndex;
        if (!rows[rowIndex]) rows[rowIndex] = {};
        rows[rowIndex][cellIndex] = cell;
      });
      const rowIndices = Object.keys(rows).sort((a, b) => a - b);
      rowIndices.forEach(rowIndex => {
        const row = [];
        const cellIndices = Object.keys(rows[rowIndex]).sort((a, b) => a - b);
        cellIndices.forEach(cellIndex => {
          const cell = rows[rowIndex][cellIndex];
          const select = cell.querySelector('select');
          if (select) {
            row.push({
              formateur: select.dataset.formateur,
              jour: select.dataset.jour,
              seance: select.dataset.seance,
              type: select.dataset.type,
              value: select.value
            });
          }
        });
        clipboard.matrix.push(row);
      });
      showPasteNotification(`${selectedCells.length} cellules copiées`);
    }
    
    function pasteSelectedCells() {
      if (!clipboard || !clipboard.matrix || clipboard.matrix.length === 0) {
        showNotification("Aucune donnée à coller", "warning");
        return;
      }
      const selectedCells = document.querySelectorAll('.excel-selected');
      if (selectedCells.length === 0) {
        showNotification("Aucune cellule sélectionnée pour le collage", "warning");
        return;
      }
      const destMatrix = [];
      const destRows = {};
      selectedCells.forEach(cell => {
        const rowIndex = cell.closest('tr').rowIndex;
        const cellIndex = cell.cellIndex;
        if (!destRows[rowIndex]) destRows[rowIndex] = {};
        destRows[rowIndex][cellIndex] = cell;
      });
      const rowIndices = Object.keys(destRows).sort((a, b) => a - b);
      rowIndices.forEach(rowIndex => {
        const row = [];
        const cellIndices = Object.keys(destRows[rowIndex]).sort((a, b) => a - b);
        cellIndices.forEach(cellIndex => {
          row.push(destRows[rowIndex][cellIndex]);
        });
        destMatrix.push(row);
      });
      let pasteCount = 0;
      for (let i = 0; i < destMatrix.length; i++) {
        for (let j = 0; j < destMatrix[i].length; j++) {
          const srcRow = i % clipboard.matrix.length;
          const srcCol = j % clipboard.matrix[0].length;
          const cellData = clipboard.matrix[srcRow][srcCol];
          const cell = destMatrix[i][j];
          const select = cell.querySelector('select');
          if (select && select.dataset.type === cellData.type) {
            select.value = cellData.value;
            const event = new Event('change');
            select.dispatchEvent(event);
            updateTimetableData(
              select.dataset.jour,
              select.dataset.seance,
              select.dataset.formateur,
              select.dataset.type,
              cellData.value
            );
            const cellElement = select.closest('td');
            if (cellData.value) {
              cellElement.classList.add('selected-cell');
              cellElement.classList.remove('empty-cell');
            } else {
              cellElement.classList.remove('selected-cell');
              cellElement.classList.add('empty-cell');
            }
            if (select.dataset.type === 'groupe') {
              updateModuleOptions(
                select.dataset.formateur,
                select.dataset.jour,
                select.dataset.seance,
                cellData.value
              );
            }
            pasteCount++;
          }
        }
      }
      if (pasteCount > 0) {
        showPasteNotification(`${pasteCount} cellules collées`);
      } else {
        showNotification("Aucune cellule compatible pour le collage", "warning");
      }
    }
    
    function cutSelectedCells() {
      copySelectedCells();
      const selectedCells = document.querySelectorAll('.excel-selected');
      selectedCells.forEach(cell => {
        const selects = cell.querySelectorAll('select');
        selects.forEach(select => {
          select.value = '';
          const event = new Event('change');
          select.dispatchEvent(event);
          updateTimetableData(
            select.dataset.jour,
            select.dataset.seance,
            select.dataset.formateur,
            select.dataset.type,
            ''
          );
          const cellElement = select.closest('td');
          cellElement.classList.remove('selected-cell');
          cellElement.classList.add('empty-cell');
        });
      });
      showPasteNotification("Cellules coupées");
    }

    function deleteSelectedCells() {
      const selectedCells = document.querySelectorAll('.excel-selected');
      if (selectedCells.length === 0) {
        showNotification("Aucune cellule sélectionnée", "warning");
        return;
      }
      let deleteCount = 0;
      selectedCells.forEach(cell => {
        const selects = cell.querySelectorAll('select');
        selects.forEach(select => {
          select.value = '';
          const event = new Event('change');
          select.dispatchEvent(event);
          updateTimetableData(
            select.dataset.jour,
            select.dataset.seance,
            select.dataset.formateur,
            select.dataset.type,
            ''
          );
          const cellElement = select.closest('td');
          cellElement.classList.remove('selected-cell');
          cellElement.classList.add('empty-cell');
          deleteCount++;
        });
      });
      showPasteNotification(`${deleteCount} cellules effacées`);
    }

    function setupEventListeners() {
    const fileInput = document.getElementById('fileInput');
    const resetBtn = document.getElementById('resetBtn');
    const autoGenerateBtn = document.getElementById('autoGenerateBtn');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const runAutoGenerateBtn = document.getElementById('runAutoGenerateBtn');

    if (fileInput) fileInput.addEventListener('change', handleFileUpload);
    if (resetBtn) resetBtn.addEventListener('click', resetTimetable);
    if (autoGenerateBtn) autoGenerateBtn.addEventListener('click', openAutoGenModal);
    if (closeModalBtn) closeModalBtn.addEventListener('click', () => {
        document.getElementById('autoGenModal').style.display = 'none';
    });
    if (runAutoGenerateBtn) runAutoGenerateBtn.addEventListener('click', runAutoGeneration);

    const timetable = document.getElementById('timetable');
    if (timetable) {
        // Gère les actions *après* un changement.
        timetable.removeEventListener('change', handleTableInteraction);
        timetable.addEventListener('change', handleTableInteraction);

        // NOUVEAU : Gestion des clics pour mettre à jour l'affichage *avant* sélection.
        timetable.addEventListener('mousedown', function(e) {
            if (e.target.tagName !== 'SELECT') return;

            // Si c'est un menu de salle, on filtre les options.
            if (e.target.dataset.type === 'salle') {
                updateSalleOptions(e.target);
            } 
            // Si c'est un menu de groupe, on colore les options indisponibles.
            else if (e.target.dataset.type === 'groupe') {
                styleGroupOptions(e.target);
            }
        });
    }

    // NOUVEL ÉCOUTEUR POUR LE BOUTON D'IMPORTATION
    document.getElementById('importWeekBtn')?.addEventListener('click', showWeekDropdown);
      
      // Fermer le menu quand on clique en dehors
      document.addEventListener('click', (e) => {
        const menu = document.getElementById('weekImportMenu');
        const btn = document.getElementById('importWeekBtn');
        
        if (menu.classList.contains('show') && 
            !menu.contains(e.target) && 
            !btn.contains(e.target)) {
          menu.classList.remove('show');
        }
      });
}
    
function loadWeekData(weekValue) {
        const loader = document.getElementById('weekLoader');
        loader.style.display = 'flex';
        fetch(`../api/data/get_timetable.php?semaine=${weekValue}`)
            .then(response => response.json())
            .then(result => {
                loader.style.display = 'none';
                if (result.success) {
                    timetableData = result.data;
                    renderTimetableFromData(timetableData);
                    showNotification("Emploi du temps chargé", "success");
                } else {
                    initializeTimetableData();
                    renderTimetableFromData(timetableData);
                    showNotification("Aucun EDT trouvé pour cette semaine, tableau initialisé.", "info");
                }
            })
            .catch(error => {
                loader.style.display = 'none';
                showNotification("Erreur réseau: " + error.message, "error");
            });
    }

// --- FONCTION MODIFIEE : updateModuleOptions (avec logs) ---
function updateModuleOptions(formateur, jour, seance, groupe) {
    const moduleSelect = document.querySelector(`select[data-formateur="${formateur}"][data-jour="${jour}"][data-seance="${seance}"][data-type="module"]`);
    if (!moduleSelect) return;

    const currentModule = moduleSelect.value;
    moduleSelect.innerHTML = '<option value=""></option>';
    moduleSelect.disabled = true;

    if (!groupe) {
        console.log(`[updateModuleOptions] Pas de groupe sélectionné pour ${formateur}, ${jour}, ${seance}.`);
        return;
    }

    moduleSelect.disabled = false;
    const subGroups = groupe.trim().split(/\s+/).filter(g => g);
    console.log(`[updateModuleOptions] Groupes à traiter pour ${formateur}:`, subGroups);
    const modulesEtStatut = new Map();

    appData.affectations.forEach(affectation => {
        if (affectation.formateur === formateur && subGroups.includes(affectation.groupe)) {
            const moduleName = affectation.module;
            // --- LOGIQUE DE DETERMINATION DU SEMESTRE ---
            // Utiliser parseFloat pour s'assurer que ce sont des nombres
            const s1Hours = parseFloat(affectation.s1_heures) || 0;
            const s2Hours = parseFloat(affectation.s2_heures) || 0;
            console.log(`[updateModuleOptions] Module ${moduleName} pour groupe ${affectation.groupe} - S1: ${s1Hours}, S2: ${s2Hours}`); // LOG

            let semesterStatus = "S2"; // Par défaut S2
            if (s1Hours > 0 && s2Hours > 0) {
                semesterStatus = "Annual";
            } else if (s1Hours > 0) {
                semesterStatus = "S1";
            }
            // Sinon, reste S2
            console.log(`[updateModuleOptions] Statut déterminé pour ${moduleName}/${affectation.groupe}: ${semesterStatus}`); // LOG
            // --- FIN LOGIQUE ---
            modulesEtStatut.set(moduleName, semesterStatus);
        }
    });

    // Ajoute les options au <select> avec l'attribut data-semester
    modulesEtStatut.forEach((status, moduleName) => {
        const option = document.createElement('option');
        option.value = moduleName;
        option.textContent = moduleName;
        option.dataset.semester = status; // <-- Ajout de l'attribut crucial
        console.log(`[updateModuleOptions] Ajout de l'option <${moduleName}> avec data-semester="${status}"`); // LOG
        if (moduleName === currentModule) {
            option.selected = true;
        }
        moduleSelect.appendChild(option);
    });

    // Déclenche manuellement handleModuleChange si une valeur était déjà présente
    if (currentModule) {
        const event = new Event('change', { bubbles: true });
        moduleSelect.dispatchEvent(event);
    }
}
// --- FIN FONCTION MODIFIEE : updateModuleOptions ---

function renderTimetableFromData(data) {
        const tbody = document.querySelector('#timetable tbody');
        let html = '';
        if (!appData.formateurs || appData.formateurs.length === 0) {
            tbody.innerHTML = '<tr><td colspan="26" style="text-align:center; padding: 20px;">Données de base non chargées. Veuillez importer un fichier Excel.</td></tr>';
            return;
        }

        initializeTimetableData();
        if (data) {
            timetableData = JSON.parse(JSON.stringify(data));
        }

        // Calculer les heures pour chaque groupe avant de générer le tableau
        groupHours = {};
        for (const formateur in timetableData) {
            for (const jour in timetableData[formateur]) {
                for (const seance in timetableData[formateur][jour]) {
                    const session = timetableData[formateur][jour][seance];
                    if (session.groupe) {
                        const subGroups = session.groupe.trim().split(/\s+/).filter(g => g);
                        subGroups.forEach(g => {
                           groupHours[g] = (groupHours[g] || 0) + SEANCE_DURATION;
                        });
                    }
                }
            }
        }

        appData.formateurs.forEach(formateur => {
            const formateurData = timetableData[formateur] || {};
            let seanceCount = 0;
            if(formateurData){
                Object.values(formateurData).forEach(day => {
                    Object.values(day).forEach(session => {
                        if (session.groupe) seanceCount++;
                    });
                });
            }
            const heures = seanceCount * SEANCE_DURATION;
            let formateurClass = 'formateur-green';
            if (heures > 35) formateurClass = 'formateur-red';
            else if (heures > 22.5) formateurClass = 'formateur-orange';

            // Ligne du formateur
            html += `<tr>
              <td rowspan="3" class="formateur-cell ${formateurClass}" data-formateur="${formateur}">
                <div class="formateur-content">
                  <div class="formateur-name">${formateur}</div>
                  <div class="formateur-hours" id="hours-${formateur}">${heures.toFixed(1)}</div>
                </div>
              </td>
              <td class="type-cell">Groupe</td>`;
            
            // Ligne des Groupes
            jours.forEach(jour => {
                seances.forEach(seance => {
                    const session = formateurData[jour]?.[seance] || { groupe: '', module: '', salle: '' };
                    const dayClass = dayClasses[jour];
                    const isSelected = session.groupe ? 'selected-cell' : '';
                    const isGroupOverloaded = session.groupe && groupHours[session.groupe] >= 40 ? 'group-highlight' : '';
                    const isTeams = session.salle === 'TEAMS';
                    const groupesPossibles = isTeams ? appData.fusionGroupes : appData.groupes;
                    const typeAffection = isTeams ? 'synchrone' : 'presentiel';
                    const groupesFiltres = groupesPossibles.filter(g => appData.affectations.some(a => a.formateur === formateur && a.groupe === g && a.type === typeAffection));
                    html += `<td class="auto-resize-cell draggable-cell ${dayClass} ${isSelected} ${isGroupOverloaded}" draggable="true" data-type="groupe" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                      <select class="auto-resize-select" data-type="groupe" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                        <option value=""></option>
                        ${groupesFiltres.map(g => `<option value="${g}" ${g === session.groupe ? 'selected' : ''}>${g}</option>`).join('')}
                      </select>
                      <div class="drag-indicator"><i class="fas fa-arrows-alt"></i></div>
                    </td>`;
                });
            });
            html += `</tr>`;
            
            // Ligne des Modules
            html += `<tr><td class="type-cell">Module</td>`;
            jours.forEach(jour => {
                seances.forEach(seance => {
                    const session = formateurData[jour]?.[seance] || { groupe: '', module: '', salle: '' };
                    const dayClass = dayClasses[jour];
                    const isModuleSelected = session.module ? 'selected-cell' : '';

                    // --- DÉBUT DE LA LOGIQUE CORRIGÉE ---
                    // 1. Déterminer le semestre du module actuellement en place
                    const semester = getModuleSemester(formateur, session.groupe, session.module);
                    const semesterClass = semester ? `module-${semester.toLowerCase()}` : '';

                    // 2. Trouver tous les modules possibles pour ce créneau avec leur semestre respectif
                    const modulesPossibles = new Map();
                    if (session.groupe) {
                        const subGroups = session.groupe.trim().split(/\s+/).filter(Boolean);
                        appData.affectations.forEach(a => {
                            if (a.formateur === formateur && subGroups.includes(a.groupe)) {
                                const modSemester = getModuleSemester(formateur, a.groupe, a.module);
                                if (modSemester) {
                                    modulesPossibles.set(a.module, modSemester);
                                }
                            }
                        });
                    }
                    
                    // 3. Générer le HTML pour les options du select, en incluant data-semester
                    let moduleOptionsHTML = '';
                    modulesPossibles.forEach((sem, mod) => {
                        moduleOptionsHTML += `<option value="${mod}" data-semester="${sem}" ${mod === session.module ? 'selected' : ''}>${mod}</option>`;
                    });
                    
                    // 4. Construire la cellule TD en ajoutant la classe de semestre
                    html += `<td class="auto-resize-cell ${dayClass} ${isModuleSelected} ${semesterClass}" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                      <select class="auto-resize-select" data-type="module" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}" ${!session.groupe ? 'disabled' : ''}>
                        <option value=""></option>
                        ${moduleOptionsHTML}
                      </select>
                    </td>`;
                    // --- FIN DE LA LOGIQUE CORRIGÉE ---
                });
            });
            html += `</tr>`;

            // Ligne des Salles
            html += `<tr class="salle-row"><td class="type-cell">Espace</td>`;
            jours.forEach(jour => {
                seances.forEach(seance => {
                    const session = formateurData[jour]?.[seance] || { groupe: '', module: '', salle: '' };
                    const dayClass = dayClasses[jour];
                    const isSalleSelected = session.salle ? 'selected-cell' : '';
                    html += `<td class="auto-resize-cell ${dayClass} ${isSalleSelected}" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                      <select class="auto-resize-select" data-type="salle" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                        <option value=""></option>
                        ${appData.espaces.map(e => `<option value="${e}" ${e === session.salle ? 'selected' : ''}>${e}</option>`).join('')}
                      </select>
                    </td>`;
                });
            });
            html += `</tr>`;
        });
        
        tbody.innerHTML = html;
        document.querySelectorAll('.auto-resize-select').forEach(resizeTextToFit);
        Object.keys(groupHours).forEach(checkGroupHours);
        setupDragAndDrop();
    }
    
    let dragSrcElement = null;
    function setupDragAndDrop() {
  const draggables = document.querySelectorAll('.draggable-cell');
  draggables.forEach(item => {
    item.addEventListener('dragstart', handleDragStart, false);
    // C'est cette ligne qui cause l'erreur car handleDragEnter n'est pas défini
    item.addEventListener('dragenter', handleDragEnter, false); 
    item.addEventListener('dragover', handleDragOver, false);
    item.addEventListener('dragleave', handleDragLeave, false);
    item.addEventListener('drop', handleDrop, false);
    item.addEventListener('dragend', handleDragEnd, false);
  });
}

    function handleDragEnter(e) {
  // 'this' est l'élément de la table sur lequel le curseur entre.
  // 'dragSrcElement' est l'élément que l'on est en train de glisser.
  
  // On vérifie que l'on ne dépose pas la séance sur un autre formateur.
  // Cette vérification ajoute de la robustesse.
  if (this.dataset.formateur === dragSrcElement.dataset.formateur) {
    this.classList.add('drop-target');
  }
}

    function handleDragStart(e) {
  dragSrcElement = this;
  const formateur = this.dataset.formateur;
  const jour = this.dataset.jour;
  const seance = this.dataset.seance;
  const sessionData = timetableData[formateur][jour][seance];

  // Si on essaie de glisser une cellule vide, on annule l'opération
  if (!sessionData || !sessionData.groupe) {
      e.preventDefault();
      return;
  }

  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', JSON.stringify({ formateur, jour, seance }));
  this.classList.add('dragging');

  // --- NOUVELLE LOGIQUE POUR METTRE EN ÉVIDENCE LES EMPLACEMENTS POSSIBLES ---
  
  // On récupère toutes les cellules "groupe" du formateur concerné
  const allTrainerCells = document.querySelectorAll(`td[data-formateur="${formateur}"][data-type="groupe"]`);

  allTrainerCells.forEach(cell => {
    const targetJour = cell.dataset.jour;
    const targetSeance = cell.dataset.seance;
    
    // On ne se compare pas à soi-même
    if (targetJour === jour && targetSeance === seance) return;
    
    // On récupère la séance qui se trouve actuellement dans la cellule cible
    const targetOriginalSession = timetableData[formateur][targetJour][targetSeance];

    // Vérification en deux temps pour un ÉCHANGE (swap) :
    // 1. Est-ce que la séance glissée peut aller dans la cellule cible sans conflit externe ?
    const canSourceMoveToTarget = isSlotAvailableForSession(targetJour, targetSeance, sessionData, formateur);

    // 2. Est-ce que la séance de la cellule cible peut aller dans la cellule d'origine sans conflit externe ?
    const canTargetMoveToSource = isSlotAvailableForSession(jour, seance, targetOriginalSession, formateur);

    // Si les deux conditions sont vraies, alors l'échange est possible
    if (canSourceMoveToTarget && canTargetMoveToSource) {
       // On trouve les 3 cellules correspondantes (groupe, module, salle) pour ce créneau cible
       const correspondingCells = document.querySelectorAll(`td[data-formateur="${formateur}"][data-jour="${targetJour}"][data-seance="${targetSeance}"]`);
       correspondingCells.forEach(c => c.classList.add('drop-possible'));
    }
  });
}

    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDragEnd(e) {
  // On nettoie toutes les classes temporaires de toute la table
  document.querySelectorAll('.dragging, .drop-target, .drop-possible').forEach(function (item) {
    item.classList.remove('dragging', 'drop-target', 'drop-possible');
  });
}

    function handleDragLeave(e) {
      this.classList.remove('drop-target');
    }

    function handleDrop(e) {
      e.stopPropagation();
      if (dragSrcElement === this) {
        return false;
      }
      const sourceInfo = JSON.parse(e.dataTransfer.getData('text/plain'));
      const srcFormateur = sourceInfo.formateur;
      const srcJour = sourceInfo.jour;
      const srcSeance = sourceInfo.seance;
      const targetFormateur = this.dataset.formateur;
      const targetJour = this.dataset.jour;
      const targetSeance = this.dataset.seance;
      if (srcFormateur !== targetFormateur) {
        showNotification("Déplacement non autorisé entre formateurs.", "warning");
        return false;
      }
      const sourceSession = JSON.parse(JSON.stringify(timetableData[srcFormateur][srcJour][srcSeance]));
      const targetSession = JSON.parse(JSON.stringify(timetableData[targetFormateur][targetJour][targetSeance]));
      let tempTimetable = JSON.parse(JSON.stringify(timetableData));
      tempTimetable[srcFormateur][srcJour][srcSeance] = targetSession;
      tempTimetable[targetFormateur][targetJour][targetSeance] = sourceSession;
      const sourceConflict = checkSessionConflict(srcJour, srcSeance, targetSession, tempTimetable, {formateur: srcFormateur});
      if (sourceConflict) {
          showNotification(`Déplacement impossible: ${sourceConflict}`, "chevauchement");
          return false;
      }
      const targetConflict = checkSessionConflict(targetJour, targetSeance, sourceSession, tempTimetable, {formateur: targetFormateur});
      if (targetConflict) {
          showNotification(`Déplacement impossible: ${targetConflict}`, "chevauchement");
          return false;
      }
      timetableData[srcFormateur][srcJour][srcSeance] = targetSession;
      timetableData[targetFormateur][targetJour][targetSeance] = sourceSession;
      showNotification("Session déplacée avec succès.", "success");
      renderTimetableFromData(timetableData);
      return false;
    }

    function checkSessionConflict(jour, seance, sessionToCheck, timetable, exclusion) {
        if (!sessionToCheck || !sessionToCheck.groupe) return null;
        const groupesToCheck = sessionToCheck.groupe.trim().split(/\s+/).filter(Boolean);
        const salleToCheck = sessionToCheck.salle;
        for (const formateur in timetable) {
            if (formateur === exclusion.formateur) continue;
            const otherSession = timetable[formateur][jour][seance];
            if (salleToCheck && salleToCheck !== 'TEAMS' && otherSession.salle === salleToCheck) {
                return `Conflit de salle pour "${salleToCheck}" avec le formateur ${formateur}.`;
            }
            if (otherSession.groupe) {
                const autresGroupes = otherSession.groupe.trim().split(/\s+/).filter(Boolean);
                if (groupesToCheck.some(g => autresGroupes.includes(g))) {
                    return `Conflit de groupe ("${sessionToCheck.groupe}") avec le formateur ${formateur}.`;
                }
            }
        }
        return null;
    }

    function handleDragEnd(e) {
      document.querySelectorAll('.draggable-cell').forEach(function (item) {
        item.classList.remove('dragging', 'drop-target');
      });
    }

    let clipboardConfiguration = null;
    
    function openAutoGenModal() {
        const container = document.getElementById('autoGenConstraintsContainer');

        // 1. Détection des années de formation (inchangé)
    const anneesFormation = [...new Set(appData.groupes.map(getAnneeFormation))]
        .filter(annee => annee !== 'N/A')
        .sort();

    // ========================================================================
    // == MODIFICATION 1 : Le HTML des taux n'inclut plus le conteneur principal
    // ========================================================================
    let tauxHtml = '';
    if (anneesFormation.length > 0) {
        // On retire le <div class="bulk-control-group"> qui entourait cette section
        // On ajoute un séparateur <hr> pour une meilleure lisibilité visuelle
        tauxHtml = `
            <hr style="margin: 25px 0 20px 0; border-color: #d8e2f3;">
            <h4 style="margin-top:0;"><i class="fas fa-percentage"></i> Répartition par Niveau</h4>
            <div id="tauxContainer" style="display: flex; flex-direction: column; gap: 10px;">
                ${anneesFormation.map(annee => `
                    <div class="control-row" style="align-items: center;">
                        <label for="taux-${annee}" style="min-width: 40px;">${annee} :</label>
                        <input type="number" id="taux-${annee}" class="bulk-input taux-input" min="0" max="100" value="${annee === '1A' ? 100 : 0}" data-annee="${annee}">
                        <span style="font-weight: bold;">%</span>
                    </div>
                `).join('')}
            </div>
            <div id="tauxTotal" style="margin-top: 15px; text-align: right; font-weight: bold; font-size: 1.1rem; transition: color 0.3s;">
                Total : <span id="tauxTotalValue">100</span>%
            </div>
        `;
    }
        
        const bulkEditPanelHTML = `
            <div id="bulkEditPanel" style="padding: 15px; background-color: #f0f4ff; border-radius: 8px; margin-bottom: 20px;">

              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #d8e2f3;">
                <div id="bulkSelectionInfo" style="font-weight: 500; color: #333;">Aucun formateur sélectionné.</div>
                <button id="invertSelectionBtn" class="btn-bulk-apply" style="background: #6c757d; color: white;">Inverser la sélection</button>
            </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                    
                    <!-- Colonne de gauche: Heures, TEAMS, Espaces -->
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <label><strong>Heures/Semaine :</strong></label>
                            <div style="display: flex; gap: 5px;"><input type="number" id="bulkHours" value="25" style="width: 80px;"><button data-action="apply-hours" class="btn-bulk-apply">Appliquer</button></div>
                        </div>
                        <div>
                            <label><strong>Sessions TEAMS :</strong></label>
                            <div style="display: flex; gap: 5px;"><input type="number" id="bulkTeams" value="0" style="width: 80px;"><button data-action="apply-teams" class="btn-bulk-apply">Appliquer</button></div>
                        </div>
                        <div>
                            <label><strong>Gérer les Espaces :</strong></label>
                            <div style="display: flex; gap: 5px;">
                                <select id="bulkSpaceSelect" style="flex: 1;">${appData.espaces.map(e => `<option value="${e}">${e}</option>`).join('')}</select>
                                <button data-action="add-space" class="btn-bulk-apply">Ajouter</button>
                                <button data-action="remove-space" class="btn-bulk-apply remove">Retirer</button>
                            </div>
                        </div>

                         ${tauxHtml}
                    </div>

                    <!-- Colonne de droite: Grille de sélection des indisponibilités -->
                    <div>
                        <label><strong>Gérer les Indisponibilités (cliquez-glissez pour sélectionner)</strong></label>
                        <div style="display: flex; gap: 10px; margin-top: 5px;">
                            <!-- === GRILLE DE SÉLECTION INVERSÉE === -->
                            <table id="bulkAvailabilityGrid" class="availability-grid-style">
                                <thead>
                                    <tr>
                                        <th></th> <!-- Coin vide -->
                                        ${seances.map(s => `<th>${s}</th>`).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${jours.map(j => `
                                        <tr>
                                            <th>${j}</th>
                                            ${seances.map(s => `<td class="bulk-slot" data-jour="${j}" data-seance="${s}"></td>`).join('')}
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                            <div style="display: flex; flex-direction: column; gap: 5px; justify-content: center;">
                                <button data-action="block-availability" class="btn-bulk-apply block">Bloquer</button>
                                <button data-action="unblock-availability" class="btn-bulk-apply unblock">Débloquer</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <style>
                #autoGenModal {
                    display: none;
                    position: fixed;
                    z-index: 1050;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgba(0,0,0,0.5);
                }

                .modal-container {
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 30px;
                    border-radius: 12px;
                    box-shadow: 0 5px 30px rgba(0, 0, 0, 0.3);
                    width: 90%;
                    max-width: 1200px;
                    position: relative;
                    max-height: 85vh;
                    overflow-y: auto;
                    border: none;
                }

                .modal-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border-bottom: 1px solid #eaeaea;
                    padding-bottom: 15px;
                    margin-bottom: 20px;
                }

                .modal-title {
                    font-size: 1.8rem;
                    color: #2c3e50;
                    font-weight: 600;
                }

                .close-modal {
                    background: none;
                    border: none;
                    font-size: 1.8rem;
                    cursor: pointer;
                    color: #7f8c8d;
                    transition: color 0.2s;
                    width: 40px;
                    height: 40px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .close-modal:hover {
                    background-color: #f5f5f5;
                    color: #e74c3c;
                }

                /* Configuration de masse */
                .bulk-config-section {
                    background-color: #f8faff;
                    border-radius: 10px;
                    padding: 20px;
                    margin-bottom: 25px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
                }

                .section-title {
                    font-size: 1.4rem;
                    color: #3498db;
                    margin-bottom: 20px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }

                .section-title i {
                    font-size: 1.2rem;
                }

                .bulk-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                    gap: 25px;
                }

                .bulk-control-group {
                    background: white;
                    padding: 15px;
                    border-radius: 8px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                }

                .bulk-control-group h4 {
                    margin-top: 0;
                    margin-bottom: 15px;
                    color: #2c3e50;
                    font-size: 1.1rem;
                }

                .control-row {
                    display: flex;
                    gap: 10px;
                    margin-bottom: 10px;
                    align-items: center;
                }

                .control-row label {
                    min-width: 120px;
                    font-weight: 500;
                }

                .bulk-input {
                    flex: 1;
                    padding: 10px;
                    border: 1px solid #ddd;
                    border-radius: 6px;
                    font-size: 1rem;
                    transition: border-color 0.3s;
                }

                .bulk-input:focus {
                    border-color: #3498db;
                    outline: none;
                    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
                }

                .btn-bulk-apply {
                    padding: 10px 15px;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                }

                .btn-bulk-apply i {
                    font-size: 0.9rem;
                }

                .btn-bulk-apply.primary {
                    background: linear-gradient(to right, #3498db, #2980b9);
                    color: white;
                }

                .btn-bulk-apply.remove {
                    background: linear-gradient(to right, #e74c3c, #c0392b);
                    color: white;
                }

                .btn-bulk-apply.block {
                    background: linear-gradient(to right, #c0392b, #a93226);
                    color: white;
                    width: 100px;
                }

                .btn-bulk-apply.unblock {
                    background: linear-gradient(to right, #27ae60, #219d54);
                    color: white;
                    width: 100px;
                }

                .btn-bulk-apply:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                    opacity: 0.9;
                }

                /* Tableau de sélection en masse */
                .bulk-availability-container {
                    margin-top: 10px;
                }

                .availability-grid-style {
                    border-collapse: collapse;
                    width: 100%;
                    user-select: none;
                }

                .availability-grid-style th {
                    background-color: #f2f6fc;
                    padding: 6px;
                    font-size: 0.85rem;
                    font-weight: 600;
                    color: #2c3e50;
                    border: 1px solid #e0e0e0;
                }

                .availability-grid-style td {
                    border: 1px solid #e0e0e0;
                    text-align: center;
                    padding: 0;
                    background-color: white;
                    transition: background-color 0.2s;
                }

                #bulkAvailabilityGrid th {
                    padding: 10px 8px;
                }
                
                #bulkEditPanel {
                    /* Style for the panel which is now outside the scroll container */
                    margin-bottom: 15px;
                }

                .constraints-table thead {
                    position: sticky;
                    top: 0; /* Stick to the top of the scrollable container */
                    z-index: 10;
                    background-color: #f8faff; /* Hide content scrolling underneath */
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                }

                #bulkAvailabilityGrid td {
                    width: 50px;
                    height: 20px;
                    cursor: pointer;
                    position: relative;
                }

                #bulkAvailabilityGrid td:after {
                    content: "";
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 20px;
                    height: 20px;
                    border-radius: 4px;
                    background: #e3f2fd;
                    transform: translate(-50%, -50%);
                    transition: all 0.2s;
                }

                #bulkAvailabilityGrid td.selected:after {
                    background: #3498db;
                    width: 24px;
                    height: 24px;
                }

                #bulkAvailabilityGrid td:hover:after {
                    background: #bbdefb;
                }

                .formateurs-list {
                    background-color: white;
                    border-radius: 10px;
                    overflow: hidden;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
                }

                .constraints-table {
                    width: 100%;
                    border-collapse: collapse;
                    font-size: 0.95rem;
                }

                .constraints-table td {
                    padding: 12px 15px;
                    border-bottom: 1px solid #f0f0f0;
                    vertical-align: middle;
                }

                .constraints-table tr:last-child td {
                    border-bottom: none;
                }

                .constraints-table tr:hover td {
                    background-color: #f9fbfe;
                }

                .formateur-name-col {
                    font-weight: 600;
                    min-width: 150px;
                }

                .constraints-table input[type="number"] {
                    width: 80px;
                    padding: 8px;
                    border: 1px solid #ddd;
                    border-radius: 6px;
                    font-size: 1rem;
                    transition: border-color 0.3s;
                }

                .constraints-table input[type="number"]:focus {
                    border-color: #3498db;
                    outline: none;
                    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
                }

                .tags-container {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 8px;
                    padding: 5px;
                    min-height: 40px;
                }

                .space-tag {
                    background: linear-gradient(to right, #3498db, #2980b9);
                    color: white;
                    padding: 5px 12px;
                    border-radius: 20px;
                    font-size: 0.85rem;
                    display: inline-flex;
                    align-items: center;
                    gap: 5px;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                }

                .remove-tag {
                    background: none;
                    border: none;
                    color: white;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 1rem;
                    padding: 0;
                    line-height: 1;
                    margin-left: 5px;
                    opacity: 0.7;
                    transition: opacity 0.2s;
                }

                .remove-tag:hover {
                    opacity: 1;
                }

                .mini-grid-container {
                    padding: 5px 0;
                }

                .availability-mini-grid {
                    border-collapse: collapse;
                    width: 100%;
                }

                .availability-mini-grid th {
                    padding: 3px 5px;
                    font-weight: normal;
                    font-size: 0.7rem;
                    color: #7f8c8d;
                }

                .availability-mini-grid td {
                    width: 20px;
                    height: 10px;
                    border-radius: 3px;
                    cursor: pointer;
                    background-color: #d5f5e3;
                    position: relative;
                    transition: all 0.2s;
                }

                .availability-mini-grid td:after {
                    content: "";
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 12px;
                    height: 12px;
                    border-radius: 2px;
                    background: #27ae60;
                    transform: translate(-50%, -50%);
                    transition: all 0.2s;
                }

                .availability-mini-grid td.unavailable:after {
                    background: #e74c3c;
                }

                .availability-mini-grid td:hover:after {
                    transform: translate(-50%, -50%) scale(1.2);
                }

                .modal-footer {
                    display: flex;
                    justify-content: flex-end;
                    margin-top: 25px;
                    padding-top: 20px;
                    border-top: 1px solid #eee;
                }

                #runAutoGenerateBtn {
                    padding: 12px 25px;
                    font-size: 1.1rem;
                    font-weight: 600;
                    border: none;
                    border-radius: 8px;
                    cursor: pointer;
                    background: linear-gradient(to right, #27ae60, #2ecc71);
                    color: white;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
                    transition: all 0.3s ease;
                }

                #runAutoGenerateBtn:hover {
                    transform: translateY(-3px);
                    box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);
                }

                #runAutoGenerateBtn:active {
                    transform: translateY(-1px);
                }

                .selected-row {
                    background-color: #f0f7ff !important;
                    position: relative;
                }

                .selected-row:after {
                    content: "";
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 4px;
                    height: 100%;
                    background: #3498db;
                }

                @media (max-width: 900px) {
                    .modal-container {
                        width: 95%;
                        padding: 20px;
                    }
                    
                    .bulk-grid {
                        grid-template-columns: 1fr;
                    }
                    
                    .constraints-table {
                        display: block;
                        overflow-x: auto;
                    }
                }

                @media (max-width: 600px) {
                    .control-row {
                        flex-direction: column;
                        align-items: flex-start;
                    }
                    
                    .control-row label {
                        margin-bottom: 5px;
                    }
                }

                 .bulk-grid {
                display: grid;
                /* On s'assure que la grille est bien adaptée pour 2 colonnes maintenant */
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                gap: 25px;
            }
            .taux-total-warning {
                color: #e74c3c !important;
            }
            </style>
        `;

        let tableHTML = `
            <table class="constraints-table">
                <thead>
                    <tr>
                        <th style="width: 20px;"><input type="checkbox" id="selectAllFormateurs"></th>
                        <th>Formateur</th>
                        <th>Heures/Sem.</th>
                        <th>Sessions TEAMS</th>
                        <th>Espaces Autorisés</th>
                        <th style="width: 220px;">Indisponibilités</th>
                    </tr>
                </thead>
                <tbody>`;

        appData.formateurs.forEach(formateur => {
            tableHTML += `<tr data-formateur="${formateur}">
                <td><input type="checkbox" class="formateur-select-checkbox"></td>
                <td class="formateur-name-col">${formateur}</td>
                <td><input type="number" class="formateur-hours" value="25"></td>
                <td><input type="number" class="formateur-teams-sessions" value="0"></td>
                <td><div class="tags-container assigned-spaces-container"></div></td>
                
                <td>
                    <table class="availability-grid-style availability-mini-grid">
                        
                        <tbody>
                            ${jours.map(j => `
                                <tr>
                                    <th>${j.substring(0,3)}</th>
                                    ${seances.map(s => `<td class="mini-slot" data-jour="${j}" data-seance="${s}" title="${j} ${s}"></td>`).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </td>
            </tr>`;
        });

        tableHTML += `</tbody></table>`;
        
        const modalContentWrapper = container.parentElement;

        const existingPanel = modalContentWrapper.querySelector('#bulkEditPanel');
        if (existingPanel) {
            existingPanel.remove();
        }
        
        container.insertAdjacentHTML('beforebegin', bulkEditPanelHTML);
        
        container.innerHTML = tableHTML;

        document.getElementById('autoGenModal').style.display = 'block';

        // ========================================================================
    // == AJOUT : CHARGEMENT DE LA CONFIGURATION SAUVEGARDÉE                 ==
    // ========================================================================
    try {
        const savedConfigJSON = localStorage.getItem('autoGenConfig_v1');
        if (savedConfigJSON) {
            const savedConfig = JSON.parse(savedConfigJSON);
            document.querySelectorAll('#autoGenConstraintsContainer tr[data-formateur]').forEach(row => {
                const formateur = row.dataset.formateur;
                if (savedConfig[formateur]) {
                    const config = savedConfig[formateur];
                    
                    // Appliquer les valeurs
                    row.querySelector('.formateur-hours').value = config.hours || 25;
                    row.querySelector('.formateur-teams-sessions').value = config.teamsSessions || 0;
                    
                    // Appliquer les espaces autorisés
                    const spacesContainer = row.querySelector('.assigned-spaces-container');
                    spacesContainer.innerHTML = ''; // Vider les anciens
                    if(config.spaces && Array.isArray(config.spaces)) {
                       config.spaces.forEach(space => addSpaceTag(row, space));
                    }
                    
                    // Appliquer les indisponibilités
                    if(config.unavailable && Array.isArray(config.unavailable)) {
                        config.unavailable.forEach(slot => {
                            const miniSlot = row.querySelector(`.mini-slot[data-jour="${slot.jour}"][data-seance="${slot.seance}"]`);
                            if (miniSlot) miniSlot.classList.add('unavailable');
                        });
                    }
                }
            });
            showNotification("Dernière configuration chargée.", "info");
        }
    } catch(e) {
        console.error("Erreur lors du chargement de la configuration sauvegardée:", e);
        localStorage.removeItem('autoGenConfig_v1'); // Nettoyer en cas d'erreur de parsing
    }
    // ========================================================================

        setupBulkEventListeners();
    }

    function updateSelectionInfo() {
    const infoPanel = document.getElementById('bulkSelectionInfo');
    const selectedRows = document.querySelectorAll('#autoGenConstraintsContainer tr.selected-row');
    const count = selectedRows.length;

    if (count === 0) {
        infoPanel.textContent = 'Aucun formateur sélectionné.';
    } else {
        const names = Array.from(selectedRows).map(row => row.dataset.formateur);
        let text = `<strong>${count} formateur(s) sélectionné(s) :</strong> `;
        // Pour éviter une liste trop longue, on limite l'affichage
        if (names.length > 5) {
            text += names.slice(0, 5).join(', ') + ` et ${names.length - 5} autre(s)...`;
        } else {
            text += names.join(', ');
        }
        infoPanel.innerHTML = text;
    }
}

/**
 * Détermine l'année de formation (1A, 2A, 3A) à partir du nom d'un groupe.
 * Se base sur les 3 derniers caractères du nom.
 * @param {string} groupe - Le nom du groupe (ex: "TDI101", "DEV201").
 * @returns {string} - L'année de formation ('1A', '2A', '3A') ou 'N/A' si non identifiable.
 */
 function getAnneeFormation(groupe) {
  // Vérifie si l'entrée est valide
  if (!groupe || typeof groupe !== 'string' || groupe.length < 3) {
    return 'N/A'; // Non applicable
  }

  // Extrait les 3 derniers caractères et les convertit en nombre
  const codeAnnee = parseInt(groupe.slice(-3), 10);

  // Vérifie si la conversion a réussi
  if (isNaN(codeAnnee)) {
    return 'N/A';
  }

  // Applique la logique pour déterminer l'année
  if (codeAnnee >= 100 && codeAnnee < 200) {
    return '1A';
  } else if (codeAnnee >= 200 && codeAnnee < 300) {
    return '2A';
  } else if (codeAnnee >= 300 && codeAnnee < 400) {
    return '3A';
  } else {
    return 'Autre'; // Pour les cas non prévus
  }
}

function updateTauxTotal() {
    const tauxInputs = document.querySelectorAll('.taux-input');
    let total = 0;
    tauxInputs.forEach(input => {
        total += parseFloat(input.value) || 0;
    });

    const totalValueElement = document.getElementById('tauxTotalValue');
    const totalContainerElement = document.getElementById('tauxTotal');
    
    totalValueElement.textContent = total.toFixed(0);

    if (total.toFixed(0) !== '100') {
        totalContainerElement.classList.add('taux-total-warning');
    } else {
        totalContainerElement.classList.remove('taux-total-warning');
    }
}

    /**
     * MODIFICATION de setupBulkEventListeners
     * Ajoute la logique pour gérer les étiquettes et la suppression individuelle.
     */
    /**
 * Attache tous les écouteurs d'événements pour la modale de configuration en masse.
 * Gère la sélection des formateurs, le calendrier interactif et les boutons d'action.
 */
function setupBulkEventListeners() {
  const modal = document.getElementById('autoGenModal');
    if (!modal) return;

    const container = document.getElementById('autoGenConstraintsContainer');
    const selectAllCheckbox = modal.querySelector('#selectAllFormateurs');
    const rowCheckboxes = modal.querySelectorAll('.formateur-select-checkbox');
    const bulkGrid = modal.querySelector('#bulkAvailabilityGrid');
    const bulkPanel = modal.querySelector('#bulkEditPanel');
    
    // AJOUT : Écouteur pour le bouton "Inverser la sélection"
    const invertBtn = document.getElementById('invertSelectionBtn');
    invertBtn.addEventListener('click', () => {
        rowCheckboxes.forEach(checkbox => {
            checkbox.checked = !checkbox.checked;
            // On déclenche l'événement "change" pour que la logique de surbrillance et de mise à jour s'exécute
            checkbox.dispatchEvent(new Event('change'));
        });
    });

    const tauxContainer = document.getElementById('tauxContainer');
    if (tauxContainer) {
        tauxContainer.addEventListener('input', (e) => {
            if (e.target.classList.contains('taux-input')) {
                updateTauxTotal();
            }
        });
        // On s'assure que le total est correct au chargement
        updateTauxTotal(); 
    }
    // ========================================================================


    // --- 1. GESTION DE LA SÉLECTION DES FORMATEURS (LIGNES) ---

    selectAllCheckbox.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        rowCheckboxes.forEach(checkbox => {
            checkbox.checked = isChecked;
            checkbox.closest('tr').classList.toggle('selected-row', isChecked);
        });
        updateSelectionInfo(); // MODIFICATION : Mettre à jour le compteur
    });

    rowCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            e.target.closest('tr').classList.toggle('selected-row', e.target.checked);
            const total = rowCheckboxes.length;
            const checkedCount = modal.querySelectorAll('.formateur-select-checkbox:checked').length;
            
            selectAllCheckbox.checked = (total === checkedCount);
            selectAllCheckbox.indeterminate = (checkedCount > 0 && checkedCount < total);
            
            updateSelectionInfo(); // MODIFICATION : Mettre à jour le compteur
        });
    });

    updateSelectionInfo();
    // --- 2. GESTION DU CALENDRIER INTERACTIF (SÉLECTION PAR BALAYAGE) ---

    let isDraggingOnGrid = false;

    // Quand on appuie sur le bouton de la souris
    bulkGrid.addEventListener('mousedown', e => {
        if (e.target.classList.contains('bulk-slot')) {
            isDraggingOnGrid = true;
            // Inverse l'état de la cellule cliquée (permet un simple clic)
            e.target.classList.toggle('selected');
            // Empêche la sélection de texte par défaut du navigateur
            e.preventDefault();
        }
    });

    // Quand la souris se déplace sur une autre cellule
    bulkGrid.addEventListener('mouseover', e => {
        if (isDraggingOnGrid && e.target.classList.contains('bulk-slot')) {
            // Ne fait que sélectionner, n'inverse pas (comportement standard du balayage)
            e.target.classList.add('selected');
        }
    });

    // Quand on relâche le bouton de la souris (n'importe où sur la page pour plus de robustesse)
    document.addEventListener('mouseup', () => {
        isDraggingOnGrid = false;
    });


    // --- 3. GESTION DES BOUTONS DU PANNEAU DE CONFIGURATION EN MASSE ---

    bulkPanel.addEventListener('click', e => {
        const target = e.target;
        if (!target.classList.contains('btn-bulk-apply')) return;

        const action = target.dataset.action;
        const selectedRows = modal.querySelectorAll('tr.selected-row');

        // Validation : vérifier si des formateurs sont sélectionnés
        if (selectedRows.length === 0) {
            showNotification("Veuillez sélectionner au moins un formateur.", "warning");
            return;
        }

        switch (action) {
            case 'apply-hours':
                const hours = modal.querySelector('#bulkHours').value;
                selectedRows.forEach(row => row.querySelector('.formateur-hours').value = hours);
                break;

            case 'apply-teams':
                const teams = modal.querySelector('#bulkTeams').value;
                selectedRows.forEach(row => row.querySelector('.formateur-teams-sessions').value = teams);
                break;

            case 'add-space':
                const spaceToAdd = modal.querySelector('#bulkSpaceSelect').value;
                selectedRows.forEach(row => addSpaceTag(row, spaceToAdd));
                break;

            case 'remove-space':
                const spaceToRemove = modal.querySelector('#bulkSpaceSelect').value;
                selectedRows.forEach(row => removeSpaceTag(row, spaceToRemove));
                break;

            case 'block-availability':
                applyAvailabilityChange(true); // true = bloquer
                break;

            case 'unblock-availability':
                applyAvailabilityChange(false); // false = débloquer
                break;
        }

        if (action.includes('hours') || action.includes('teams') || action.includes('space')) {
             showNotification(`${selectedRows.length} formateur(s) mis à jour.`, "success");
        }
    });


    // --- 4. GESTION DE LA SUPPRESSION INDIVIDUELLE DES TAGS ---

    // Utilise la délégation d'événements sur le conteneur principal du tableau
    container.addEventListener('click', function(e) {
        if (e.target.classList.contains('remove-tag')) {
            e.preventDefault();
            // Supprime l'étiquette parente (le tag)
            e.target.closest('.tag').remove();
        }
    });
}

function addSpaceTag(row, space) {
    const container = row.querySelector('.assigned-spaces-container');
    if (!container) return; // Sécurité

    // Vérifie si l'étiquette existe déjà pour ne pas l'ajouter en double
    const alreadyExists = container.querySelector(`.space-tag[data-space="${space}"]`);
    if (alreadyExists) {
        return; // L'espace est déjà là, on ne fait rien
    }

    // Crée le HTML pour la nouvelle étiquette
    const tagHTML = `
        <span class="tag space-tag" data-space="${space}">
            ${space}
            <button class="remove-tag">×</button>
        </span>`;
    
    // Ajoute la nouvelle étiquette à la fin du conteneur
    container.insertAdjacentHTML('beforeend', tagHTML);
}

function removeSpaceTag(row, space) {
    const container = row.querySelector('.assigned-spaces-container');
    if (!container) return; // Sécurité

    const tagToRemove = container.querySelector(`.space-tag[data-space="${space}"]`);
    if (tagToRemove) {
        tagToRemove.remove(); // Supprime l'élément du DOM
    }
}

    /**
     * Fonction générique pour appliquer une modification à toutes les lignes sélectionnées.
     * @param {function(HTMLTableRowElement): void} action - La fonction à exécuter pour chaque ligne.
     */
    function applyBulkChange(action) {
        const selectedRows = document.querySelectorAll('#autoGenConstraintsContainer tr.selected-row');
        if (selectedRows.length === 0) {
            showNotification("Veuillez sélectionner au moins un formateur.", "warning");
            return;
        }
        selectedRows.forEach(action);
        showNotification(`${selectedRows.length} formateur(s) mis à jour.`, "success");
    }

    /**
     * Gère le blocage/déblocage des créneaux en masse.
     * @param {string} selection - Le créneau sélectionné (ex: 'Lundi', 'morning', 'all').
     * @param {boolean} shouldBeChecked - True pour bloquer, false pour débloquer.
     */
     function applyAvailabilityChange(shouldBlock) {
        const modal = document.getElementById('autoGenModal');
        const selectedBulkSlots = modal.querySelectorAll('#bulkAvailabilityGrid .bulk-slot.selected');
        const selectedRows = modal.querySelectorAll('tr.selected-row');

        if (selectedRows.length === 0) {
            showNotification("Veuillez sélectionner au moins un formateur.", "warning");
            return;
        }
        if (selectedBulkSlots.length === 0) {
            showNotification("Veuillez sélectionner des créneaux dans la grille.", "warning");
            return;
        }

        selectedRows.forEach(row => {
            selectedBulkSlots.forEach(slot => {
                const { jour, seance } = slot.dataset;
                const miniSlot = row.querySelector(`.mini-slot[data-jour="${jour}"][data-seance="${seance}"]`);
                if (miniSlot) {
                    miniSlot.classList.toggle('unavailable', shouldBlock);
                }
            });
        });
        
        // Nettoyer la sélection de la grille en masse après l'opération
        selectedBulkSlots.forEach(slot => slot.classList.remove('selected'));
        
        showNotification(`${selectedRows.length} formateur(s) mis à jour.`, "success");
    }


    function addUnavailabilityTag(row, jour, seance) {
        const container = row.querySelector('.assigned-unavailabilities-container');
        const alreadyExists = container.querySelector(`.unavailability-tag[data-jour="${jour}"][data-seance="${seance}"]`);
        if (!alreadyExists) {
            const tagHTML = `<span class="tag unavailability-tag" data-jour="${jour}" data-seance="${seance}">
                                ${jour.substring(0,3)} ${seance}
                                <button class="remove-tag">×</button>
                             </span>`;
            container.insertAdjacentHTML('beforeend', tagHTML);
        }
    }

    /** Supprime une étiquette d'indisponibilité. */
    function removeUnavailabilityTag(row, jour, seance) {
        const tag = row.querySelector(`.unavailability-tag[data-jour="${jour}"][data-seance="${seance}"]`);
        if (tag) tag.remove();
    }

    function setupModalEventListeners() {
        const container = document.getElementById('autoGenConstraintsContainer');

        // Actions globales
        document.getElementById('applyAllBtn')?.addEventListener('click', applyFirstRowToAll);
        document.getElementById('resetAllBtn')?.addEventListener('click', resetAllConfigurations);
        
        // Utilisation de la délégation d'événements pour les boutons dans le tableau
        container.addEventListener('click', (e) => {
            const target = e.target;
            const row = target.closest('tr');
            if (!row) return;

            // Boutons d'action par ligne
            if (target.matches('.btn-copy-config')) copyConfig(row);
            if (target.matches('.btn-paste-config')) pasteConfig(row);
            if (target.matches('.btn-reset-config')) resetConfig(row);
            
            // Boutons de disponibilité
            if (target.matches('.availability-controls button')) {
                const action = target.dataset.action;
                if (action === 'toggle-day') {
                    toggleDayAvailability(row, target.dataset.day);
                } else if (action === 'toggle-period') {
                    togglePeriodAvailability(row, target.dataset.period);
                }
            }

            // Bouton "Tout/Rien" pour les espaces
            if(target.matches('.btn-toggle-all-spaces')) {
                const spacesContainer = row.querySelector('.spaces-checkbox-container');
                const allCheckboxes = spacesContainer.querySelectorAll('input[type="checkbox"]');
                const isAnyChecked = Array.from(allCheckboxes).some(cb => cb.checked);
                allCheckboxes.forEach(cb => cb.checked = !isAnyChecked);
            }
        });
    }

    function getConfigFromRow(row) {
        const hours = row.querySelector('.formateur-hours').value;
        const teamsSessions = row.querySelector('.formateur-teams-sessions').value;
        const spaces = Array.from(row.querySelectorAll('.space-checkbox:checked')).map(cb => cb.value);
        const unavailable = Array.from(row.querySelectorAll('.availability-checkbox:checked')).map(cb => ({
            jour: cb.dataset.jour,
            seance: cb.dataset.seance
        }));
        return { hours, teamsSessions, spaces, unavailable };
    }

    function applyConfigToRow(row, config) {
        row.querySelector('.formateur-hours').value = config.hours;
        row.querySelector('.formateur-teams-sessions').value = config.teamsSessions;
        row.querySelectorAll('.space-checkbox').forEach(cb => cb.checked = config.spaces.includes(cb.value));
        row.querySelectorAll('.availability-checkbox').forEach(cb => {
            cb.checked = config.unavailable.some(u => u.jour === cb.dataset.jour && u.seance === cb.dataset.seance);
        });
    }

    function copyConfig(row) {
        clipboardConfiguration = getConfigFromRow(row);
        showNotification(`Configuration de ${row.dataset.formateur} copiée.`, 'info');
    }

    function pasteConfig(row) {
        if (clipboardConfiguration) {
            applyConfigToRow(row, clipboardConfiguration);
            showNotification(`Configuration collée sur ${row.dataset.formateur}.`, 'success');
        } else {
            showNotification('Aucune configuration dans le presse-papiers.', 'warning');
        }
    }

    function resetConfig(row) {
        const defaultConfig = {
            hours: 25,
            teamsSessions: 0,
            spaces: [],
            unavailable: []
        };
        applyConfigToRow(row, defaultConfig);
    }
    
    function applyFirstRowToAll() {
        const allRows = document.querySelectorAll('#autoGenConstraintsContainer tbody tr');
        if (allRows.length < 2) return;
        const firstRowConfig = getConfigFromRow(allRows[0]);
        if (confirm(`Voulez-vous vraiment appliquer la configuration de ${allRows[0].dataset.formateur} à tous les autres ?`)) {
            allRows.forEach((row, index) => {
                if (index > 0) applyConfigToRow(row, firstRowConfig);
            });
            showNotification('Configuration appliquée à tous les formateurs.', 'success');
        }
    }

    function resetAllConfigurations() {
        if (confirm("Êtes-vous sûr de vouloir réinitialiser toutes les configurations ?")) {
            document.querySelectorAll('#autoGenConstraintsContainer tbody tr').forEach(resetConfig);
            showNotification('Toutes les configurations ont été réinitialisées.', 'info');
        }
    }

    function toggleDayAvailability(row, day) {
        const checkboxes = row.querySelectorAll('.availability-checkbox' + (day === 'all' ? '' : `[data-jour="${day}"]`));
        const isAnyChecked = Array.from(checkboxes).some(cb => cb.checked);
        checkboxes.forEach(cb => cb.checked = !isAnyChecked);
    }

    function togglePeriodAvailability(row, period) {
        const seancesToToggle = period === 'morning' ? ['S1', 'S2'] : ['S3', 'S4'];
        const checkboxes = Array.from(row.querySelectorAll('.availability-checkbox'))
            .filter(cb => seancesToToggle.includes(cb.dataset.seance));
        const isAnyChecked = checkboxes.some(cb => cb.checked);
        checkboxes.forEach(cb => cb.checked = !isAnyChecked);
    }

    function isSlotValidForSingle(task, slot, trackers, constraints) {
        const { jour, seance } = slot;
        const formateur = task.formateur;
        const formateurConstraints = constraints[formateur];
        if (trackers.formateurSlots[`${jour}-${seance}-${formateur}`]) return false;
        if (isGroupBusy(jour, seance, task.groupe, trackers)) return false;
        if (formateurConstraints.unavailable.some(u => u.jour === jour && u.seance === seance)) return false;
        if (trackers.formateurHours[formateur] >= formateurConstraints.hours) return false;
        const allowedSpaces = formateurConstraints.spaces;
        let spaceFound = false;
        for (const space of allowedSpaces) {
            if (task.type === 'synchrone') {
                if (space === 'TEAMS' && trackers.formateurTeamsCount[formateur] < formateurConstraints.teamsSessions) {
                    spaceFound = true; break;
                }
            } else {
                if (space !== 'TEAMS' && !trackers.roomSlots[`${jour}-${seance}-${space}`]) {
                    spaceFound = true; break;
                }
            }
        }
        return spaceFound;
    }

    function findBestSlotForSingle(task, newTimetableData, trackers, constraints) {
        let bestSlot = null;
        let highestScore = -1;
        const formateur = task.formateur;
        const formateurSchedule = newTimetableData[formateur];
        for (const jour of jours) {
            for (const seance of seances) {
                const currentSlot = { jour, seance };
                if (!isSlotValidForSingle(task, currentSlot, trackers, constraints)) {
                    continue;
                }
                let score = 1;
                const seanceIndex = seances.indexOf(seance);
                const hasWorkOnDay = seances.some(s => formateurSchedule[jour][s].groupe);
                if (hasWorkOnDay) {
                    score += 10;
                }
                if (seanceIndex > 0 && formateurSchedule[jour][seances[seanceIndex - 1]].groupe) {
                    score += 50;
                }
                if (seanceIndex < seances.length - 1 && formateurSchedule[jour][seances[seanceIndex + 1]].groupe) {
                    score += 50;
                }
                if (seance === 'S3' && formateurSchedule[jour]['S1'].groupe && !formateurSchedule[jour]['S2'].groupe) {
                    score -= 40;
                }
                if (seance === 'S4' && formateurSchedule[jour]['S2'].groupe && !formateurSchedule[jour]['S3'].groupe) {
                    score -= 40;
                }
                if (score > highestScore) {
                    highestScore = score;
                    bestSlot = currentSlot;
                }
            }
        }
        return bestSlot;
    }

    function tryPlaceSingle(task, slot, newTimetableData, trackers, constraints) {
        const { jour, seance } = slot;
        const formateur = task.formateur;
        const formateurConstraints = constraints[formateur];
        let availableSpace = null;
        const allowedSpaces = [...formateurConstraints.spaces].sort(() => Math.random() - 0.5);
        for (const space of allowedSpaces) {
            if (task.type === 'synchrone') {
                if (space === 'TEAMS' && trackers.formateurTeamsCount[formateur] < formateurConstraints.teamsSessions) {
                    availableSpace = space; break;
                }
            } else {
                if (space !== 'TEAMS' && !trackers.roomSlots[`${jour}-${seance}-${space}`]) {
                    availableSpace = space; break;
                }
            }
        }
        if (availableSpace) {
            newTimetableData[formateur][jour][seance] = { groupe: task.groupe, module: task.module, salle: availableSpace };
            trackers.formateurHours[formateur] += SEANCE_DURATION;
            trackers.formateurSlots[`${jour}-${seance}-${formateur}`] = true;
            task.groupe.trim().split(/\s+/).forEach(g => trackers.groupSlots[`${jour}-${seance}-${g}`] = true);
            if (availableSpace === 'TEAMS') {
                trackers.formateurTeamsCount[formateur]++;
            } else {
                trackers.roomSlots[`${jour}-${seance}-${availableSpace}`] = true;
            }
            return true;
        }
        return false;
    }
    
    function findBestSlotForBlock(task, newTimetableData, trackers, constraints) {
        let bestSlot = null;
        let highestScore = -1;
        const formateur = task.formateur;
        const formateurSchedule = newTimetableData[formateur];
        const formateurConstraints = constraints[formateur];
        const pairs = [['S1', 'S2'], ['S3', 'S4']];
        for (const jour of jours) {
            for (const pair of pairs) {
                const [s1, s2] = pair;
                const isUnavailable = formateurConstraints.unavailable.some(u => u.jour === jour && (u.seance === s1 || u.seance === s2));
                if (isUnavailable) continue;
                if (trackers.formateurSlots[`${jour}-${s1}-${formateur}`] || trackers.formateurSlots[`${jour}-${s2}-${formateur}`]) continue;
                if (isGroupBusy(jour, s1, task.groupe, trackers) || isGroupBusy(jour, s2, task.groupe, trackers)) continue;
                if (trackers.formateurHours[formateur] + (SEANCE_DURATION * 2) > formateurConstraints.hours) continue;
                let spaceFound = false;
                for (const space of formateurConstraints.spaces) {
                     if (task.type === 'synchrone') {
                        if (space === 'TEAMS' && trackers.formateurTeamsCount[formateur] < formateurConstraints.teamsSessions) {
                            spaceFound = true; break;
                        }
                    } else {
                        if (space !== 'TEAMS' && !trackers.roomSlots[`${jour}-${s1}-${space}`] && !trackers.roomSlots[`${jour}-${s2}-${space}`]) {
                            spaceFound = true; break;
                        }
                    }
                }
                if (!spaceFound) continue;
                let score = 1;
                 if (formateurSchedule[jour]['S1'].groupe || formateurSchedule[jour]['S2'].groupe || formateurSchedule[jour]['S3'].groupe || formateurSchedule[jour]['S4'].groupe) {
                    score += 10;
                } else {
                    score += 5;
                }
                if (score > highestScore) {
                    highestScore = score;
                    bestSlot = { jour, pair };
                }
            }
        }
        return bestSlot;
    }
    
    function tryPlaceBlock(task, slot, newTimetableData, trackers, constraints) {
        const { jour, pair } = slot;
        const [s1, s2] = pair;
        const formateur = task.formateur;
        const formateurConstraints = constraints[formateur];
        let availableSpace = null;
        for (const space of formateurConstraints.spaces) {
             if (task.type === 'synchrone') {
                if (space === 'TEAMS' && trackers.formateurTeamsCount[formateur] < formateurConstraints.teamsSessions) {
                    availableSpace = space; break;
                }
            } else {
                if (space !== 'TEAMS' && !trackers.roomSlots[`${jour}-${s1}-${space}`] && !trackers.roomSlots[`${jour}-${s2}-${space}`]) {
                    availableSpace = space; break;
                }
            }
        }
        if (availableSpace) {
            const sessionData = { groupe: task.groupe, module: task.module, salle: availableSpace };
            newTimetableData[formateur][jour][s1] = sessionData;
            newTimetableData[formateur][jour][s2] = sessionData;
            [s1, s2].forEach(seance => {
                trackers.formateurSlots[`${jour}-${seance}-${formateur}`] = true;
                task.groupe.trim().split(/\s+/).forEach(g => trackers.groupSlots[`${jour}-${seance}-${g}`] = true);
                if (availableSpace !== 'TEAMS') {
                    trackers.roomSlots[`${jour}-${seance}-${availableSpace}`] = true;
                }
            });
            trackers.formateurHours[formateur] += (SEANCE_DURATION * 2);
            if (availableSpace === 'TEAMS') trackers.formateurTeamsCount[formateur]++;
            return true;
        }
        return false;
    }

    function createSchedulableUnits(affectations) {
        const taskMap = new Map();
        affectations.forEach(task => {
            const key = `${task.formateur}|${task.groupe}|${task.module}|${task.type}`;
            if (!taskMap.has(key)) {
                taskMap.set(key, { ...task, count: 0 });
            }
            taskMap.get(key).count++;
        });
        const fiveHourBlockTasks = [];
        const twoPointFiveHourTasks = [];
        taskMap.forEach(task => {
            const fiveHourBlocks = Math.floor(task.count / 2);
            const remainingSingles = task.count % 2;
            if (fiveHourBlocks > 0) fiveHourBlockTasks.push({ ...task, blocksToPlace: fiveHourBlocks });
            if (remainingSingles > 0) twoPointFiveHourTasks.push(task);
        });
        return { fiveHourBlockTasks, twoPointFiveHourTasks };
    }

    function prioritizeTasks(tasks, constraints) {
        const getDifficultyScore = (task) => {
            if (!task || !task.formateur) {
              console.error("Tâche invalide lors du calcul de difficulté :", task);
              return 0; 
            }
            const formateurConstraints = constraints[task.formateur];
            if (!formateurConstraints) return 0;
            const availableSlots = (jours.length * seances.length) - formateurConstraints.unavailable.length;
            return (formateurConstraints.hours / (availableSlots || 1)) * 10;
        };
        return tasks.sort((a, b) => getDifficultyScore(b) - getDifficultyScore(a));
    }

    function isGroupBusy(jour, seance, groupe, trackers) {
        const subGroups = groupe.trim().split(/\s+/).filter(g => g);
        return subGroups.some(subGroup => trackers.groupSlots[`${jour}-${seance}-${subGroup}`]);
    }
    
    /**
 * Fonction principale pour lancer la génération automatique de l'emploi du temps.
 * Extrait toutes les contraintes de l'interface, y compris la répartition par niveau,
 * puis lance un algorithme pondéré pour créer et afficher le nouvel emploi du temps.
 */
async function runAutoGeneration() {
    console.log("Lancement de la génération automatique...");
    document.getElementById('weekLoader').style.display = 'flex';
    
    // --- ÉTAPE 1 : EXTRACTION ET VALIDATION DES CONTRAINTES DEPUIS L'INTERFACE ---

    // Extraction des contraintes par formateur
    autoGenConstraints = {};
    document.querySelectorAll('#autoGenConstraintsContainer tr[data-formateur]').forEach(row => {
        const formateur = row.dataset.formateur;
        const assignedSpaces = Array.from(row.querySelectorAll('.space-tag')).map(tag => tag.dataset.space);
        const unavailableSlots = Array.from(row.querySelectorAll('.availability-mini-grid .mini-slot.unavailable'))
            .map(slot => ({ jour: slot.dataset.jour, seance: slot.dataset.seance }));

        autoGenConstraints[formateur] = {
            hours: parseFloat(row.querySelector('.formateur-hours').value) || 0,
            teamsSessions: parseInt(row.querySelector('.formateur-teams-sessions').value, 10) || 0,
            spaces: assignedSpaces,
            unavailable: unavailableSlots
        };
    });

    // Extraction des pourcentages de répartition par niveau
    const tauxAnnees = {};
    const tauxInputs = document.querySelectorAll('.taux-input');
    let totalTaux = 0;
    tauxInputs.forEach(input => {
        const annee = input.dataset.annee;
        const taux = parseFloat(input.value) || 0;
        tauxAnnees[annee] = taux;
        totalTaux += taux;
    });

    // Validation cruciale : le total des taux doit être 100%
    if (Math.round(totalTaux) !== 100) {
        showNotification("Erreur : La somme des pourcentages de répartition par niveau doit être égale à 100%.", "error");
        document.getElementById('weekLoader').style.display = 'none';
        return; // Arrêt de la fonction
    }

    // Sauvegarde de la configuration complète pour une utilisation future
    try {
        const configToSave = {
            constraints: autoGenConstraints,
            rates: tauxAnnees
        };
        // On utilise une clé versionnée pour faciliter les migrations futures
        localStorage.setItem('autoGenConfig_v2', JSON.stringify(configToSave));
        console.log("Configuration de la génération auto sauvegardée.");
    } catch (e) {
        console.error("Erreur lors de la sauvegarde de la configuration:", e);
    }
    
    // Utiliser un setTimeout permet à l'interface (le loader) de se rafraîchir avant le calcul intensif
    setTimeout(() => {
        try {
            // --- ÉTAPE 2 : INITIALISATION DES DONNÉES POUR LA GÉNÉRATION ---
            
            let newTimetableData = {};
            let trackers = { formateurHours: {}, formateurTeamsCount: {}, roomSlots: {}, groupSlots: {}, formateurSlots: {} };

            appData.formateurs.forEach(f => {
                newTimetableData[f] = {};
                trackers.formateurHours[f] = 0;
                trackers.formateurTeamsCount[f] = 0;
                jours.forEach(j => {
                    newTimetableData[f][j] = {};
                    seances.forEach(s => newTimetableData[f][j][s] = { groupe: '', module: '', salle: '' });
                });
            });

            // Préparation des tâches en y ajoutant leur année de formation
            const affectationsAvecAnnee = appData.affectations.map(aff => ({
                ...aff,
                anneeFormation: getAnneeFormation(aff.groupe)
            }));

            let { fiveHourBlockTasks, twoPointFiveHourTasks } = createSchedulableUnits(affectationsAvecAnnee);
            fiveHourBlockTasks.forEach(t => t.anneeFormation = getAnneeFormation(t.groupe));
            twoPointFiveHourTasks.forEach(t => t.anneeFormation = getAnneeFormation(t.groupe));

            const allTasks = [...fiveHourBlockTasks, ...twoPointFiveHourTasks];
            const tasksToProcess = [...allTasks]; // Copie de la liste des tâches à placer
            let unplacedTasksLog = [];

            // Création des seuils de probabilité pour la sélection pondérée
            const seuilsProbabilite = [];
            let cumul = 0;
            for (const annee in tauxAnnees) {
                if (tauxAnnees[annee] > 0) {
                    cumul += tauxAnnees[annee] / 100;
                    seuilsProbabilite.push({ annee: annee, seuil: cumul });
                }
            }

            // --- ÉTAPE 3 : ALGORITHME PRINCIPAL DE PLACEMENT DES TÂCHES ---
            
            while (tasksToProcess.length > 0) {
                // 1. Choisir une année de formation selon les pourcentages
                const rand = Math.random();
                let anneeChoisie = seuilsProbabilite.length > 0 ? seuilsProbabilite[seuilsProbabilite.length - 1].annee : 'N/A';
                for (const item of seuilsProbabilite) {
                    if (rand < item.seuil) {
                        anneeChoisie = item.annee;
                        break;
                    }
                }

                // 2. Trouver une tâche correspondant à l'année choisie
                let taskIndex = tasksToProcess.findIndex(t => t.anneeFormation === anneeChoisie);

                // Fallback : si plus aucune tâche de l'année choisie n'est disponible, on en prend une autre
                if (taskIndex === -1) {
                    taskIndex = 0;
                }

                const task = tasksToProcess.splice(taskIndex, 1)[0];
                
                // 3. Essayer de placer la tâche
                let placed = false;
                if (task.hasOwnProperty('blocksToPlace')) { // Cas d'un bloc de 5h
                    const bestSlot = findBestSlotForBlock(task, newTimetableData, trackers, autoGenConstraints);
                    if (bestSlot) {
                        placed = tryPlaceBlock(task, bestSlot, newTimetableData, trackers, autoGenConstraints);
                    }
                } else { // Cas d'une séance de 2.5h
                    const bestSlot = findBestSlotForSingle(task, newTimetableData, trackers, autoGenConstraints);
                    if (bestSlot) {
                        placed = tryPlaceSingle(task, bestSlot, newTimetableData, trackers, autoGenConstraints);
                    }
                }

                // 4. Si non placée, on la journalise
                if (!placed) {
                    unplacedTasksLog.push(task);
                }
            }
            
            // --- ÉTAPE 4 : FINALISATION ET AFFICHAGE DES RÉSULTATS ---
            
            renderTimetableFromData(newTimetableData);
            document.getElementById('autoGenModal').style.display = 'none';
            document.getElementById('weekLoader').style.display = 'none';
            
            const totalPlaced = allTasks.length - unplacedTasksLog.length;
            let report = `Génération terminée. ${totalPlaced} séances sur ${allTasks.length} ont été placées.`;
            
            if (unplacedTasksLog.length > 0) {
                report += ` (${unplacedTasksLog.length} non placées)`;
            }

            console.warn("Tâches non placées:", unplacedTasksLog);
            showNotification(report, unplacedTasksLog.length > 0 ? 'warning' : 'success');

        } catch (error) {
            console.error("Erreur critique lors de la génération automatique:", error);
            showNotification(`Une erreur est survenue: ${error.message}`, 'error');
            document.getElementById('weekLoader').style.display = 'none';
        }
    }, 100);
}

    function setupVoiceAssistant() {
        if (!SpeechRecognition) {
            voiceAssistantBtn.style.display = 'none';
            console.warn("L'API Web Speech n'est pas supportée par ce navigateur.");
            return;
        }
        voiceAssistantBtn.addEventListener('click', toggleListening);
        recognition.onresult = (event) => {
            const transcript = event.results[event.results.length - 1][0].transcript.trim();
            updateStatus(`J'ai entendu : "${transcript}"`);
            processCommand(transcript);
        };
        recognition.onerror = (event) => {
            console.error("Erreur de reconnaissance vocale:", event.error);
            updateStatus("Désolé, je n'ai pas compris.", 3000, true);
            stopListening();
        };
        recognition.onend = () => {
            stopListening();
        };
    }
    
    function toggleListening() {
        if (voiceAssistantBtn.classList.contains('listening')) {
            recognition.stop();
        } else {
            startListening();
        }
    }

    // NOUVELLE VERSION ADAPTÉE AU BOUTON CIRCULAIRE
function startListening() {
    voiceAssistantBtn.classList.add('listening');
    // On change juste la classe de l'icône existante
    voiceAssistantBtn.querySelector('span i').className = 'fas fa-wave-square';
    updateStatus("Je vous écoute...", 0);
    recognition.start();
}

function stopListening() {
    voiceAssistantBtn.classList.remove('listening');
    // On remet la classe de l'icône par défaut
    voiceAssistantBtn.querySelector('span i').className = 'fas fa-microphone';
    setTimeout(() => assistantStatus.classList.remove('visible'), 500);
}

    function updateStatus(message, duration = 2000, isError = false) {
        assistantStatus.textContent = message;
        assistantStatus.style.backgroundColor = isError ? '#e74c3c' : 'rgba(0, 0, 0, 0.75)';
        assistantStatus.classList.add('visible');
        if (duration > 0) {
            setTimeout(() => {
                assistantStatus.classList.remove('visible');
            }, duration);
        }
    }
    
    function speak(text) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'fr-FR';
        utterance.rate = 1.1;
        speechSynthesis.cancel();
        speechSynthesis.speak(utterance);
    }

    let conversationContext = null;
    async function processCommand(command) {
        const GEMINI_API_KEY = 'AIzaSyCtvJkZ0xp7eSEIVVThjiYQ9HsK84ca_bU';
        if (GEMINI_API_KEY.includes('VOTRE_CLE')) {
            const errorMsg = "Erreur : La clé API Gemini n'a pas été configurée dans le code.";
            speak(errorMsg);
            updateStatus(errorMsg, 4000, true);
            console.error(errorMsg);
            return;
        }
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
        updateStatus('Réflexion en cours...', 0);
        if (conversationContext && conversationContext.action === 'confirm_generation') {
            if (command.toLowerCase().match(/oui|lance|vas-y|confirme|ok|d'accord/)) {
                speak("Parfait, je lance la génération immédiatement.");
                openAutoGenModal();
                setTimeout(() => document.getElementById('runAutoGenerateBtn').click(), 500);
                conversationContext = null;
                return;
            } else {
                speak("D'accord, la génération automatique est annulée.");
                conversationContext = null;
                return;
            }
        }
        const currentFormateurs = appData.formateurs.map(f => f.toUpperCase());
        const formateursListString = currentFormateurs.length > 0 
            ? `Voici la liste des formateurs valides que tu dois utiliser : ${currentFormateurs.join(', ')}.` 
            : "Aucun formateur n'est chargé pour le moment.";
        const system_prompt = `
            Tu es un assistant IA pour une application de gestion d'emplois du temps. ${formateursListString}
            Ton rôle est de convertir la requête de l'utilisateur en un objet JSON structuré et de fournir une réponse textuelle pour initier un dialogue si nécessaire.
            Intents possibles : 'afficher_edt', 'enregistrer_edt', 'generer_edt', 'definir_contrainte', 'naviguer_page', 'effacer_edt', 'inconnue'.
            Le format de ta réponse DOIT être UNIQUEMENT un objet JSON.
            Format JSON :
            {
              "intent": "nom_de_l_intention",
              "parameters": {
                "semaine": null,
                "page": null, // 'accueil', 'edition', 'avancement', 'espaces'
                "formateur": null, // DOIT être un nom de la liste fournie.
                "type_contrainte": null, // 'heures' ou 'indisponibilite'
                "valeur": null
              },
              "response": "phrase de réponse naturelle pour l'utilisateur."
            }
            Exemples :
            - Utilisateur: "Va sur la page d'avancement" -> JSON: { "intent": "naviguer_page", "parameters": {"page": "avancement"}, "response": "J'ouvre la page d'avancement." }
            - Utilisateur: "Lance la génération automatique" -> JSON: { "intent": "generer_edt", "parameters": {}, "response": "Je peux lancer la génération. Dois-je vous confirmer les contraintes actuelles avant ?" }
            - Utilisateur: "Pour MARTIN, mets 30 heures" -> JSON: { "intent": "definir_contrainte", "parameters": {"formateur": "MARTIN", "type_contrainte": "heures", "valeur": 30}, "response": "Contrainte mise à jour pour Martin : 30 heures." }
            Maintenant, analyse la requête suivante : "${command}"
        `;
        try {
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: system_prompt }] }] }),
            });
            if (!response.ok) throw new Error('Réponse de l\'API Google non valide.');
            const data = await response.json();
            const rawTextResponse = data.candidates[0].content.parts[0].text;
            const jsonText = rawTextResponse.replace(/```json/g, '').replace(/```/g, '').trim();
            const result = JSON.parse(jsonText);
            speak(result.response);
            switch (result.intent) {
                case 'afficher_edt':
                    const weekNumber = result.parameters.semaine;
                    if (weekNumber) {
                        // Logique pour trouver la date correspondant au numéro de semaine scolaire
                        const schoolYear = getSchoolYear(new Date());
                        let firstMonday = getWeekInfo(new Date(schoolYear, 8, 1)).startOfWeek;
                        let targetDate = new Date(firstMonday);
                        targetDate.setDate(firstMonday.getDate() + (weekNumber) * 7);
                        updateWeekSelection(targetDate);
                    }
                    break;
                case 'enregistrer_edt':
                    saveTimetable();
                    break;
                case 'effacer_edt':
                    resetTimetable();
                    break;
                case 'generer_edt':
                    handleGenerationCommand();
                    break;
                case 'definir_contrainte':
                    handleConstraintCommand(result.parameters);
                    break;
                case 'naviguer_page':
                    const page = result.parameters.page;
                    const pageMap = {
                        'accueil': 'admin.html',
                        'edition': 'edition.html',
                        'avancement': 'avancement.html',
                        'espaces': 'espaces.html'
                    };
                    if (page && pageMap[page]) {
                        window.location.href = pageMap[page];
                    }
                    break;
                default:
                    console.log("Intent non reconnu par l'IA.");
                    break;
            }
        } catch (error) {
            console.error("Erreur de communication avec l'API Gemini:", error);
            const errorMessage = "Désolé, une erreur est survenue lors de la communication avec mon intelligence.";
            speak(errorMessage);
            updateStatus(errorMessage, 4000, true);
        }
    }

    function handleGenerationCommand() {
        openAutoGenModal();
        setTimeout(() => {
            let constraintsSummary = "Je suis prêt à lancer la génération. ";
            const constraintRows = document.querySelectorAll('#autoGenConstraintsContainer tr[data-formateur]');
            if (constraintRows.length > 0) {
                const firstRow = constraintRows[0];
                const formateur = firstRow.dataset.formateur;
                const heures = firstRow.querySelector('.formateur-hours').value;
                constraintsSummary += `À titre d'exemple, pour ${formateur}, le maximum est de ${heures} heures. Dois-je lancer la génération avec les réglages actuels ?`;
            } else {
                constraintsSummary += "Dois-je continuer ?";
            }
            speak(constraintsSummary);
            conversationContext = {
                action: 'confirm_generation'
            };
        }, 500);
    }

    function handleConstraintCommand(params) {
        if (!params.formateur) {
            speak("Veuillez spécifier un nom de formateur valide.");
            return;
        }
        openAutoGenModal();
        setTimeout(() => {
            const formateurRow = document.querySelector(`#autoGenConstraintsContainer tr[data-formateur="${params.formateur.toUpperCase()}"]`);
            if (!formateurRow) {
                speak(`Désolé, je ne trouve pas le formateur nommé ${params.formateur}.`);
                return;
            }
            if (!params.type_contrainte) {
                formateurRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                formateurRow.style.backgroundColor = '#fff9c4';
                return;
            }
            switch (params.type_contrainte) {
                case 'heures':
                    const hoursInput = formateurRow.querySelector('.formateur-hours');
                    if (hoursInput) {
                        hoursInput.value = params.valeur;
                        hoursInput.style.backgroundColor = '#a7ffeb';
                        setTimeout(() => hoursInput.style.backgroundColor = '', 2000);
                    }
                    break;
                case 'indisponibilite':
                    const [jour, seance] = params.valeur.split(/\s+/);
                    const checkbox = formateurRow.querySelector(`input[data-jour*="${jour}"][data-seance="${seance}"]`);
                    if (checkbox) {
                        checkbox.checked = true;
                        checkbox.parentElement.style.backgroundColor = '#ffcdd2';
                        setTimeout(() => checkbox.parentElement.style.backgroundColor = '', 2000);
                    }
                    break;
            }
        }, 500);
    }

    function getOccupiedRooms(jour, seance, currentSelect) {
      const occupied = new Set();
      const allSalleSelects = document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="salle"]`);
      
      allSalleSelects.forEach(select => {
        // On vérifie les autres menus, pas celui qu'on est en train d'éditer.
        // On ne compte que les salles qui ont une valeur et qui ne sont pas "TEAMS".
        if (select !== currentSelect && select.value && select.value !== 'TEAMS') {
          occupied.add(select.value);
        }
      });
      return occupied;
    }

    /**
     * Met à jour les options d'un menu déroulant pour n'afficher que les salles disponibles.
     * @param {HTMLSelectElement} selectElement - Le menu déroulant à mettre à jour.
     */
    function updateSalleOptions(selectElement) {
      const jour = selectElement.dataset.jour;
      const seance = selectElement.dataset.seance;
      const currentValue = selectElement.value; // On sauvegarde la sélection actuelle

      // 1. Obtenir les salles déjà prises sur ce créneau
      const occupiedRooms = getOccupiedRooms(jour, seance, selectElement);

      // 2. Vider les options actuelles
      selectElement.innerHTML = '';

      // 3. Recréer les options en filtrant les salles
      const emptyOption = document.createElement('option');
      emptyOption.value = '';
      selectElement.appendChild(emptyOption); // Toujours garder une option vide

      appData.espaces.forEach(espace => {
        // Une salle est disponible si:
        // - Elle n'est pas dans la liste des salles occupées.
        // - OU, elle est la salle actuellement sélectionnée dans CE menu (pour ne pas la faire disparaître).
        if (!occupiedRooms.has(espace) || espace === currentValue) {
          const option = document.createElement('option');
          option.value = espace;
          option.textContent = espace;
          selectElement.appendChild(option);
        }
      });

      // 4. Restaurer la sélection initiale
      selectElement.value = currentValue;
    }

    /**
 * Récupère la liste de tous les groupes occupés pour un créneau donné,
 * en tenant compte des groupes fusionnés.
 * @param {string} jour - Le jour du créneau.
 * @param {string} seance - La séance du créneau.
 * @param {HTMLSelectElement} currentSelect - Le menu déroulant en cours de modification pour l'exclure de la vérification.
 * @returns {Set<string>} Un Set contenant les noms de chaque groupe individuel occupé.
 */
function getOccupiedGroups(jour, seance, currentSelect) {
    const occupied = new Set();
    const allGroupSelects = document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="groupe"]`);

    allGroupSelects.forEach(select => {
        // On ne vérifie que les autres menus déroulants, pas celui sur lequel on a cliqué.
        if (select !== currentSelect && select.value) {
            // Un champ peut contenir plusieurs groupes (ex: "G1 G2"), on les sépare.
            const subGroups = select.value.trim().split(/\s+/);
            subGroups.forEach(g => {
                if (g) occupied.add(g);
            });
        }
    });
    return occupied;
}

/**
 * Met en évidence les options de groupe non disponibles dans un menu déroulant.
 * @param {HTMLSelectElement} selectElement - Le menu déroulant de groupe à styliser.
 */
function styleGroupOptions(selectElement) {
    const jour = selectElement.dataset.jour;
    const seance = selectElement.dataset.seance;

    // 1. Obtenir les groupes déjà pris sur ce créneau.
    const occupiedGroups = getOccupiedGroups(jour, seance, selectElement);

    // 2. Parcourir chaque option du menu déroulant pour la styliser.
    for (const option of selectElement.options) {
        if (!option.value) continue; // Ignorer l'option vide

        // On vérifie si l'un des sous-groupes de l'option est dans la liste des groupes occupés.
        const optionSubGroups = option.value.trim().split(/\s+/);
        const isOccupied = optionSubGroups.some(g => occupiedGroups.has(g));

        // 3. Appliquer ou retirer le style en fonction de la disponibilité.
        if (isOccupied) {
            option.style.color = 'red';
            option.style.fontWeight = 'bold';
            option.textContent = `${option.value} (Pris)`; // Ajoute une indication textuelle
        } else {
            // Il est crucial de réinitialiser le style pour les options qui redeviennent disponibles.
            option.style.color = ''; // Couleur par défaut
            option.style.fontWeight = ''; // Poids par défaut
            option.textContent = option.value; // Texte original
        }
    }
}

// Fonction pour formater une date au format français
function formatFrenchDate(date) {
        return date.toLocaleDateString('fr-FR', { 
            day: '2-digit', 
            month: 'short'
        });
    }
    
    // Fonction pour obtenir la liste des semaines sauvegardées
    async function getSavedWeeks() {
        try {
            // CORRECTION: On appelle l'API qui liste les EDT de l'utilisateur
            const response = await fetch('../api/data/get_all_timetables.php');
            if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
            
            const savedTimetables = await response.json(); // C'est un tableau d'objets {semaine: ..., emploiDuTemps: ...}
            
            const weeks = savedTimetables.map(tt => {
                const weekInfo = parseWeekValue(tt.semaine);
                if (!weekInfo) return null;
                return {
                    value: tt.semaine,
                    label: `S${weekInfo.weekNumber}`,
                    dates: `${formatFrenchDate(weekInfo.startOfWeek)} - ${formatFrenchDate(weekInfo.endOfWeek)}`
                };
            }).filter(Boolean); // Filtrer les nuls

            weeks.sort((a, b) => b.value.localeCompare(a.value)); // Tri du plus récent au plus ancien
            return weeks;

        } catch (error) {
            console.error("Erreur lors de la récupération des semaines:", error);
            return []; 
        }
    }
    
    // Fonction pour parser la valeur de semaine
    function parseWeekValue(weekValue) {
        const [year, week] = weekValue.split('-W');
        if (!year || !week) return null;
        
        const schoolYear = parseInt(year);
        const weekNumber = parseInt(week);
        
        // Calculer la date de début de semaine
        const firstDayOfSeptember = new Date(schoolYear, 8, 1);
        let dayOfWeek = firstDayOfSeptember.getDay();
        let firstMonday = new Date(firstDayOfSeptember);
        
        if (dayOfWeek !== 1) {
            const offset = (dayOfWeek === 0) ? 1 : 8 - dayOfWeek;
            firstMonday.setDate(firstDayOfSeptember.getDate() + offset);
        }
        
        const startOfWeek = new Date(firstMonday);
        startOfWeek.setDate(firstMonday.getDate() + (weekNumber - 1) * 7);
        startOfWeek.setHours(0, 0, 0, 0);
        
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6);
        
        return {
            schoolYear: schoolYear,
            weekNumber: weekNumber,
            startOfWeek: startOfWeek,
            endOfWeek: endOfWeek
        };
    }
    
   // NOUVELLE FONCTION (asynchrone) pour afficher le menu déroulant
async function showWeekDropdown() {
    const menu = document.getElementById('weekImportMenu');
    menu.innerHTML = '<div style="padding:10px; text-align:center;">Chargement des semaines...</div>';
    menu.classList.add('show');
    
    // Attendre la réponse du serveur
    const savedWeeks = await getSavedWeeks();
    
    if (savedWeeks.length === 0) {
        menu.innerHTML = '<div style="padding:10px; text-align:center; color:#777;">Aucune semaine sauvegardée sur le serveur.</div>';
        return;
    }
    
    menu.innerHTML = '';
    
    // Filtrer pour exclure la semaine actuellement affichée
    const filteredWeeks = savedWeeks.filter(w => w.value !== currentWeekValue);
    
    if (filteredWeeks.length === 0) {
        menu.innerHTML = '<div style="padding:10px; text-align:center; color:#777;">Aucune autre semaine à importer.</div>';
        return;
    }
    
    filteredWeeks.forEach(week => {
        const weekElement = document.createElement('div');
        weekElement.className = 'week-import-item';
        // Affichage amélioré avec l'année
        const year = week.value.split('-W')[0];
        weekElement.innerHTML = `
            <div>
                <span class="week-import-label">${week.label} (${year})</span>
                <span class="week-import-dates" style="display:block; font-size:0.8em; color:#666;">${week.dates}</span>
            </div>
        `;
        weekElement.dataset.week = week.value;
        // On rend le clic asynchrone également
        weekElement.onclick = () => importWeekData(week.value);
        menu.appendChild(weekElement);
    });
}
    
    // NOUVELLE FONCTION (asynchrone) pour importer les données d'une semaine
    async function importWeekData(sourceWeekValue) {
        if (sourceWeekValue === currentWeekValue) {
            showNotification("Vous ne pouvez pas importer la semaine active sur elle-même.", "warning");
            return;
        }

        const weekInfo = parseWeekValue(sourceWeekValue);
        const sourceLabel = `S${weekInfo.weekNumber}`;
        
        if (!confirm(`Voulez-vous écraser l'emploi du temps actuel avec celui de la semaine ${sourceLabel} ?`)) return;

        const loader = document.getElementById('weekLoader');
        loader.style.display = 'flex';
        
        try {
            // CORRECTION 1: On récupère les données de la semaine source via l'API sécurisée
            const response = await fetch(`../api/data/get_timetable.php?semaine=${sourceWeekValue}`);
            const result = await response.json();

            if (!result.success) throw new Error(result.message || 'Impossible de charger la semaine source.');
            
            // Les données de l'emploi du temps importé
            const importedData = result.data;
            
            // CORRECTION 2: On met à jour la variable globale et on sauvegarde via l'API
            timetableData = importedData;
            await saveTimetable(); // On attend que la sauvegarde soit terminée
            
            // On rafraîchit l'affichage
            renderTimetableFromData(timetableData);
            showNotification(`EDT de ${sourceLabel} importé et enregistré pour la semaine actuelle !`, "success");

        } catch (error) {
            console.error("Erreur lors de l'importation:", error);
            showNotification(`Erreur d'importation: ${error.message}`, "error");
        } finally {
            loader.style.display = 'none';
            document.getElementById('weekImportMenu').classList.remove('show');
        }
    }
    
// MODIFIEZ checkSessionAndLoad pour qu'elle ressemble à ça
async function checkSessionAndLoad() {
        try {
            const response = await fetch('../api/auth/verify_session.php');
            const result = await response.json();

            if (!result.success) {
                window.location.href = 'login.html';
                return;
            }

            // Initialisation de l'interface utilisateur
            populateUserInfo(result.userData);
            setupProfileMenu();
            setupEventListeners();
            setupCustomCalendar();
            
            // Chargement des données et initialisation du calendrier
            loadInitialData(); // Cela va charger les données de base PUIS initialiser le calendrier
            
        } catch (error) {
            console.error('Session check failed:', error);
            window.location.href = 'login.html';
        }
    }

    // On remplace l'ancien listener par un appel à notre nouvelle fonction
    document.addEventListener('DOMContentLoaded', () => {
        checkSessionAndLoad();
        document.getElementById('notificationClose').addEventListener('click', () => {
            document.getElementById('notification').classList.add('hide');
        });
    });
    
    function loadInitialData() {
    fetch('../api/data/get_base_data.php')
        .then(response => response.json())
        .then(result => {
            // Log amélioré pour le débogage
            console.log("Données de base reçues du serveur:", result);

            appData = { formateurs: [], groupes: [], fusionGroupes: [], espaces: [], affectations: [] };

            if (result.success && result.data) {
                appData = result.data;

                // Vérification plus explicite
                if (!appData.formateurs || appData.formateurs.length === 0) {
                    showNotification("Fichier traité, mais aucun formateur trouvé. Vérifiez le contenu de votre fichier Excel.", "warning");
                    console.warn("La liste des formateurs est vide après le chargement des données. Assurez-vous que la feuille et la colonne sont correctement nommées dans le fichier Excel.");
                } else {
                    console.log(`${appData.formateurs.length} formateurs chargés.`);
                }
            } else {
                showNotification(result.message || 'Aucune donnée de base trouvée sur le serveur. Veuillez charger un fichier Excel.', "warning");
                console.warn(result.message || 'Aucune donnée de base trouvée.');
            }

            updateWeekSelection(new Date()); 
            generateTimetable(); 
        })
        .catch(error => {
            console.error('Erreur critique lors du chargement des données de base:', error);
            showNotification("Impossible de communiquer avec le serveur pour charger les données.", "error");
            appData = { formateurs: [], groupes: [], fusionGroupes: [], espaces: [], affectations: [] };
            generateTimetable();
        });
}


    function getInitials(name) {
        if (!name) return '--';
        const words = name.trim().split(' ');
        if (words.length === 1) return words[0].substring(0, 2).toUpperCase();
        return (words[0][0] + words[words.length - 1][0]).toUpperCase();
    }

    function populateUserInfo(userData) {
    if (!userData) return;
    
    // Remplir les initiales sur le bouton principal
    const initialsEl = document.getElementById('profile-initials');
    if (initialsEl) initialsEl.textContent = getInitials(userData.nom);
    
    // Remplir le nom complet et l'email dans l'en-tête du dropdown
    const nameEl = document.getElementById('dropdown-user-name');
    const emailEl = document.getElementById('dropdown-user-email');
    if (nameEl) nameEl.textContent = userData.nom;
    if (emailEl) emailEl.textContent = userData.email;
}

/**
 * Met en place les écouteurs pour le menu de profil.
 */
// Remplacez votre fonction setupProfileMenu par celle-ci

function setupProfileMenu() {
    const profileButton = document.getElementById('profile-button');
    const profileDropdown = document.getElementById('profile-dropdown');

    if (profileButton && profileDropdown) {
        // Ouvre/ferme le menu quand on clique sur le bouton de profil
        profileButton.addEventListener('click', (event) => {
            // Empêche le clic de se propager à la fenêtre, ce qui fermerait le menu immédiatement
            event.stopPropagation(); 
            profileDropdown.classList.toggle('show');
        });
        
        // Ferme le menu si on clique n'importe où ailleurs sur la page
        window.addEventListener('click', (event) => {
            // On vérifie que le menu est ouvert ET que le clic n'est pas à l'intérieur du menu
            if (profileDropdown.classList.contains('show') && !profileDropdown.contains(event.target)) {
                profileDropdown.classList.remove('show');
            }
        });
    }
}
    /**
 * Vérifie si un créneau (jour, séance) est disponible pour une séance donnée,
 * en vérifiant les conflits potentiels de groupe et de salle avec les autres formateurs.
 * @param {string} jour - Le jour à vérifier.
 * @param {string} seance - La séance à vérifier.
 * @param {object} sessionToCheck - La séance ({groupe, salle}) que l'on souhaite placer.
 * @param {string} excludeFormateur - Le formateur qui effectue le glisser, à exclure de la vérification.
 * @returns {boolean} - True si le créneau est disponible, false sinon.
 */
function isSlotAvailableForSession(jour, seance, sessionToCheck, excludeFormateur) {
    // Si la session à vérifier est vide, le créneau est toujours "disponible" pour elle.
    if (!sessionToCheck || !sessionToCheck.groupe) return true;

    const groupesToCheck = sessionToCheck.groupe.trim().split(/\s+/).filter(Boolean);
    const salleToCheck = sessionToCheck.salle;

    // Parcourir tous les formateurs du tableau
    for (const formateur in timetableData) {
        // On saute le formateur qui est en train de déplacer un élément
        if (formateur === excludeFormateur) continue;

        const otherSession = timetableData[formateur][jour][seance];
        if (!otherSession || !otherSession.groupe) continue; // On ignore les créneaux vides des autres

        // 1. Vérification du conflit de salle
        if (salleToCheck && salleToCheck !== 'TEAMS' && otherSession.salle === salleToCheck) {
            return false; // Conflit de salle trouvé
        }

        // 2. Vérification du conflit de groupe
        const autresGroupes = otherSession.groupe.trim().split(/\s+/).filter(Boolean);
        if (groupesToCheck.some(g => autresGroupes.includes(g))) {
            return false; // Conflit de groupe trouvé
        }
    }

    // Si on arrive ici, aucun conflit n'a été trouvé avec les autres formateurs
    return true;
}

    /**
     * Détermine le semestre d'un module en se basant sur les affectations.
     * @param {string} formateur - Le nom du formateur.
     * @param {string} groupe - Le nom du ou des groupes (ex: "G1" ou "G1 G2").
     * @param {string} module - Le nom du module.
     * @returns {string|null} - 'S1', 'S2', 'Annual', ou null si non trouvé.
     */
     function getModuleSemester(formateur, groupe, module) {
        // Si une des informations essentielles manque, on ne peut rien faire.
        if (!formateur || !groupe || !module) {
            return null;
        }

        // Gère les cas où plusieurs groupes sont dans la même cellule (ex: "TDI101 TDI102")
        const subGroups = groupe.trim().split(/\s+/).filter(Boolean);

        // On cherche l'affectation qui correspond. On s'arrête à la première trouvée.
        for (const subGroup of subGroups) {
            const affectation = appData.affectations.find(a =>
                a.formateur === formateur &&
                a.groupe === subGroup &&
                a.module === module
            );

            if (affectation) {
                const s1Hours = parseFloat(affectation.s1_heures) || 0;
                const s2Hours = parseFloat(affectation.s2_heures) || 0;

                if (s1Hours > 0 && s2Hours > 0) return "Annual";
                if (s1Hours > 0) return "S1";
                if (s2Hours > 0) return "S2";
            }
        }
        
        // Si on n'a rien trouvé, on retourne null.
        return null;
    }
  </script>
</body>
</html>