<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Système d'Emploi du Temps avec Excel</title>
  <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <style>
    /* ... (tous les styles précédents restent ici, SAUF les styles pour .alert-box et .btn-save) ... */
    
    /* ============================================================== */
    /* ==   NOUVEAUX STYLES AMÉLIORÉS POUR LE CALENDRIER PERSONNALISÉ   == */
    /* ============================================================== */
    .week-selection {
      display: flex;
      justify-content: center;
      margin: auto;
      gap: 10px;
      align-items: center;
    }

    .week-import-btn {
      position: relative;
      display: inline-block;
    }

    .week-import-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      z-index: 1100;
      min-width: 250px;
      max-height: 300px;
      overflow-y: auto;
      padding: 10px;
      margin-top: 5px;
    }

    .week-import-menu.show {
      display: block;
      animation: fadeInScaleUp 0.2s ease-out;
    }

    .week-import-item {
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 0.95rem;
      margin-bottom: 3px;
    }

    .week-import-item:hover {
      background-color: #f0f4ff;
    }

    .week-import-item.selected {
      background-color: #3498db;
      color: white;
    }

    .btn-import {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 12px 8px 16px;
      gap: 8px;
      height: 43px;
      border: none;
      background: #000000d4;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .btn-import:hover {
      background: #0f0d0f4d;
    }

    .svg-icon-import {
      width: 20px;
      height: 20px;
      stroke: #ffffff;
    }

    .lable-import {
      margin-top: 1px;
      font-weight: bold;
      font-size: 15px;
      line-height: 22px;
      color: #ffffff;
      letter-spacing: 1px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }


    .custom-week-picker {
        position: relative;
        min-width: 250px;
        margin-left: 320px;
    }

    #customWeekDisplay {
        padding: 10px 15px;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 1.1rem;
        background-color: #fff;
        cursor: pointer;
        text-align: center;
        user-select: none;
        transition: all 0.2s ease-in-out;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        display: flex; /* Active Flexbox */
        align-items: center; /* Aligne verticalement l'icône et le texte */
        justify-content: center; /* Centre le contenu horizontalement */
        gap: 20px; /* Crée un espace entre l'icône et le texte */
        height: 43px;
    }

    #customWeekDisplay img {
        height: 25px;
        width: auto;
    }

    @keyframes fadeInScaleUp {
      from {
        opacity: 0;
        transform: translateX(-50%) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) scale(1);
      }
    }

    #calendarPopup {
        display: none;
        position: absolute;
        top: calc(100% + 5px);
        left: 50%;
        transform: translateX(-50%);
        width: 320px;
        background: #fff;
        border: 1px solid #e0e0e0;
        border-radius: 10px;
        box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        z-index: 1200;
        padding: 15px;
        animation: fadeInScaleUp 0.2s ease-out;
    }

    .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: 10px;
        margin-bottom: 10px;
        border-bottom: 1px solid #f0f0f0;
    }
    .calendar-header button {
        background: none;
        border: none;
        font-size: 1rem;
        cursor: pointer;
        color: #555;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
    }
    .calendar-header button:hover {
        background-color: #f0f4ff;
        color: #3498db;
    }
    .calendar-title {
        font-weight: 600;
        font-size: 1.1rem;
        color: #2c3e50;
    }

    .calendar-grid {
        width: 100%;
        border-collapse: collapse;
        text-align: center;
    }
    .calendar-grid th {
        font-size: 0.8rem;
        color: #95a5a6;
        padding-bottom: 10px;
        font-weight: 600;
        text-transform: uppercase;
    }
    .calendar-grid td {
        padding: 2px;
    }
    .calendar-day {
        width: 100%;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 0.95rem;
        border: 1px solid transparent;
    }
    .calendar-day:hover {
        background-color: #f0f4ff;
        transform: scale(1.05);
    }
    .calendar-day.other-month {
        opacity: 0.4;
    }
    .calendar-day.disabled-day {
        color: #bdc3c7;
        background-color: #f9f9f9;
        cursor: not-allowed;
    }
     .calendar-day.disabled-day:hover {
        background-color: #f9f9f9;
        transform: none;
    }
    .calendar-day.today {
        border-color: #3498db;
        color: #3498db;
        font-weight: bold;
    }
    
    /* Style pour la semaine sélectionnée */
    .calendar-day.selected-in-range {
        background-color: #eaf5ff;
        color: #2980b9;
        border-radius: 0;
    }
    .calendar-day.selected-start {
        background-color: #3498db;
        color: #fff;
        border-top-left-radius: 20px;
        border-bottom-left-radius: 20px;
    }
    .calendar-day.selected-end {
        background-color: #3498db;
        color: #fff;
        border-top-right-radius: 20px;
        border-bottom-right-radius: 20px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    body {
      background-color: #ffffff;
      padding-top: 60px;
      user-select: none;
    }

    .upload {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 30px;
      margin-left: 30px;
      margin-right: 30px;
      flex-wrap: wrap;
    }   

    .container-btn-file {
      display: flex;
      position: relative;
      justify-content: center;
      align-items: center;
      background-color: #307750;
      color: #fff;
      border-style: none;
      padding: 0.85em 0.85em;
      border-radius: 0.5em;
      overflow: hidden;
      z-index: 1;
      transition: all 250ms;
      font-weight: bold;
      min-width: 200px;
      margin-left: 10px;
    }

    .container-btn-file input[type="file"] {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    .container-btn-file > svg {
      margin-right: 1em;
    }
    .container-btn-file::before {
      content: "";
      position: absolute;
      height: 100%;
      width: 0;
      border-radius: 0.5em;
      background-color: #469b61;
      z-index: -1;
      transition: all 350ms;
    }
    .container-btn-file:hover::before {
      width: 100%;
    }

    .file-name {
      margin-top: 10px;
      font-size: 0.9rem;
      color: #333;
      background: #f0f7ff;
      padding: 5px 10px;
      border-radius: 5px;
      border: 1px dashed #3498db;
      max-width: 300px;
      word-break: break-all;
    }

    .week-selection {
      display: flex;
      justify-content: center;
      margin: auto;
    }

    .timetable-container {
      max-height: 80vh;
      overflow-y: auto;
      overflow-x: hidden;
      border-radius: 12px;
      margin: 5px;
      background: white;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    #timetable {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      font-size: 13px;
      color: #333;
      margin: 0 auto;
      background-color: #ffffff;
      border: 1px solid #ccc;
      min-width: 100%; /* Forcer le tableau à s'adapter à la largeur du conteneur */
    }

    #timetable thead {
      position: sticky;
      top: 0;
      background-color: #f1f1f1;
      z-index: 100;
      box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1);
      border: 1px solid #ccc;
    }

    #timetable th {
      padding: 10px 8px;
      text-align: center;
      font-weight: bold;
      color: #2c3e50;
      white-space: nowrap;
      border: 1px solid #ccc;
      font-size: 14px;
      white-space: normal;
    }

    #timetable td,
    #timetable th {
      padding: 0;
      word-wrap: break-word;
      border: 1px solid #c5c4c4;
      border-bottom: 1px solid #c5c4c4;
      transition: background-color 0.2s ease;
    }

    #timetable td,
    #timetable th {
      height: 30px;
    }

    #timetable .salle-row td {
  border-bottom: 4px solid #c5c4c4 !important;
}

    .formateur-cell {
      color: #fff;
      font-weight: bold;
      text-align: center;
      vertical-align: middle;
      border-right: 1px solid #4a6491;
      border-bottom: 3px solid #c5c4c4 !important;
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      white-space: nowrap;
      padding: 8px 4px;
      min-width: 120px !important;
      width: 120px !important;
    }

    .type-cell {
      background-color: #f5f5f5;
      font-weight: 300;
      font-size: 12px;
      min-width: 10px;
      max-width: 10px;
      text-align: center;
      width: 10px;
      padding: 4px 6px !important;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .formateur-green {
      background: linear-gradient(to right, #2e55cc, #3927ae);
    }

    .formateur-orange {
      background: linear-gradient(to right, #309654, #1a8139);
    }

    .formateur-red {
      background: linear-gradient(to right, #e74c3c, #c0392b);
    }

    .formateur-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
    }

    .formateur-name {
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
    }

    .formateur-hours {
      font-size: 0.85em;
      font-weight: normal;
      margin-top: 5px;
      background-color: rgba(255, 255, 255, 0.2);
      padding: 2px 5px;
      border-radius: 10px;
      writing-mode: horizontal-tb;
      transform: rotate(180deg);
    }

    .formateur-hours-genAuto {
      font-size: 0.85em;
      font-weight: normal;
      margin-top: 5px;
      background-color: rgba(255, 255, 255, 0.2);
      padding: 2px 5px;
      border-radius: 10px;
      writing-mode: horizontal-tb;
      transform: rotate(0deg);
    }
    
    #timetable tbody tr:hover td {
      background-color: #f9f9f9;
    }

    .day-header {
      font-size: 20px !important;
      color: #ffffff;
    }
    
    .day-header {
      font-size: 20px !important;
      color: #ffffff !important;
    }

    .day-header *,
    .day-header::before,
    .day-header::after {
      color: #ffffff !important;
    }

    .time-header {
      color: #ffffff !important; 
      font-weight: bold;
    }

    .weekend-row td {
      background-color: #fafafa;
    }
    
    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    .auto-resize-cell {
      width: 100%;
      padding: 0;
      height: 40px;
    }

    .auto-resize-select {
      width: 100%;
      font-size: 10px;
      border: none;
      outline: none;
      background: transparent;
      white-space: normal;
      overflow: visible;
      text-overflow: initial;
      height: 100%;
      line-height: 1.2;
      text-align: center;
      padding: 2px 4px;
      box-sizing: border-box;
      cursor: pointer;
    }

    .auto-resize-select option {
      text-align: center;
    }

    select::-ms-expand {
      display: none;
    }

    .save-section {
      text-align: center;
      padding: 20px;
      background-color: #f8f9fa;
      border-top: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .btn {
      padding: 9px 22px;
      font-size: 1.1rem;
      font-weight: 600;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 0 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    /* .btn-save a été supprimé */

    .btn-reset {
      background: linear-gradient(to right, #e74c3c, #c0392b);
      color: white;
    }

    .btn-history {
      background: linear-gradient(to right, #9b59b6, #8e44ad);
      color: white;
    }
    
    .btn-export {
      background: linear-gradient(to right, #3498db, #2980b9);
      color: white;
    }

    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
    }

    .btn:active {
      transform: translateY(-1px);
    }
    
    .conflict-highlight {
      background-color: #ffcdd2 !important;
      transition: background-color 0.3s;
    }

    .weekend-row {
      background-color: #f9f9f9;
    }

    .history-section {
      padding: 20px;
      background-color: #f8f9fa;
      border-top: 1px solid #e0e0e0;
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .history-title {
      font-size: 1.4rem;
      color: #2c3e50;
    }

    .history-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      max-height: 200px;
      overflow-y: auto;
      padding: 10px;
      background-color: white;
      border-radius: 8px;
      box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .week-card {
      background: linear-gradient(to right, #3498db, #2980b9);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 120px;
      text-align: center;
    }

    .week-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .week-card.active {
      background: linear-gradient(to right, #27ae60, #2ecc71);
      box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.3);
    }

    .week-card .week-label {
      font-weight: bold;
      font-size: 1.1rem;
    }

    .week-card .dates {
      font-size: 0.85rem;
      opacity: 0.9;
    }
    
    .legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      background: #f0f7ff;
      padding: 6px 12px;
      border-radius: 20px;
    }
    
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }
    
    .legend-green {
      background: linear-gradient(to right, #2ecc71, #27ae60);
    }
    
    .legend-orange {
      background: linear-gradient(to right, #f39c12, #e67e22);
    }
    
    .legend-red {
      background: linear-gradient(to right, #e74c3c, #c0392b);
    }
    
    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 60px;
      padding: 10px 20px;
      background:#fff;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      z-index: 700;
      justify-content: space-between;
    }


    
    .lundi-day-header { background: #007bff; }
    .mardi-day-header { background: #ae06cc; }
    .mercredi-day-header { background: #e74c3c; }
    .jeudi-day-header { background: #f39c12; }
    .vendredi-day-header { background: #27ae60; }
    .samedi-day-header { background: #ff00d9; }
    
    .lundi-session { background: #007bff; }
    .mardi-session { background: #ae06cc; }
    .mercredi-session { background: #e74c3c; }
    .jeudi-session { background: #f39c12; }
    .vendredi-session { background: #27ae60; }
    .samedi-session { background: #ff00d9; }
    
    .lundi-cell { background-color: #E0F0FF !important; }
    .mardi-cell { background-color: #f6d4ff !important; }
    .mercredi-cell { background-color: #ffe0e0 !important; }
    .jeudi-cell { background-color: #fff7e0 !important; }
    .vendredi-cell { background-color: #e0ffe0 !important; }
    .samedi-cell { background-color: #ffe0fd !important; }

    .selected-cell {
      background-color: #000000 !important;
      font-weight: bold !important;
      color: #ffffff !important;
    }

    .selected-cell * {
      color: #ffffff !important;
      font-weight: bold !important;
    }

    .selected-cell input,
    .selected-cell select {
      color: #ffffff !important;
      font-weight: bold !important;
      background-color: #000000 !important;
      border-color: #ffffff !important;
    }

    .draggable-cell {
      cursor: move;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .dragging {
      opacity: 0.5;
      transform: scale(0.95);
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }
    
    .drag-over {
      background-color: #e3f2fd !important;
      border: 2px dashed #2196F3 !important;
    }
    
    .drop-target {
      background-color: #e3f2fd !important;
      border: 2px dashed #2196F3 !important;
    }
    
    .drop-hint {
      position: absolute;
      background: #2196F3;
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      opacity: 0.9;
      transform: translateY(-100%);
    }
    
    .drag-indicator {
      position: absolute;
      top: 2px;
      right: -5px;
      font-size: 10px;
      opacity: 0;
      cursor: move;
      width: 20px;
      height: 20px;
      z-index: 10;
    }

    .draggable-cell:hover .drag-indicator {
      opacity: 0.5;
    }
    
    .group-highlight {
      animation: pulse 2s infinite;
      border: 2px solid #ff9800;
      box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(255, 152, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0); }
    }
    
    .excel-selection {
      position: absolute;
      border: 2px solid #2196F3;
      background-color: rgba(33, 150, 243, 0.1);
      pointer-events: none;
      z-index: 500;
    }
    
    .excel-selected {
      background-color: rgba(33, 150, 243, 0.3) !important;
      outline: 2px solid #2196F3 !important;
      position: relative;
      z-index: 50;
    }
    
    .excel-selected.select-focus {
      background-color: rgba(33, 150, 243, 0.4) !important;
    }
    
    .excel-toolbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: white;
      padding: 10px 20px;
      border-radius: 50px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      z-index: 600;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    
    .excel-toolbar.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    .excel-toolbar button {
      background: #f5f5f5;
      border: none;
      border-radius: 5px;
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: background 0.2s;
    }
    
    .excel-toolbar button:hover {
      background: #e0e0e0;
    }
    
    .keyboard-shortcut {
      background: #e0e0e0;
      border-radius: 3px;
      padding: 2px 4px;
      font-size: 0.8em;
      margin-left: 5px;
    }
    
    .tooltip {
      position: relative;
      display: inline-block;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 120px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    .paste-notification {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      z-index: 700;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .paste-notification.show {
      opacity: 1;
    }

    .conflict-highlight {
      background-color: #ffdddd !important;
    }

    td[data-salle="TEAMS"] .conflict-highlight {
      background-color: transparent !important;
    }
    
    /* Styles pour les espaces personnalisés */
    .espace-section {
      margin: 15px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .espace-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .espace-controls input {
      flex: 1;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    
    .espace-controls button {
      padding: 10px 15px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    
    .espace-controls button:hover {
      background: #2980b9;
    }
    
    .espaces-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .espace-tag {
      background: #3498db;
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .espace-tag button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-weight: bold;
    }
    
    /* Section d'export */
    .export-section {
      display: flex;
      justify-content: center;
      margin-top: 15px;
      gap: 10px;
    }

    .save-status {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 15px 25px;
      color: white;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      transform: translateX(150%);
      transition: transform 0.3s ease;
      background-color: #3498db;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .save-status.show {
      transform: translateX(0);
    }
    
    .save-status.error {
      background-color: #e74c3c;
    }
    
    .save-status.success {
      background-color: #2ecc71;
    }

    
    /* ======================================================= */
/* ==      NOUVEAU STYLE POUR LE LOADER ANIMÉ           == */
/* ======================================================= */

/* Ce conteneur gère l'arrière-plan et le centrage */
.loader-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(44, 62, 80, 0.235); /* Un fond sombre pour mieux voir l'animation */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

/* Le texte sous l'animation */
.loader-container p {
    color: white;
    font-weight: 500;
    margin-top: 20px;
    letter-spacing: 1px;
}

/* Votre code CSS pour l'animation (inchangé) */
.loader {
  position: relative;
  width: 33px;
  height: 33px;
  perspective: 67px;
}

.loader div {
  width: 100%;
  height: 100%;
  background: #fff;
  position: absolute;
  left: 50%;
  transform-origin: left;
  animation: loader 2s infinite;
}

.loader div:nth-child(1) {
  animation-delay: 0.15s;
}

.loader div:nth-child(2) {
  animation-delay: 0.3s;
}

.loader div:nth-child(3) {
  animation-delay: 0.45s;
}

.loader div:nth-child(4) {
  animation-delay: 0.6s;
}

.loader div:nth-child(5) {
  animation-delay: 0.75s;
}

@keyframes loader {
  0% {
    transform: rotateY(0deg);
  }

  50%, 80% {
    transform: rotateY(-180deg);
  }

  90%, 100% {
    opacity: 0;
    transform: rotateY(-180deg);
  }
}

    nav a {
      text-decoration: none;
      color: #333;
      padding: 8px 16px;
      border-radius: 8px;
      transition: background-color 0.3s, color 0.3s;
    }

    nav a:hover {
      background-color: #f0f4ff;
      color: #1d4ed8; /* Bleu foncé */
      font-weight: 600;
    }

    nav a.active {
      background-color: #f0f4ff;
      color: #1d4ed8; /* Bleu foncé */
      font-weight: 600;
    }

    /* AJOUTEZ CE BLOC CSS DANS VOS PAGES */

.nav-links {
    display: flex;
    align-items: center;
    gap: 10px; /* Espace entre les liens et le bouton de profil */
}

/* Conteneur principal pour le menu de profil */
/* AJOUTEZ/REMPLACEZ CE BLOC CSS DANS VOS PAGES */

.profile-menu-container {
    position: relative;
}

.profile-button {
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #e0eaff; /* Couleur similaire à un lien actif */
    color: #1d4ed8;
    border: 1px solid #e0eaff;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}


.profile-dropdown {
    display: none;
    position: absolute;
    top: calc(100% + 12px);
    right: 0;
    width: 280px;
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    z-index: 1010;
    overflow: hidden;
    transform-origin: top right;
    animation: scale-up-and-fade-in 0.2s ease-out;
}

.profile-dropdown.show {
    display: block; /* La classe .show le rend visible */
}

@keyframes scale-up-and-fade-in {
    from {
        transform: scale(0.95);
        opacity: 0;
    }
    to {
        transform: scale(1);
        opacity: 1;
    }
}


.dropdown-profile-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px;
    border-bottom: 1px solid #f3f4f6;
}

.profile-pic {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background-color: #f3f4f6;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    color: #6b7280;
}

.profile-info strong {
    display: block;
    font-size: 1rem;
    font-weight: 600;
    color: #111827;
}
.profile-info small {
    font-size: 0.875rem;
    color: #6b7280;
}

.dropdown-menu-list {
    list-style: none;
    padding: 8px;
    margin: 0;
}

.dropdown-link {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 10px 12px;
    border-radius: 8px;
    text-decoration: none;
    color: #374151;
    font-weight: 500;
    transition: background-color 0.2s, color 0.2s;
}
.dropdown-link:hover {
    background-color: #f3f4f6;
}

.dropdown-link .icon {
    width: 32px;
    font-size: 16px;
    color: #6b7280;
}
.dropdown-link .text {
    flex-grow: 1;
}
.dropdown-link .chevron {
    font-size: 12px;
    color: #9ca3af;
}

.dropdown-divider {
    margin: 0 8px;
    border: none;
    border-top: 1px solid #f3f4f6;
}

.dropdown-link.logout {
    margin: 8px;
    width: calc(100% - 16px);
    color: #ef4444; /* Rouge */
}
.dropdown-link.logout .icon {
    color: #ef4444;
}
.dropdown-link.logout:hover {
    background-color: #fee2e2;
}

    /* Styles pour le tableau des contraintes dans la modale */
    .constraints-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .constraints-table th, .constraints-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
      vertical-align: middle;
    }
    .constraints-table th {
      background-color: #f2f2f2;
      font-weight: 600;
    }
    .constraints-table .formateur-name-col {
      font-weight: bold;
      min-width: 150px;
    }
    .constraints-table input[type="number"] {
      width: 60px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .constraints-table select[multiple] {
      width: 100%;
      min-height: 80px;
    }

    .availability-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
    }
    .availability-grid label {
      font-size: 12px;
      display: flex;
      align-items: center;
    }
    .availability-grid input {
      margin-right: 4px;
    }


 /* NOUVEAUX STYLES SANS ASCENSEUR */
.spaces-checkbox-container {
  /* On a retiré max-height et overflow-y */
  border: 1px solid #ddd;
  padding: 8px;
  border-radius: 4px;
  background-color: #f9f9f9; /* Légère couleur de fond pour distinguer la zone */
}
.spaces-checkbox-container label {
  display: block; 
  padding: 3px 0;
  user-select: none;
  cursor: pointer;
}
.spaces-checkbox-container input {
  margin-right: 8px;
  vertical-align: middle;
}


/* ... (votre autre CSS) ... */

/* NOUVEAUX STYLES POUR LE BOUTON UIVERSE */

#voiceAssistantBtn {
  position: fixed;
  bottom: 30px;
  right: 30px;
  z-index: 1100;
}

.uiverse {
  --duration: 7s;
  --easing: linear;
  --c-color-1: rgba(255, 163, 26, 0.7);
  --c-color-2: #1a23ff;
  --c-color-3: #e21bda;
  --c-color-4: rgba(255, 232, 26, 0.7);
  --c-shadow: rgba(255, 223, 87, 0.5);
  --c-shadow-inset-top: rgba(255, 223, 52, 0.9);
  --c-shadow-inset-bottom: rgba(255, 250, 215, 0.8);
  --c-radial-inner: #ffd215;
  --c-radial-outer: #fff172;
  --c-color: #ffffff;
  -webkit-tap-highlight-color: transparent;
  -webkit-appearance: none;
  outline: none;
  position: relative;
  cursor: pointer;
  border: none;
  
  /* --- MODIFICATIONS CLÉS POUR LA FORME CIRCULAIRE --- */
  width: 60px; /* AJOUTÉ: Largeur fixe */
  height: 60px; /* AJOUTÉ: Hauteur fixe */
  border-radius: 50%; /* MODIFIÉ: Pour un cercle parfait */
  padding: 0; /* MODIFIÉ: Pas de padding sur le bouton lui-même */
  /* --- FIN DES MODIFICATIONS CLÉS --- */

  margin: 0;
  text-align: center;
  font-weight: 600;
  letter-spacing: 0.02em;
  line-height: 1.5;
  color: var(--c-color);
  background: radial-gradient(
    circle,
    var(--c-radial-inner),
    var(--c-radial-outer) 80%
  );
  box-shadow: 0 0 14px var(--c-shadow);
}

.uiverse:before {
  content: "";
  pointer-events: none;
  position: absolute;
  z-index: 3;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  border-radius: 50%; /* MODIFIÉ: Doit correspondre au bouton */
  box-shadow:
    inset 0 3px 12px var(--c-shadow-inset-top),
    inset 0 -3px 4px var(--c-shadow-inset-bottom);
}

.uiverse .wrapper {
  -webkit-mask-image: -webkit-radial-gradient(white, black);
  overflow: hidden;
  border-radius: 50%; /* MODIFIÉ: Doit correspondre au bouton */
  
  /* --- AJOUTS POUR CENTRER LE CONTENU --- */
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  /* --- FIN DES AJOUTS --- */
}

.uiverse .wrapper span {
  display: inline-block;
  position: relative;
  z-index: 1;
  font-size: 24px; /* AJOUTÉ: Pour une icône plus grande */
  line-height: 0; /* AJOUTÉ: Pour un centrage vertical parfait */
}

.uiverse:hover {
  --duration: 1400ms;
}

.uiverse.listening {
    --duration: 1s;
    box-shadow: 0 0 25px var(--c-color-2), 0 0 15px var(--c-shadow);
}
.uiverse.listening span i {
    animation: pulse-mic 1.5s infinite;
}

@keyframes pulse-mic {
    0% { transform: scale(1); color: #e74c3c; }
    50% { transform: scale(1.3); color: #1a23ff; }
    100% { transform: scale(1); color: #e74c3c; }
}

.uiverse .wrapper .circle {
  position: absolute;
  left: 0;
  top: 0;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  filter: blur(var(--blur, 8px));
  background: var(--background, transparent);
  transform: translate(var(--x, 0), var(--y, 0)) translateZ(0);
  animation: var(--animation, none) var(--duration) var(--easing) infinite;
}

/* ... (toutes les classes .circle et les @keyframes restent les mêmes) ... */
.uiverse .wrapper .circle.circle-1,
.uiverse .wrapper .circle.circle-9,
.uiverse .wrapper .circle.circle-10 {
  --background: var(--c-color-4);
}
.uiverse .wrapper .circle.circle-3,
.uiverse .wrapper .circle.circle-4 {
  --background: var(--c-color-2);
  --blur: 14px;
}
.uiverse .wrapper .circle.circle-5,
.uiverse .wrapper .circle.circle-6 {
  --background: var(--c-color-3);
  --blur: 16px;
}
.uiverse .wrapper .circle.circle-2,
.uiverse .wrapper .circle.circle-7,
.uiverse .wrapper .circle.circle-8,
.uiverse .wrapper .circle.circle-11,
.uiverse .wrapper .circle.circle-12 {
  --background: var(--c-color-1);
  --blur: 12px;
}
.uiverse .wrapper .circle.circle-1 { --x: 0; --y: -40px; --animation: circle-1; }
.uiverse .wrapper .circle.circle-2 { --x: 92px; --y: 8px; --animation: circle-2; }
.uiverse .wrapper .circle.circle-3 { --x: -12px; --y: -12px; --animation: circle-3; }
.uiverse .wrapper .circle.circle-4 { --x: 80px; --y: -12px; --animation: circle-4; }
.uiverse .wrapper .circle.circle-5 { --x: 12px; --y: -4px; --animation: circle-5; }
.uiverse .wrapper .circle.circle-6 { --x: 56px; --y: 16px; --animation: circle-6; }
.uiverse .wrapper .circle.circle-7 { --x: 8px; --y: 28px; --animation: circle-7; }
.uiverse .wrapper .circle.circle-8 { --x: 28px; --y: -4px; --animation: circle-8; }
.uiverse .wrapper .circle.circle-9 { --x: 20px; --y: -12px; --animation: circle-9; }
.uiverse .wrapper .circle.circle-10 { --x: 64px; --y: 16px; --animation: circle-10; }
.uiverse .wrapper .circle.circle-11 { --x: 4px; --y: 4px; --animation: circle-11; }
.uiverse .wrapper .circle.circle-12 { --blur: 14px; --x: 52px; --y: 4px; --animation: circle-12; }

@keyframes circle-1 { 33% { transform: translate(0px, 16px) translateZ(0); } 66% { transform: translate(12px, 64px) translateZ(0); } }
@keyframes circle-2 { 33% { transform: translate(80px, -10px) translateZ(0); } 66% { transform: translate(72px, -48px) translateZ(0); } }
@keyframes circle-3 { 33% { transform: translate(20px, 12px) translateZ(0); } 66% { transform: translate(12px, 4px) translateZ(0); } }
@keyframes circle-4 { 33% { transform: translate(76px, -12px) translateZ(0); } 66% { transform: translate(112px, -8px) translateZ(0); } }
@keyframes circle-5 { 33% { transform: translate(84px, 28px) translateZ(0); } 66% { transform: translate(40px, -32px) translateZ(0); } }
@keyframes circle-6 { 33% { transform: translate(28px, -16px) translateZ(0); } 66% { transform: translate(76px, -56px) translateZ(0); } }
@keyframes circle-7 { 33% { transform: translate(8px, 28px) translateZ(0); } 66% { transform: translate(20px, -60px) translateZ(0); } }
@keyframes circle-8 { 33% { transform: translate(32px, -4px) translateZ(0); } 66% { transform: translate(56px, -20px) translateZ(0); } }
@keyframes circle-9 { 33% { transform: translate(20px, -12px) translateZ(0); } 66% { transform: translate(80px, -8px) translateZ(0); } }
@keyframes circle-10 { 33% { transform: translate(68px, 20px) translateZ(0); } 66% { transform: translate(100px, 28px) translateZ(0); } }
@keyframes circle-11 { 33% { transform: translate(4px, 4px) translateZ(0); } 66% { transform: translate(68px, 20px) translateZ(0); } }
@keyframes circle-12 { 33% { transform: translate(56px, 0px) translateZ(0); } 66% { transform: translate(60px, -32px) translateZ(0); } }

    .assistant-status {
        position: fixed;
        bottom: 100px;
        right: 30px;
        background: rgba(0, 0, 0, 0.75);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        z-index: 1099;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none; /* Pour ne pas gêner les clics */
    }
    .assistant-status.visible {
        opacity: 1;
    }


    /* ======================================================= */
    /* ==      NOUVEAUX STYLES POUR LA NOTIFICATION         == */
    /* ======================================================= */
    :root {
      --notification-inset: 2rem;
      --animation-play-state: running;
    }

    .notification {
      color: rgba(0, 0, 0, 0.7);
      position: fixed;
      display: flex;
      font-size: 1.1rem; /* Taille de police ajustée */
      letter-spacing: 1px; /* Espacement ajusté */
      line-height: 1.4;
      gap: 1.25rem; /* Espace ajusté */
      top: 0;
      right: 0;
      margin: var(--notification-inset);
      width: 22rem; /* Largeur ajustée */
      background-color: white;
      box-shadow: 0 0 0.5rem rgba(0, 0, 0, 0.25);
      border-radius: 0.5rem;
      max-width: calc(100% - 4rem); /* Marge ajustée */
      z-index: 9999;
      padding: 1.25rem 1rem; /* Remplissage ajusté */
      overflow: hidden; /* changé de clip à hidden pour meilleure compatibilité */
      transform: translateX(calc(100% + var(--notification-inset)));
      animation: slideInOut 160s cubic-bezier(0.33, 0, 0.66, 1.33);
      animation-fill-mode: forwards; /* Pour que l'état final persiste */
    }

    .notification.show {
        transform: translateX(0);
        animation: slideIn 0.5s cubic-bezier(0.33, 0, 0.66, 1.33) forwards;
    }
    
    .notification.hide {
        animation: slideOut 0.5s cubic-bezier(0.33, 0, 0.66, 1.33) forwards;
    }

    .notification:before {
      content: "";
      display: block;
      position: absolute;
      inset: 0 auto auto 0;
      height: 0.35rem; /* Hauteur ajustée */
      background-color: var(--accent-color, #49a87d);
      transform-origin: left;
      animation: countdown 3.5s linear forwards;
      animation-delay: 0.5s;
    }

    .notification__text {
      margin: 0.2rem 0 0;
      font-size: 0.9rem;
    }

    .notification__header {
      color: black;
      margin: 0;
      font-size: 1.2rem; /* Taille ajustée */
      font-weight: 600;
    }

    .notification__action {
      margin-left: auto;
    }
    
    .notification__action .button {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
    }
    
    .notification__action .button:hover {
        background-color: rgba(0,0,0,0.1);
    }

    .notification__icon {
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 3rem; /* Taille ajustée */
      height: 3rem; /* Taille ajustée */
      background-color: var(--accent-color, #49a87d);
      flex-shrink: 0;
    }
    
    .notification__icon i {
        font-size: 1.5rem;
        color: white;
    }

    .button {
      appearance: none;
      background: none;
      border: none;
      font: inherit;
      margin: 0;
      color: currentColor;
      padding: 0;
      cursor: pointer;
    }

    @keyframes slideIn {
        from { transform: translateX(calc(100% + var(--notification-inset))); }
        to { transform: translateX(0); }
    }
    
    @keyframes slideOut {
        from { transform: translateX(0); }
        to { transform: translateX(calc(100% + var(--notification-inset))); }
    }

    @keyframes countdown {
      to {
        transform: scaleX(0);
      }
    }
    
    /* ======================================================= */
    /* ==      NOUVEAUX STYLES POUR LE BOUTON ENREGISTRER   == */
    /* ======================================================= */
    .button {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 12px 8px 16px;
      gap: 8px;
      height: 45px;
      width: 150px;
      border: none;
      background: #e6f0ff;
      border-radius: 20px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .button-reset {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 12px 8px 16px;
      gap: 8px;
      height: 45px;
      width: 150px;
      border: none;
      background: #ff362b34;
      border-radius: 20px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .button-autogen {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 12px 8px 16px;
      gap: 4px;
      height: 45px;
      width: 270px;
      border: none;
      background: #5e41de33;
      border-radius: 20px;
      cursor: pointer;
      transition: background 0.3s ease;
      margin-right: 10px;
    }

    .button:hover {
      background: #d2e3fd;
    }

    .button-reset:hover {
      background: #ff362b52;
    }

    .button-autogen:hover {
      background: #5e41de4d;
    }

    .svg-icon {
      width: 20px;
      height: 20px;
      stroke: #056dfa;
    }

    .svg-icon-autogen {
      width: 20px;
      height: 20px;
      stroke: #5d41de;
    }

    .lable {
      margin-top: 1px;
      font-weight: 600;
      font-size: 15px;
      line-height: 22px;
      color: #056dfa;
      letter-spacing: 1px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    .lable-reset {
      margin-top: 1px;
      font-weight: 600;
      font-size: 15px;
      line-height: 22px;
      color: #fa0505;
      letter-spacing: 1px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    .lable-autogen {
      margin-top: 1px;
      font-weight: 600;
      font-size: 15px;
      line-height: 22px;
      color: #5D41DE;
      letter-spacing: 1px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }




    .button#notificationClose{
      background-color: white;
    }

    .upload-section{
      margin-top: 35px;
    }



    .drop-possible {
      background-color: #e8f5e9 !important;
      border: 2px dashed #4CAF50 !important;
  outline-offset: -1px;
}
    

/* ================================================================= */
/*          NOUVEAU CODE CORRIGÉ POUR LES BADGES ET L'ÉTOILE         */
/* ================================================================= */

/* --- Base commune pour les cellules de module --- */
.auto-resize-cell.module-s1,
.auto-resize-cell.module-s2,
.auto-resize-cell.module-annual,
.auto-resize-cell.module-regional {
    position: relative;
    overflow: visible;
}


/* --- Badge Numérique (Carré + Chiffre) via ::after --- */
/* Reste inchangé, en haut à droite */
.auto-resize-cell.module-s1::after,
.auto-resize-cell.module-s2::after,
.auto-resize-cell.module-annual::after {
    /* Propriétés du texte (Numéro/Lettre) */
    color: white;
    font-size: 10px;
    font-weight: 700;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    text-shadow: 0 0.5px 1px rgba(0,0,0,0.3);

    /* Propriétés de la boîte (Carré) */
    position: absolute;
    top: 4px;
    right: 4px; /* Aligné à droite */
    width: 14px;
    height: 14px;
    border-radius: 3px;
    box-shadow:
        0 0 0 1px rgba(255,255,255,0.8) inset,
        0 1px 2px rgba(0,0,0,0.1);

    /* Centrage du texte dans la boîte */
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    pointer-events: none;
}

/* Contenu et couleur spécifiques à chaque type de badge */
.auto-resize-cell.module-s1::after {
    content: "1";
    background-color: #1B9AF0;
}

.auto-resize-cell.module-s2::after {
    content: "2";
    background-color: #2BB673;
}

.auto-resize-cell.module-annual::after {
    content: "A";
    background-color: #FF6D00;
}


/* --- Étoile pour les modules Régionaux via ::before --- */
/*
 * MODIFICATION : L'étoile est maintenant positionnée à gauche
 * pour une meilleure visibilité.
*/
.auto-resize-cell.module-regional::before {
  content: "⭐";
  position: absolute;
  top: calc(100% - 28px);
  left: 3px; /* CHANGEMENT ICI : de 'right' à 'left' */
  font-size: 8px;
  color: gold;
  text-shadow: 0 0 1px rgba(0, 0, 0, 0.5);
  z-index: 1;
  pointer-events: none;
}


/* --- Styles inchangés pour les listes déroulantes --- */
.auto-resize-cell.module-s1 select,
.auto-resize-cell.module-s2 select,
.auto-resize-cell.module-annual select {
    padding-top: 5px;
    padding-right: 20px;
    padding-left: 6px;
    cursor: pointer;
    background-color: rgba(0,0,0,0.03);
    border-radius: 3px;
    font-size: 0.9em;
}
/* --- FIN Styles pour les modules Régionaux --- */
  </style>
</head>

<body>
  <div class="container">
    <nav>
      <img src="assets/images/logo_edtpro.png" style="height: 80px; width: auto;" id="logo" alt="Logo">
      <div class="nav-links"> <!-- J'ai ajouté une classe pour mieux cibler les liens -->
          <a href="admin.html" id="nav-admin">Emploi globale</a>
          <a href="edition.html" id="nav-edition">Edition</a>
          <a href="avancement.html" id="nav-avancement">Avancement</a>
          <div class="profile-menu-container" id="profile-menu-container">
            <!-- Le bouton/lien principal reste le même -->
            <button id="profile-button" class="profile-button">
              <span id="profile-initials">--</span>
          </button>
        
            <!-- === NOUVELLE STRUCTURE SIMPLIFIÉE DU MENU DÉROULANT === -->
<div id="profile-dropdown" class="profile-dropdown">
  <!-- En-tête avec l'image et le nom -->
  <div class="dropdown-profile-header">
      <div class="profile-pic">
          <i class="fas fa-user"></i>
      </div>
      <div class="profile-info">
          <strong id="dropdown-user-name">Chargement...</strong>
          <small id="dropdown-user-email">...</small>
      </div>
  </div>

  <!-- Liste des liens (simplifiée) -->
  <ul class="dropdown-menu-list">
      <li>
          <a href="profile.html" class="dropdown-link">
              <i class="fas fa-user-edit icon"></i>
              <span class="text">Mon Profil</span>
              <i class="fas fa-chevron-right chevron"></i>
          </a>
      </li>
      <!-- Le lien "Paramètres" a été supprimé -->
  </ul>

  <!-- Séparateur et lien de déconnexion -->
  <hr class="dropdown-divider">
  <a href="../api/auth/logout.php" class="dropdown-link logout">
      <i class="fas fa-sign-out-alt icon"></i>
      <span class="text">Déconnexion</span>
  </a>
</div>
<!-- ======================================================== -->
      </div>
  </nav>
    
    <section class="upload-section">
      <div class="upload">
        <div class="file-input-container">
          <button class="container-btn-file">
            <svg fill="#fff" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 50 50">
              <path d="M28.8125 .03125L.8125 5.34375C.339844 5.433594 0 5.863281 0 6.34375L0 43.65625C0 
                44.136719 .339844 44.566406 .8125 44.65625L28.8125 
                49.96875C28.875 49.980469 28.9375 50 29 50C29.230469 
                50 29.445313 49.929688 29.625 49.78125C29.855469 49.589844 
                30 49.296875 30 49L30 1C30 .703125 29.855469 .410156 29.625 
                .21875C29.394531 .0273438 29.105469 -.0234375 28.8125 .03125ZM32 
                6L32 13L34 13L34 15L32 15L32 20L34 20L34 22L32 22L32 27L34 27L34 
                29L32 29L32 35L34 35L34 37L32 37L32 44L47 44C48.101563 44 49 
                43.101563 49 42L49 8C49 6.898438 48.101563 6 47 6ZM36 13L44 
                13L44 15L36 15ZM6.6875 15.6875L11.8125 15.6875L14.5 21.28125C14.710938 
                21.722656 14.898438 22.265625 15.0625 22.875L15.09375 22.875C15.199219 
                22.511719 15.402344 21.941406 15.6875 21.21875L18.65625 15.6875L23.34375 
                15.6875L17.75 24.9375L23.5 34.375L18.53125 34.375L15.28125 
                28.28125C15.160156 28.054688 15.035156 27.636719 14.90625 
                27.03125L14.875 27.03125C14.8125 27.316406 14.664063 27.761719 
                14.4375 28.34375L11.1875 34.375L6.1875 34.375L12.15625 25.03125ZM36 
                20L44 20L44 22L36 22ZM36 27L44 27L44 29L36 29ZM36 35L44 35L44 37L36 37Z">
              </path>
            </svg>
            Sélectionner fichier
            <input class="file" name="text" type="file" id="fileInput" accept=".xlsx, .xls" />
          </button>
          <div class="file-name" id="fileName" style="display: none;">Aucun fichier sélectionné</div>
        </div>

        <!-- ***** DÉBUT DE LA ZONE DU CALENDRIER PERSONNALISÉ ***** -->
        <div class="week-selection">
            <div class="custom-week-picker">
              <div id="customWeekDisplay">
                <img src="https://cdn-icons-png.flaticon.com/512/12887/12887924.png" alt="">
                <span id="weekDisplayText"></span>
              </div>
                <div id="calendarPopup">
                    <div class="calendar-header">
                        <button id="prevMonthBtn"><i class="fas fa-chevron-left"></i></button>
                        <span id="calendarTitle"></span>
                        <button id="nextMonthBtn"><i class="fas fa-chevron-right"></i></button>
                    </div>
                    <table class="calendar-grid">
                        <thead>
                            <tr><th>L</th><th>M</th><th>M</th><th>J</th><th>V</th><th>S</th><th>D</th></tr>
                        </thead>
                        <tbody id="calendarBody"></tbody>
                    </table>
                </div>
            </div>

            <div class="week-import-btn">
              <button class="btn-import" id="importWeekBtn">
                <svg class="svg-icon-import" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#9b59b6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24">
                  <path d="M3 15v4c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2v-4M17 8l-5-5-5 5M12 4.2v10.3"/>
                </svg>
                <span class="lable-import">Importer</span>
              </button>
              <div id="weekImportMenu" class="week-import-menu">
                <!-- Le contenu sera chargé dynamiquement -->
              </div>
            </div>
        </div>
        <!-- ***** FIN DE LA ZONE DU CALENDRIER PERSONNALISÉ ***** -->

        <!-- MODIFICATION : ANCIEN BOUTON REMPLACÉ PAR LE NOUVEAU -->
        <button class="button" id="saveTimetableBtn">
          <svg class="svg-icon" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#056dfa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24">
            <path d="M3 6H21V18a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6z"/>
            <path d="M3 6l3-4h6l3 4"/>
          </svg>
          <span class="lable">Enregistrer</span>
        </button>

        <button class="button-reset" id="resetBtn">
          <svg
    xmlns="http://www.w3.org/2000/svg"
    width="20"
    viewBox="0 0 20 20"
    height="20"
    fill="none"
    class="svg-icon-reset"
  >
    <g stroke-width="1.5" stroke-linecap="round" stroke="#ff342b">
      <path
        d="m3.33337 10.8333c0 3.6819 2.98477 6.6667 6.66663 6.6667 3.682 0 6.6667-2.9848 6.6667-6.6667 0-3.68188-2.9847-6.66664-6.6667-6.66664-1.29938 0-2.51191.37174-3.5371 1.01468"
      ></path>
      <path
        d="m7.69867 1.58163-1.44987 3.28435c-.18587.42104.00478.91303.42582 1.0989l3.28438 1.44986"
      ></path>
    </g>
  </svg>
          <span class="lable-reset">Réinitialiser</span>
        </button>

        <button class="button-autogen" id="autoGenerateBtn">
          <svg width="32px" height="32px" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><defs><style>.a{fill:none;stroke:#5D41DE;stroke-linecap:round;stroke-linejoin:round;}</style></defs><path class="a" d="M12,19.77a11.13,11.13,0,0,0-2.26.94L10,25.24,5.44,25a11.13,11.13,0,0,0-.94,2.26l3.37,3.05-3.37,3a10.68,10.68,0,0,0,.94,2.26L10,35.39l-.23,4.54a11.09,11.09,0,0,0,2.26.93l3.05-3.37,3,3.37a10.64,10.64,0,0,0,2.26-.93l-.23-4.54,4.54.23a10.64,10.64,0,0,0,.93-2.26l-3.37-3,3.37-3.05A11.09,11.09,0,0,0,24.66,25l-4.54.23.23-4.53a10.68,10.68,0,0,0-2.26-.94l-3,3.37Z"/><circle class="a" cx="15.05" cy="30.32" r="3.96"/><path class="a" d="M29.91,7.14a11,11,0,0,0-2.27.93l.24,4.54-4.54-.23a10.64,10.64,0,0,0-.93,2.26l3.36,3-3.36,3.05A11.09,11.09,0,0,0,23.34,23l4.54-.23-.24,4.53a11,11,0,0,0,2.27.94l3-3.37,3,3.37a11.13,11.13,0,0,0,2.26-.94L38,22.76l4.53.23a11.13,11.13,0,0,0,.94-2.26l-3.37-3.05,3.37-3a10.68,10.68,0,0,0-.94-2.26L38,12.61l.23-4.54A11,11,0,0,0,36,7.14l-3,3.37Z"/><circle class="a" cx="32.95" cy="17.68" r="3.96"/></svg>
          <span class="lable-autogen">Générer Automatiquement</span>
        </button>
    
    
    
    <section class="timetable-container" >
      <table id="timetable">
        <thead>
          <tr>
            <th rowspan="2" colspan="2"></th>
            <th colspan="4" class="day-header lundi-day-header">Lundi</th>
            <th colspan="4" class="day-header mardi-day-header">Mardi</th>
            <th colspan="4" class="day-header mercredi-day-header">Mercredi</th>
            <th colspan="4" class="day-header jeudi-day-header">Jeudi</th>
            <th colspan="4" class="day-header vendredi-day-header">Vendredi</th>
            <th colspan="4" class="day-header samedi-day-header">Samedi</th>
          </tr>
          <tr>
            <!-- Lundi -->
            <th class="time-header lundi-session">S1</th>
            <th class="time-header lundi-session">S2</th>
            <th class="time-header lundi-session">S3</th>
            <th class="time-header lundi-session">S4</th>
            <!-- Mardi -->
            <th class="time-header mardi-session">S1</th>
            <th class="time-header mardi-session">S2</th>
            <th class="time-header mardi-session">S3</th>
            <th class="time-header mardi-session">S4</th>
            <!-- Mercredi -->
            <th class="time-header mercredi-session">S1</th>
            <th class="time-header mercredi-session">S2</th>
            <th class="time-header mercredi-session">S3</th>
            <th class="time-header mercredi-session">S4</th>
            <!-- Jeudi -->
            <th class="time-header jeudi-session">S1</th>
            <th class="time-header jeudi-session">S2</th>
            <th class="time-header jeudi-session">S3</th>
            <th class="time-header jeudi-session">S4</th>
            <!-- Vendredi -->
            <th class="time-header vendredi-session">S1</th>
            <th class="time-header vendredi-session">S2</th>
            <th class="time-header vendredi-session">S3</th>
            <th class="time-header vendredi-session">S4</th>
            <!-- Samedi -->
            <th class="time-header samedi-session">S1</th>
            <th class="time-header samedi-session">S2</th>
            <th class="time-header samedi-session">S3</th>
            <th class="time-header samedi-session">S4</th>
          </tr>
        </thead>
        <tbody>
          <!-- Généré dynamiquement -->
        </tbody>
      </table>
    </section>
    
    
    
  </div>
  
  <div class="excel-toolbar" id="excelToolbar">
    <button id="copyBtn" class="tooltip">
      <i class="fas fa-copy"></i> Copier <span class="keyboard-shortcut">Ctrl+C</span>
      <span class="tooltiptext">Copier les cellules sélectionnées</span>
    </button>
    <button id="pasteBtn" class="tooltip">
      <i class="fas fa-paste"></i> Coller <span class="keyboard-shortcut">Ctrl+V</span>
      <span class="tooltiptext">Coller dans les cellules sélectionnées</span>
    </button>
    <button id="cutBtn" class="tooltip">
      <i class="fas fa-cut"></i> Couper <span class="keyboard-shortcut">Ctrl+X</span>
      <span class="tooltiptext">Couper les cellules sélectionnées</span>
    </button>
    <button id="deleteBtn" class="tooltip">
      <i class="fas fa-trash-alt"></i> Supprimer <span class="keyboard-shortcut">Suppr</span>
      <span class="tooltiptext">Effacer le contenu des cellules</span>
    </button>
    <button id="clearSelectionBtn" class="tooltip">
      <i class="fas fa-times"></i> Annuler sélection
      <span class="tooltiptext">Désélectionner les cellules</span>
    </button>
  </div>
  
  <div class="paste-notification" id="pasteNotification"></div>
  
  <!-- NOUVELLE STRUCTURE HTML POUR LA NOTIFICATION -->
  <div id="notification" class="notification" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="notification__icon" id="notificationIcon">
        <i class="fas fa-check"></i>
    </div>
    <div class="notification__body">
        <h2 class="notification__header" id="notificationHeader">Success</h2>
        <p class="notification__text" id="notificationText">Your changes have been saved</p>
    </div>
    <div class="notification__action">
        <button id="notificationClose" class="button" aria-label="dismiss this notification">
            <span aria-hidden="true">✕</span>
        </button>
    </div>
  </div>


  <div id="weekLoader" class="loader-container" style="display: none;">
    <div class="loader">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>
    <p>Chargement en cours...</p>
</div>

  <div id="autoGenModal" style="display: none; position: fixed; z-index: 1050; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);">
    <div style="background-color: #fefefe; margin: 10px auto; padding: 10px; border: 1px solid #888; width: 90%; height: 100%; max-width: 1600px; max-height: 920px; border-radius: 10px;">
      <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 10px;">
         <!--<h2 style="font-size: 1.8rem; color: #333;">Configuration de la Génération Automatique</h2>-->
         <div style="text-align: right; padding-top: 0px;">
          <button id="runAutoGenerateBtn" class="btn btn-save">Lancer la Génération</button>
        </div>
        <button id="closeModalBtn" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">×</button>
      </div>

      <div style="margin-bottom: 20px; font-size: 1.1rem; display: none; align-items: center;">
        <input type="checkbox" id="prefer5hBlocks" checked style="width: 20px; height: 20px; margin-right: 10px;">
        <label for="prefer5hBlocks">Privilégier les blocs de 5h (2 séances consécutives)</label>
    </div>
      
      <div id="autoGenConstraintsContainer" style="max-height: 400px; overflow-y: auto; padding-right: 15px;">
        <!-- Le contenu sera généré par JS -->
      </div>

      
    </div>
  </div>

  <button class="uiverse" id="voiceAssistantBtn" title="Activer l'assistant vocal">
    <div class="wrapper">
      <span><i class="fas fa-microphone"></i></span>
      <div class="circle circle-12"></div>
      <div class="circle circle-11"></div>
      <div class="circle circle-10"></div>
      <div class="circle circle-9"></div>
      <div class="circle circle-8"></div>
      <div class="circle circle-7"></div>
      <div class="circle circle-6"></div>
      <div class="circle circle-5"></div>
      <div class="circle circle-4"></div>
      <div class="circle circle-3"></div>
      <div class="circle circle-2"></div>
      <div class="circle circle-1"></div>
    </div>
  </button>
<div class="assistant-status" id="assistantStatus"></div>



  <script>


const jours = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
    const seances = ['S1', 'S2', 'S3', 'S4'];
    const SEANCE_DURATION = 2.5;
    let autoGenConstraints = {};
    const dayClasses = {
      'Lundi': 'lundi-cell',
      'Mardi': 'mardi-cell',
      'Mercredi': 'mercredi-cell',
      'Jeudi': 'jeudi-cell',
      'Vendredi': 'vendredi-cell',
      'Samedi': 'samedi-cell'
    };
    let appData = { formateurs: [], groupes: [], fusionGroupes: [], espaces: [], affectations: [] };
    let timetableData = {};
    let groupHours = {};
    let clipboard = { type: null, data: [] };
    let selectedDate = new Date();
    let calendarCurrentDate = new Date();
    let currentWeekValue = '';
    
    
    
    

    

    function updateEspacesTags() {
        const container = document.getElementById('espacesContainer');
        if (!container) return;
        container.innerHTML = '';
        appData.espaces.forEach(espace => {
            const tag = document.createElement('div');
            tag.className = 'espace-tag';
            tag.innerHTML = `${espace}<button onclick="removeEspace('${espace}')">×</button>`;
            container.appendChild(tag);
        });
    }

    document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('notificationClose').addEventListener('click', () => {
        document.getElementById('notification').classList.add('hide');
    });
});

    // =========================================================================
    // ==     NOUVELLE SECTION : LOGIQUE DU CALENDRIER PERSONNALISÉ           ==
    // =========================================================================

    /**
     * Initialise les écouteurs d'événements pour le calendrier personnalisé.
     */
    function setupCustomCalendar() {
        const display = document.getElementById('customWeekDisplay');
        const popup = document.getElementById('calendarPopup');
        const prevBtn = document.getElementById('prevMonthBtn');
        const nextBtn = document.getElementById('nextMonthBtn');

        display.addEventListener('click', () => {
            const isVisible = popup.style.display === 'block';
            popup.style.display = isVisible ? 'none' : 'block';
            if (!isVisible) {
                calendarCurrentDate = new Date(selectedDate);
                generateCalendar(calendarCurrentDate);
            }
        });

        prevBtn.addEventListener('click', () => {
            calendarCurrentDate.setMonth(calendarCurrentDate.getMonth() - 1);
            generateCalendar(calendarCurrentDate);
        });

        nextBtn.addEventListener('click', () => {
            calendarCurrentDate.setMonth(calendarCurrentDate.getMonth() + 1);
            generateCalendar(calendarCurrentDate);
        });
        
        // Fermer le popup si on clique en dehors
        document.addEventListener('click', (e) => {
            if (!display.contains(e.target) && !popup.contains(e.target)) {
                popup.style.display = 'none';
            }
        });
    }
    
    /**
     * Génère et affiche le calendrier pour un mois donné.
     * @param {Date} date - Une date dans le mois à afficher.
     */
    function generateCalendar(date) {
        const calendarBody = document.getElementById('calendarBody');
        const calendarTitle = document.getElementById('calendarTitle');
        
        calendarBody.innerHTML = '';
        const month = date.getMonth();
        const year = date.getFullYear();

        const monthName = date.toLocaleDateString('fr-FR', { month: 'long' });
        calendarTitle.textContent = `${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${year}`;

        const firstDayOfMonth = new Date(year, month, 1);
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const dateOffset = (firstDayOfMonth.getDay() + 6) % 7; 

        const selectedWeekInfo = getWeekInfo(selectedDate);
        const { startOfWeek, endOfWeek } = selectedWeekInfo;

        let currentDay = 1;
        for (let i = 0; i < 6; i++) {
            const row = document.createElement('tr');
            for (let j = 0; j < 7; j++) {
                const cell = document.createElement('td');
                if (i === 0 && j < dateOffset) {
                    // Cellules vides avant
                } else if (currentDay > daysInMonth) {
                    // Cellules vides après
                } else {
                    const cellDate = new Date(year, month, currentDay);
                    cellDate.setHours(0,0,0,0);
                    const dayDiv = document.createElement('div');
                    dayDiv.className = 'calendar-day';
                    dayDiv.textContent = currentDay;

                    const today = new Date();
                    today.setHours(0,0,0,0);
                    if (cellDate.getTime() === today.getTime()) {
                        dayDiv.classList.add('today');
                    }
                    
                    if (cellDate.getMonth() === 7) { // Août
                        dayDiv.classList.add('disabled-day');
                    } else {
                        dayDiv.onclick = () => {
                           updateWeekSelection(cellDate);
                           document.getElementById('calendarPopup').style.display = 'none';
                        };
                    }
                    
                    // NOUVELLE LOGIQUE POUR LE STYLE DE LA SEMAINE SÉLECTIONNÉE
                    if (cellDate >= startOfWeek && cellDate <= endOfWeek) {
                        if (cellDate.getTime() === startOfWeek.getTime()) {
                            dayDiv.classList.add('selected-start');
                        } else if (cellDate.getTime() === endOfWeek.getTime()) {
                            dayDiv.classList.add('selected-end');
                        } else {
                            dayDiv.classList.add('selected-in-range');
                        }
                    }

                    cell.appendChild(dayDiv);
                    currentDay++;
                }
                row.appendChild(cell);
            }
            calendarBody.appendChild(row);
            if (currentDay > daysInMonth) break;
        }
    }
    
    /**
     * Met à jour l'affichage et charge les données pour la semaine d'une date donnée.
     * @param {Date} date - La date sélectionnée.
     */
    function updateWeekSelection(date) {
        selectedDate = date;
        const weekInfo = getWeekInfo(date);
        
        const display = document.getElementById('customWeekDisplay');
        const start = weekInfo.startOfWeek.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short' });
        const end = weekInfo.endOfWeek.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short' });
        
        document.getElementById('weekDisplayText').innerHTML = `<strong>S${weekInfo.weekNumber}</strong> <span style="font-size:0.9em; color: #555;">(${start} - ${end})</span>`;
        
        if (weekInfo.weekValue !== currentWeekValue) {
            currentWeekValue = weekInfo.weekValue;
            loadWeekData(currentWeekValue);
        }

        generateCalendar(calendarCurrentDate);
    }
    
    /**
     * Obtient l'année de début de l'année scolaire pour une date donnée.
     * @param {Date} date - La date à évaluer.
     * @returns {number} - L'année de début (ex: 2024 pour l'année 2024-2025).
     */
    function getSchoolYear(date) {
        return (date.getMonth() < 8) ? date.getFullYear() - 1 : date.getFullYear(); // 8 = Septembre
    }
    
    /**
     * Fonction principale qui calcule toutes les informations sur une semaine scolaire.
     * @param {Date} date - La date pour laquelle on veut les informations.
     * @returns {object} - Un objet contenant les détails de la semaine.
     */
    function getWeekInfo(date) {
        const schoolYear = getSchoolYear(date);
        
        let firstDayOfSeptember = new Date(schoolYear, 8, 1);
        let dayOfWeek = firstDayOfSeptember.getDay();
        let firstMonday = new Date(firstDayOfSeptember);
        if (dayOfWeek !== 1) {
            const offset = (dayOfWeek === 0) ? 1 : 8 - dayOfWeek;
            firstMonday.setDate(firstDayOfSeptember.getDate() + offset);
        }
        
        let startOfWeek = new Date(date);
        const day = startOfWeek.getDay();
        const diff = startOfWeek.getDate() - day + (day === 0 ? -6 : 1);
        startOfWeek.setDate(diff);
        startOfWeek.setHours(0, 0, 0, 0);
        firstMonday.setHours(0, 0, 0, 0);
        
        let weekNumber = 1;
        if (startOfWeek >= firstMonday) {
            const timeDiff = startOfWeek.getTime() - firstMonday.getTime();
            weekNumber = Math.floor(timeDiff / (1000 * 60 * 60 * 24 * 7)) + 1;
        }

        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6);
        
        return {
            schoolYear: schoolYear,
            weekNumber: weekNumber,
            startOfWeek: startOfWeek,
            endOfWeek: endOfWeek,
            weekValue: `${schoolYear}-W${weekNumber}`
        };
    }

    // =========================================================================
    // ==               FIN DE LA SECTION CALENDRIER                          ==
    // =========================================================================


    window.addEventListener('resize', () => {
        document.querySelectorAll('.auto-resize-select').forEach(resizeTextToFit);
    });

    function resizeTextToFit(select) {
        const cell = select.closest('td');
        if (!cell) return;
        select.style.fontSize = '10px';
        let fontSize = 10;
        while (select.scrollWidth > cell.offsetWidth && fontSize > 6) {
            fontSize -= 0.5;
            select.style.fontSize = fontSize + 'px';
        }
    }

    function getFormattedName(name) {
        if (!name) return '';
        const words = name.trim().split(/\s+/).filter(word => word.length > 0);
        if (words.length <= 1) return name;
        if (words.length === 2) return words[1];
        const avantDernier = words[words.length - 2];
        const dernier = words[words.length - 1];
        return avantDernier.length < 4 ? `${avantDernier} ${dernier}` : dernier;
    }

    function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        document.getElementById('fileName').textContent = file.name;
        document.getElementById('fileName').style.display = 'block';
        const formData = new FormData();
        formData.append('excelFile', file);
        document.getElementById('weekLoader').style.display = 'flex';
        fetch('../api/data/upload_base_data.php', { method: 'POST', body: formData })
            .then(response => {
                if (!response.ok) {
                    // Capture les erreurs HTTP comme 500, 404 etc.
                    return response.text().then(text => { 
                        // On essaie de ne pas afficher tout le HTML d'erreur dans l'alerte
                        const shortError = text.length > 300 ? text.substring(0, 300) + '...' : text;
                        throw new Error(`Erreur serveur (HTTP ${response.status}): ${shortError}`);
                    });
                }
                return response.json(); // Tente de parser en JSON
            })
            .then(result => {
                document.getElementById('weekLoader').style.display = 'none';
                if (result.success) {
                    showNotification("Fichier traité et données mises à jour !", "success");
                    loadInitialData(); // On recharge tout pour refléter les changements
                } else {
                    showNotification(result.message || "Erreur lors du traitement.", "error");
                }
            })
            .catch(error => {
                document.getElementById('weekLoader').style.display = 'none';
                console.error("Erreur détaillée de l'upload:", error);
                // Affiche une erreur plus informative
                if (error instanceof SyntaxError) {
                    showNotification("Erreur: La réponse du serveur n'est pas un JSON valide. Vérifiez les logs PHP.", "error");
                } else {
                    showNotification(error.message || "Erreur de communication lors de l'envoi.", "error");
                }
            });
    }

    function generateTimetable() {
      const tbody = document.querySelector('#timetable tbody');
      tbody.innerHTML = '';
      if (!appData.formateurs || appData.formateurs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="26" style="text-align:center; padding: 20px; font-size: 1.1rem; color: #777;">Aucun formateur à afficher. Veuillez charger un fichier Excel contenant les données de base.</td></tr>';
        return;
      }
      renderTimetableFromData(timetableData);
      const timetableElement = document.getElementById('timetable');
      timetableElement.removeEventListener('change', handleTableInteraction);
      timetableElement.addEventListener('change', handleTableInteraction);
    }

    function handleTableInteraction(e) {
        const target = e.target;
        if (target.tagName !== 'SELECT') return;
        const type = target.dataset.type;
        if (type === 'groupe') {
            handleGroupeChange(e);
            updateFormateurCell(target.dataset.formateur);
        } else if (type === 'module') {
            handleModuleChange(e);
        } else if (type === 'salle') {
            handleSalleChange(e);
        }
        const cell = target.closest('td');
        if (target.value) {
            cell.classList.add('selected-cell');
        } else {
            cell.classList.remove('selected-cell');
        }
        resizeTextToFit(target);
    }

    function createSelect(jour, seance, formateur, type, options, selectedValue = '') {
        const select = document.createElement('select');
        select.dataset.jour = jour;
        select.dataset.seance = seance;
        select.dataset.formateur = formateur;
        select.dataset.type = type;
        select.className = "auto-resize-select";
        const emptyOption = document.createElement('option');
        emptyOption.value = '';
        emptyOption.textContent = '';
        select.appendChild(emptyOption);
        options.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option;
            opt.textContent = option;
            if (option === selectedValue) {
                opt.selected = true;
            }
            select.appendChild(opt);
        });
        if (type === 'module') {
            select.disabled = !selectedValue;
        }
        return select;
    }


    function updateGroupeSelectOptions(formateur, jour, seance, salle, isTeams) {
        const groupeSelect = document.querySelector(
            `select[data-formateur="${formateur}"][data-jour="${jour}"][data-seance="${seance}"][data-type="groupe"]`
        );
        if (!groupeSelect) return;
        const currentGroupe = groupeSelect.value;
        groupeSelect.innerHTML = '';
        const emptyOption = document.createElement('option');
        emptyOption.value = '';
        groupeSelect.appendChild(emptyOption);
        const source = isTeams ? appData.fusionGroupes : appData.groupes;
        const typeAffection = isTeams ? 'synchrone' : 'presentiel';
        let foundCurrent = false;
        source.forEach(groupe => {
            if (appData.affectations.some(a => a.formateur === formateur && a.groupe === groupe && a.type === typeAffection)) {
                const option = document.createElement('option');
                option.value = groupe;
                option.textContent = groupe;
                groupeSelect.appendChild(option);
                if (groupe === currentGroupe) {
                    foundCurrent = true;
                }
            }
        });
        if (foundCurrent) {
            groupeSelect.value = currentGroupe;
        } else if (currentGroupe) {
            const option = document.createElement('option');
            option.value = currentGroupe;
            option.textContent = currentGroupe;
            option.style.color = 'red';
            groupeSelect.appendChild(option);
            groupeSelect.value = currentGroupe;
        }
    }

    function handleGroupeChange(e) {
      const select = e.target;
      const jour = select.dataset.jour;
      const seance = select.dataset.seance;
      const formateur = select.dataset.formateur;
      const groupe = select.value;
      const conflict = checkGroupConflict(jour, seance, groupe, select);
      if (conflict) {
        showNotification(`Conflit: Le groupe ${groupe} est déjà pris.`, "chevauchement");
        highlightConflict(jour, seance, 'groupe', groupe);
        select.value = '';
        const event = new Event('change');
        select.dispatchEvent(event);
        updateTimetableData(jour, seance, formateur, 'groupe', '');
        return;
      }
      const oldGroupe = timetableData[formateur][jour][seance].groupe;
      const moduleSelect = document.querySelector(`select[data-jour="${jour}"][data-seance="${seance}"][data-formateur="${formateur}"][data-type="module"]`);
      if (groupe) {
        moduleSelect.disabled = false;
        if (oldGroupe && oldGroupe !== groupe) {
          groupHours[oldGroupe] = (groupHours[oldGroupe] || 0) - SEANCE_DURATION;
          checkGroupHours(oldGroupe);
        }
        groupHours[groupe] = (groupHours[groupe] || 0) + SEANCE_DURATION;
        checkGroupHours(groupe);
        updateModuleOptions(formateur, jour, seance, groupe);
        const currentModule = moduleSelect.value;
        if (!moduleSelect.querySelector(`option[value="${currentModule}"]`)) {
          moduleSelect.value = '';
        }
      } else {
        if (oldGroupe) {
          groupHours[oldGroupe] = (groupHours[oldGroupe] || 0) - SEANCE_DURATION;
          checkGroupHours(oldGroupe);
        }
        moduleSelect.disabled = true;
        moduleSelect.value = '';
      }
      updateTimetableData(jour, seance, formateur, 'groupe', groupe);
      updateTimetableData(jour, seance, formateur, 'module', moduleSelect.value);
    }
    
    function checkGroupHours(groupe) {
        if (!groupe) return;
        const hours = groupHours[groupe] || 0;
        updateGroupCells(groupe);
        if (hours >= 40) {
            showNotification(`Le groupe ${groupe} a atteint ${hours.toFixed(1)}h.`, "warning");
            document.querySelectorAll(`select[data-type="groupe"] option[value="${groupe}"]:checked`).forEach(opt => {
                const cell = opt.closest('td');
                cell.classList.add('group-highlight');
                setTimeout(() => cell.classList.remove('group-highlight'), 3000);
            });
        }
    }
    
    function updateGroupCells(groupe) {
      if (!groupe) return;
      const hours = groupHours[groupe] || 0;
      document.querySelectorAll(`select[data-type="groupe"] option[value="${groupe}"]:checked`).forEach(opt => {
            const cell = opt.closest('td');
            if(cell){
                cell.classList.toggle('group-highlight', hours >= 40);
            }
        });
    }

    function getCurrentTimetableData() {
        return {
            semaine: currentWeekValue, // Utilise la variable globale du calendrier
            emploiDuTemps: timetableData
        };
    }

    function updateFormateurCell(formateur) {
      const formateurCell = document.querySelector(`td.formateur-cell[data-formateur="${formateur}"]`);
      if (!formateurCell) return;
      let count = 0;
      if (timetableData[formateur]) {
        for (const jour in timetableData[formateur]) {
            for (const seance in timetableData[formateur][jour]) {
                if (timetableData[formateur][jour][seance].groupe) {
                    count++;
                }
            }
        }
      }
      const heures = count * SEANCE_DURATION;
      const hoursElement = document.getElementById(`hours-${formateur}`);
      if (hoursElement) {
        hoursElement.textContent = `${heures.toFixed(1)}`;
      }
      formateurCell.classList.remove('formateur-green', 'formateur-orange', 'formateur-red');
      if (heures <= 22.5) {
        formateurCell.classList.add('formateur-green');
      } else if (heures <= 35) {
        formateurCell.classList.add('formateur-orange');
      } else {
        formateurCell.classList.add('formateur-red');
      }
    }

    function handleModuleChange(e) {
    const select = e.target;
    const jour = select.dataset.jour;
    const seance = select.dataset.seance;
    const formateur = select.dataset.formateur;
    const module = select.value;

    updateTimetableData(jour, seance, formateur, 'module', module);

    const cell = select.closest('td');
    if (cell) {
        cell.classList.remove('module-s1', 'module-s2', 'module-annual', 'module-regional');

        if (module) {
            const selectedOption = select.options[select.selectedIndex];
            const semester = selectedOption.dataset.semester;
            const isRegional = selectedOption.dataset.regional === 'true';

            if (semester) {
                cell.classList.add(`module-${semester.toLowerCase()}`);
            }

            if (isRegional) {
                cell.classList.add('module-regional');
            }

            cell.classList.add('selected-cell');
        } else {
            cell.classList.remove('selected-cell');
        }
    }
}


    function handleSalleChange(e) {
        const select = e.target;
        const jour = select.dataset.jour;
        const seance = select.dataset.seance;
        const formateur = select.dataset.formateur;
        const salle = select.value;
        const cell = select.closest('td');
        cell.classList.toggle('selected-cell', !!salle);
        if (salle && checkRoomConflict(jour, seance, salle, select)) {
            showNotification(`La salle ${salle} est déjà occupée.`, "chevauchement");
            highlightConflict(jour, seance, 'salle', salle);
            select.value = '';
            cell.classList.remove('selected-cell');
            updateTimetableData(jour, seance, formateur, 'salle', '');
            return;
        }
        const isTeams = salle === "TEAMS";
        updateGroupeSelectOptions(formateur, jour, seance, salle, isTeams);
        const groupeSelect = document.querySelector(`select[data-jour="${jour}"][data-seance="${seance}"][data-formateur="${formateur}"][data-type="groupe"]`);
        if (groupeSelect) {
            const options = Array.from(groupeSelect.options).map(opt => opt.value);
            if (!options.includes(groupeSelect.value)) {
                groupeSelect.value = '';
                groupeSelect.dispatchEvent(new Event('change'));
            }
        }
        updateTimetableData(jour, seance, formateur, 'salle', salle);
    }

    function checkGroupConflict(jour, seance, groupe, currentSelect) {
        if (!groupe) return false;
        const newGroups = groupe.trim().split(/\s+/).filter(g => g);
        const allGroupeSelects = document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="groupe"]`);
        for (const select of allGroupeSelects) {
            if (select === currentSelect || !select.value) continue;
            const existingGroups = select.value.trim().split(/\s+/).filter(g => g);
            if (newGroups.some(ng => existingGroups.includes(ng))) {
                return true;
            }
        }
        return false;
    }

    function checkRoomConflict(jour, seance, salle, currentSelect) {
      if (salle === "TEAMS" || !salle) return false;
      const allSalleSelects = document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="salle"]`);
      for (const select of allSalleSelects) {
        if (select !== currentSelect && select.value === salle) {
            return true;
        }
      }
      return false;
    }

    function highlightConflict(jour, seance, type, value) {
      document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="${type}"]`).forEach(select => {
        const values = select.value.trim().split(/\s+/);
        if (values.includes(value)) {
            const cell = select.closest('td');
            cell.classList.add('conflict-highlight');
            setTimeout(() => cell.classList.remove('conflict-highlight'), 3000);
        }
      });
    }

    function initializeTimetableData() {
        timetableData = {};
        appData.formateurs.forEach(formateur => {
            timetableData[formateur] = {};
            jours.forEach(jour => {
                timetableData[formateur][jour] = {};
                seances.forEach(seance => {
                    timetableData[formateur][jour][seance] = { groupe: '', module: '', salle: '' };
                });
            });
        });
        groupHours = {};
    }

    function updateTimetableData(jour, seance, formateur, type, value) {
      if (timetableData[formateur] &&
          timetableData[formateur][jour] &&
          timetableData[formateur][jour][seance]) {
        timetableData[formateur][jour][seance][type] = value;
      }
    }

    async function saveTimetable() {
        const semaine = currentWeekValue;
        if (!semaine) {
            showNotification("Veuillez sélectionner une semaine.", "warning");
            return;
        }
        const dataToSave = getCurrentTimetableData();
        try {
            const saveResponse = await fetch('../api/data/save_timetable.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(dataToSave)
            });
            const saveResult = await saveResponse.json();
            if (saveResult.success) {
                showNotification("Emploi du temps enregistré avec succès", "success");
            } else {
                showNotification("Erreur: " + (saveResult.message || 'Erreur serveur'), "error");
            }
        } catch (error) {
            showNotification("Erreur réseau: " + error.message, "error");
        }
    }

    document.getElementById('saveTimetableBtn')?.addEventListener('click', saveTimetable);

    function resetTimetable() {
      if (confirm("Êtes-vous sûr de vouloir effacer l'emploi du temps affiché ?")) {
        initializeTimetableData();
        renderTimetableFromData(timetableData);
        showNotification("L'emploi du temps a été effacé.", "info");
      }
    }

    // =========================================================================
    // ==           NOUVELLE FONCTION DE NOTIFICATION                       ==
    // =========================================================================
    let notificationTimeout;
    function showNotification(message, type = "info") {
        const notification = document.getElementById('notification');
        const header = document.getElementById('notificationHeader');
        const text = document.getElementById('notificationText');
        const iconContainer = document.getElementById('notificationIcon');
        
        // Annuler le timeout précédent pour éviter une fermeture prématurée
        clearTimeout(notificationTimeout);

        // Définir les styles et le contenu en fonction du type
        const typeSettings = {
            success: { header: 'Succès', icon: 'fa-check', color: '#4CAF50' },
            error: { header: 'Erreur', icon: 'fa-times', color: '#f44336' },
            chevauchement:{ header: 'Chevauchement', icon: 'fa-exclamation-triangle', color: '#f44336' },
            warning: { header: 'Attention', icon: 'fa-exclamation-triangle', color: '#ff9800' },
            info: { header: 'Information', icon: 'fa-info-circle', color: '#2196F3' }
        };
        const settings = typeSettings[type] || typeSettings.info;

        header.textContent = settings.header;
        text.textContent = message;
        iconContainer.innerHTML = `<i class="fas ${settings.icon}"></i>`;
        notification.style.setProperty('--accent-color', settings.color);

        // Afficher la notification
        notification.classList.remove('hide');
        notification.classList.add('show');

        // La cacher après un délai
        notificationTimeout = setTimeout(() => {
            notification.classList.add('hide');
        }, 4000); // 4 secondes
    }
    
    function setupExcelSelection() {
      const table = document.getElementById('timetable');
      const selectionDiv = document.createElement('div');
      selectionDiv.className = 'excel-selection';
      selectionDiv.style.display = 'none';
      document.body.appendChild(selectionDiv);
      let isSelecting = false;
      let startCell = null;
      let startX, startY;
      table.addEventListener('mousedown', function(e) {
        if (!e.ctrlKey) {
          clearExcelSelection();
          return;
        }
        const cell = e.target.closest('td');
        if (!cell) return;
        if (cell.classList.contains('formateur-cell') || 
            cell.classList.contains('type-cell')) {
          return;
        }
        e.preventDefault();
        isSelecting = true;
        startCell = cell;
        startX = e.clientX;
        startY = e.clientY;
        const toolbar = document.getElementById('excelToolbar');
        toolbar.classList.add('visible');
        const rect = cell.getBoundingClientRect();
        selectionDiv.style.left = `${rect.left}px`;
        selectionDiv.style.top = `${rect.top}px`;
        selectionDiv.style.width = `${rect.width}px`;
        selectionDiv.style.height = `${rect.height}px`;
        selectionDiv.style.display = 'block';
        document.querySelectorAll('.excel-selected').forEach(c => {
          c.classList.remove('excel-selected');
        });
        cell.classList.add('excel-selected');
      });
      document.addEventListener('mousemove', function(e) {
        if (!isSelecting || !startCell) return;
        const currentCell = document.elementFromPoint(e.clientX, e.clientY)?.closest('td');
        if (!currentCell || currentCell === startCell) return;
        const startRect = startCell.getBoundingClientRect();
        const currentRect = currentCell.getBoundingClientRect();
        const minX = Math.min(startRect.left, currentRect.left);
        const maxX = Math.max(startRect.right, currentRect.right);
        const minY = Math.min(startRect.top, currentRect.top);
        const maxY = Math.max(startRect.bottom, currentRect.bottom);
        selectionDiv.style.left = `${minX}px`;
        selectionDiv.style.top = `${minY}px`;
        selectionDiv.style.width = `${maxX - minX}px`;
        selectionDiv.style.height = `${maxY - minY}px`;
        const allCells = document.querySelectorAll('tbody td');
        allCells.forEach(cell => {
          if (cell.classList.contains('formateur-cell') || 
              cell.classList.contains('type-cell')) {
            return;
          }
          const cellRect = cell.getBoundingClientRect();
          const isInSelection = 
            cellRect.left >= minX && 
            cellRect.right <= maxX && 
            cellRect.top >= minY && 
            cellRect.bottom <= maxY;
          if (isInSelection) {
            cell.classList.add('excel-selected');
          } else {
            cell.classList.remove('excel-selected');
          }
        });
      });
      document.addEventListener('mouseup', function() {
        isSelecting = false;
      });
      table.addEventListener('contextmenu', function(e) {
        if (isSelecting) {
          e.preventDefault();
        }
      });
    }

    function setupExcelToolbarListeners() {
      document.getElementById('copyBtn').addEventListener('click', copySelectedCells);
      document.getElementById('pasteBtn').addEventListener('click', pasteSelectedCells);
      document.getElementById('cutBtn').addEventListener('click', cutSelectedCells);
      document.getElementById('deleteBtn').addEventListener('click', deleteSelectedCells);
      document.getElementById('clearSelectionBtn').addEventListener('click', clearExcelSelection);
      document.addEventListener('keydown', function(e) {
        if (e.ctrlKey) {
          if (e.key === 'c') {
            e.preventDefault();
            copySelectedCells();
          } else if (e.key === 'v') {
            e.preventDefault();
            pasteSelectedCells();
          } else if (e.key === 'x') {
            e.preventDefault();
            cutSelectedCells();
          }
        } else if (e.key === 'Delete') {
          e.preventDefault();
          deleteSelectedCells();
        }
      });
      document.getElementById('clearSelectionBtn').addEventListener('click', clearExcelSelection);
    }
    
    function clearExcelSelection() {
      document.querySelectorAll('.excel-selected').forEach(c => {
        c.classList.remove('excel-selected');
      });
      const selectionDiv = document.querySelector('.excel-selection');
      if (selectionDiv) {
        selectionDiv.style.display = 'none';
      }
      const toolbar = document.getElementById('excelToolbar');
      toolbar.classList.remove('visible');
    }

    function showPasteNotification(message) {
      const notification = document.getElementById('pasteNotification');
      notification.textContent = message;
      notification.classList.add('show');
      setTimeout(() => notification.classList.remove('show'), 2000);
    }
    
    function copySelectedCells() {
      const selectedCells = document.querySelectorAll('.excel-selected');
      if (selectedCells.length === 0) {
        showNotification("Aucune cellule sélectionnée", "warning");
        return;
      }
      clipboard = {
        type: 'copy',
        data: [],
        matrix: []
      };
      const rows = {};
      selectedCells.forEach(cell => {
        const rowIndex = cell.closest('tr').rowIndex;
        const cellIndex = cell.cellIndex;
        if (!rows[rowIndex]) rows[rowIndex] = {};
        rows[rowIndex][cellIndex] = cell;
      });
      const rowIndices = Object.keys(rows).sort((a, b) => a - b);
      rowIndices.forEach(rowIndex => {
        const row = [];
        const cellIndices = Object.keys(rows[rowIndex]).sort((a, b) => a - b);
        cellIndices.forEach(cellIndex => {
          const cell = rows[rowIndex][cellIndex];
          const select = cell.querySelector('select');
          if (select) {
            row.push({
              formateur: select.dataset.formateur,
              jour: select.dataset.jour,
              seance: select.dataset.seance,
              type: select.dataset.type,
              value: select.value
            });
          }
        });
        clipboard.matrix.push(row);
      });
      showPasteNotification(`${selectedCells.length} cellules copiées`);
    }
    
    function pasteSelectedCells() {
      if (!clipboard || !clipboard.matrix || clipboard.matrix.length === 0) {
        showNotification("Aucune donnée à coller", "warning");
        return;
      }
      const selectedCells = document.querySelectorAll('.excel-selected');
      if (selectedCells.length === 0) {
        showNotification("Aucune cellule sélectionnée pour le collage", "warning");
        return;
      }
      const destMatrix = [];
      const destRows = {};
      selectedCells.forEach(cell => {
        const rowIndex = cell.closest('tr').rowIndex;
        const cellIndex = cell.cellIndex;
        if (!destRows[rowIndex]) destRows[rowIndex] = {};
        destRows[rowIndex][cellIndex] = cell;
      });
      const rowIndices = Object.keys(destRows).sort((a, b) => a - b);
      rowIndices.forEach(rowIndex => {
        const row = [];
        const cellIndices = Object.keys(destRows[rowIndex]).sort((a, b) => a - b);
        cellIndices.forEach(cellIndex => {
          row.push(destRows[rowIndex][cellIndex]);
        });
        destMatrix.push(row);
      });
      let pasteCount = 0;
      for (let i = 0; i < destMatrix.length; i++) {
        for (let j = 0; j < destMatrix[i].length; j++) {
          const srcRow = i % clipboard.matrix.length;
          const srcCol = j % clipboard.matrix[0].length;
          const cellData = clipboard.matrix[srcRow][srcCol];
          const cell = destMatrix[i][j];
          const select = cell.querySelector('select');
          if (select && select.dataset.type === cellData.type) {
            select.value = cellData.value;
            const event = new Event('change');
            select.dispatchEvent(event);
            updateTimetableData(
              select.dataset.jour,
              select.dataset.seance,
              select.dataset.formateur,
              select.dataset.type,
              cellData.value
            );
            const cellElement = select.closest('td');
            if (cellData.value) {
              cellElement.classList.add('selected-cell');
              cellElement.classList.remove('empty-cell');
            } else {
              cellElement.classList.remove('selected-cell');
              cellElement.classList.add('empty-cell');
            }
            if (select.dataset.type === 'groupe') {
              updateModuleOptions(
                select.dataset.formateur,
                select.dataset.jour,
                select.dataset.seance,
                cellData.value
              );
            }
            pasteCount++;
          }
        }
      }
      if (pasteCount > 0) {
        showPasteNotification(`${pasteCount} cellules collées`);
      } else {
        showNotification("Aucune cellule compatible pour le collage", "warning");
      }
    }
    
    function cutSelectedCells() {
      copySelectedCells();
      const selectedCells = document.querySelectorAll('.excel-selected');
      selectedCells.forEach(cell => {
        const selects = cell.querySelectorAll('select');
        selects.forEach(select => {
          select.value = '';
          const event = new Event('change');
          select.dispatchEvent(event);
          updateTimetableData(
            select.dataset.jour,
            select.dataset.seance,
            select.dataset.formateur,
            select.dataset.type,
            ''
          );
          const cellElement = select.closest('td');
          cellElement.classList.remove('selected-cell');
          cellElement.classList.add('empty-cell');
        });
      });
      showPasteNotification("Cellules coupées");
    }

    function deleteSelectedCells() {
      const selectedCells = document.querySelectorAll('.excel-selected');
      if (selectedCells.length === 0) {
        showNotification("Aucune cellule sélectionnée", "warning");
        return;
      }
      let deleteCount = 0;
      selectedCells.forEach(cell => {
        const selects = cell.querySelectorAll('select');
        selects.forEach(select => {
          select.value = '';
          const event = new Event('change');
          select.dispatchEvent(event);
          updateTimetableData(
            select.dataset.jour,
            select.dataset.seance,
            select.dataset.formateur,
            select.dataset.type,
            ''
          );
          const cellElement = select.closest('td');
          cellElement.classList.remove('selected-cell');
          cellElement.classList.add('empty-cell');
          deleteCount++;
        });
      });
      showPasteNotification(`${deleteCount} cellules effacées`);
    }

    function setupEventListeners() {
    const fileInput = document.getElementById('fileInput');
    const resetBtn = document.getElementById('resetBtn');
    const autoGenerateBtn = document.getElementById('autoGenerateBtn');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const runAutoGenerateBtn = document.getElementById('runAutoGenerateBtn');

    if (fileInput) fileInput.addEventListener('change', handleFileUpload);
    if (resetBtn) resetBtn.addEventListener('click', resetTimetable);
    if (autoGenerateBtn) autoGenerateBtn.addEventListener('click', openAutoGenModal);
    if (closeModalBtn) closeModalBtn.addEventListener('click', () => {
        document.getElementById('autoGenModal').style.display = 'none';
    });
    if (runAutoGenerateBtn) runAutoGenerateBtn.addEventListener('click', runAutoGeneration);

    const timetable = document.getElementById('timetable');
    if (timetable) {
        // Gère les actions *après* un changement.
        timetable.removeEventListener('change', handleTableInteraction);
        timetable.addEventListener('change', handleTableInteraction);

        // NOUVEAU : Gestion des clics pour mettre à jour l'affichage *avant* sélection.
        timetable.addEventListener('mousedown', function(e) {
            if (e.target.tagName !== 'SELECT') return;

            // Si c'est un menu de salle, on filtre les options.
            if (e.target.dataset.type === 'salle') {
                updateSalleOptions(e.target);
            } 
            // Si c'est un menu de groupe, on colore les options indisponibles.
            else if (e.target.dataset.type === 'groupe') {
                styleGroupOptions(e.target);
            }
        });
    }

    // NOUVEL ÉCOUTEUR POUR LE BOUTON D'IMPORTATION
    document.getElementById('importWeekBtn')?.addEventListener('click', showWeekDropdown);
      
      // Fermer le menu quand on clique en dehors
      document.addEventListener('click', (e) => {
        const menu = document.getElementById('weekImportMenu');
        const btn = document.getElementById('importWeekBtn');
        
        if (menu.classList.contains('show') && 
            !menu.contains(e.target) && 
            !btn.contains(e.target)) {
          menu.classList.remove('show');
        }
      });
}
    
function loadWeekData(weekValue) {
        const loader = document.getElementById('weekLoader');
        loader.style.display = 'flex';
        fetch(`../api/data/get_timetable.php?semaine=${weekValue}`)
            .then(response => response.json())
            .then(result => {
                loader.style.display = 'none';
                if (result.success) {
                    timetableData = result.data;
                    renderTimetableFromData(timetableData);
                    showNotification("Emploi du temps chargé", "success");
                } else {
                    initializeTimetableData();
                    renderTimetableFromData(timetableData);
                    showNotification("Aucun EDT trouvé pour cette semaine, tableau initialisé.", "info");
                }
            })
            .catch(error => {
                loader.style.display = 'none';
                showNotification("Erreur réseau: " + error.message, "error");
            });
    }

    /**
 * [CORRIGÉ ET ROBUSTE] Détermine si un module est régional.
 * Gère plusieurs formats de données pour la propriété 'est_regional' (1, "1", true, "true").
 * @param {string} formateur - Le nom du formateur.
 * @param {string} groupe - Le nom du ou des groupes.
 * @param {string} module - Le nom du module.
 * @returns {boolean} - True si le module est marqué comme régional, false sinon.
 */
function isModuleRegional(formateur, groupe, module) {
    if (!formateur || !groupe || !module) {
        return false;
    }

    const subGroups = groupe.trim().split(/\s+/).filter(Boolean);

    for (const subGroup of subGroups) {
        const affectation = appData.affectations.find(a =>
            a.formateur === formateur &&
            a.groupe === subGroup &&
            a.module === module
        );

        if (affectation && affectation.hasOwnProperty('est_regional')) {
            const value = affectation.est_regional;
            // Cette nouvelle condition est plus flexible et gère plusieurs cas :
            // true (booléen), 1 (nombre), "1" (chaîne), "true" (chaîne, insensible à la casse)
            return value === true || value == 1 || String(value).toLowerCase() === 'true';
        }
    }
    // Si aucune affectation n'est trouvée ou si la propriété manque.
    return false;
}


/**
 * [CORRIGÉ] Met à jour les options du menu déroulant des modules.
 * Utilise la nouvelle logique robuste pour attacher les métadonnées correctes.
 */
function updateModuleOptions(formateur, jour, seance, groupe) {
  const moduleSelect = document.querySelector(`select[data-formateur="${formateur}"][data-jour="${jour}"][data-seance="${seance}"][data-type="module"]`);
  if (!moduleSelect) {
    return;
  }

  const currentModule = moduleSelect.value;
  moduleSelect.innerHTML = '<option value=""></option>';

  if (!groupe) {
    moduleSelect.disabled = true;
    handleModuleChange({ target: moduleSelect });
    return;
  }

  moduleSelect.disabled = false;
  const subGroups = groupe.trim().split(/\s+/).filter(Boolean);
  const modulesEtStatut = new Map();

  appData.affectations.forEach(affectation => {
    if (affectation.formateur === formateur && subGroups.includes(affectation.groupe)) {
      const moduleName = affectation.module;
      const semesterStatus = getModuleSemester(formateur, affectation.groupe, moduleName);
      // Appel à la fonction corrigée
      const estRegional = isModuleRegional(formateur, affectation.groupe, moduleName);
      
      modulesEtStatut.set(moduleName, { semesterStatus, estRegional });
    }
  });

  modulesEtStatut.forEach((info, moduleName) => {
    const option = document.createElement('option');
    option.value = moduleName;
    option.textContent = moduleName;
    option.dataset.semester = info.semesterStatus;
    // Attache la bonne valeur booléenne à l'attribut data-regional
    option.dataset.regional = info.estRegional ? 'true' : 'false';

    if (moduleName === currentModule) {
      option.selected = true;
    }
    moduleSelect.appendChild(option);
  });
  
  if (currentModule && !modulesEtStatut.has(currentModule)) {
      moduleSelect.value = '';
  }

  const event = new Event('change', { bubbles: true });
  moduleSelect.dispatchEvent(event);
}


/**
 * [CORRIGÉ] Génère et affiche le contenu HTML de l'emploi du temps.
 * Utilise la nouvelle logique robuste pour appliquer la classe `module-regional`.
 */
function renderTimetableFromData(data) {
    const tbody = document.querySelector('#timetable tbody');
    let html = '';
    if (!appData.formateurs || appData.formateurs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="26" style="text-align:center; padding: 20px;">Données de base non chargées. Veuillez importer un fichier Excel.</td></tr>';
        return;
    }

    initializeTimetableData();
    if (data) {
        timetableData = JSON.parse(JSON.stringify(data));
    }

    groupHours = {};
    for (const formateur in timetableData) {
        for (const jour in timetableData[formateur]) {
            for (const seance in timetableData[formateur][jour]) {
                const session = timetableData[formateur][jour][seance];
                if (session.groupe) {
                    const subGroups = session.groupe.trim().split(/\s+/).filter(g => g);
                    subGroups.forEach(g => {
                       groupHours[g] = (groupHours[g] || 0) + SEANCE_DURATION;
                    });
                }
            }
        }
    }

    appData.formateurs.forEach(formateur => {
        const formateurData = timetableData[formateur] || {};
        let seanceCount = 0;
        if(formateurData){
            Object.values(formateurData).forEach(day => {
                Object.values(day).forEach(session => {
                    if (session.groupe) seanceCount++;
                });
            });
        }
        const heures = seanceCount * SEANCE_DURATION;
        let formateurClass = 'formateur-green';
        if (heures > 35) formateurClass = 'formateur-red';
        else if (heures > 22.5) formateurClass = 'formateur-orange';

        html += `<tr>
          <td rowspan="3" class="formateur-cell ${formateurClass}" data-formateur="${formateur}">
            <div class="formateur-content">
              <div class="formateur-name">${formateur}</div>
              <div class="formateur-hours" id="hours-${formateur}">${heures.toFixed(1)}</div>
            </div>
          </td>
          <td class="type-cell">Groupe</td>`;
        
        jours.forEach(jour => {
            seances.forEach(seance => {
                const session = formateurData[jour]?.[seance] || { groupe: '', module: '', salle: '' };
                const dayClass = dayClasses[jour];
                const isSelected = session.groupe ? 'selected-cell' : '';
                const isGroupOverloaded = session.groupe && groupHours[session.groupe] >= 40 ? 'group-highlight' : '';
                const isTeams = session.salle === 'TEAMS';
                const groupesPossibles = isTeams ? appData.fusionGroupes : appData.groupes;
                const typeAffection = isTeams ? 'synchrone' : 'presentiel';
                const groupesFiltres = groupesPossibles.filter(g => appData.affectations.some(a => a.formateur === formateur && a.groupe === g && a.type === typeAffection));
                html += `<td class="auto-resize-cell draggable-cell ${dayClass} ${isSelected} ${isGroupOverloaded}" draggable="true" data-type="groupe" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                  <select class="auto-resize-select" data-type="groupe" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                    <option value=""></option>
                    ${groupesFiltres.map(g => `<option value="${g}" ${g === session.groupe ? 'selected' : ''}>${g}</option>`).join('')}
                  </select>
                  <div class="drag-indicator"><i class="fas fa-arrows-alt"></i></div>
                </td>`;
            });
        });
        html += `</tr>`;
        
        html += `<tr><td class="type-cell">Module</td>`;
        jours.forEach(jour => {
            seances.forEach(seance => {
                const session = formateurData[jour]?.[seance] || { groupe: '', module: '', salle: '' };
                const dayClass = dayClasses[jour];
                const isModuleSelected = session.module ? 'selected-cell' : '';

                const semester = getModuleSemester(formateur, session.groupe, session.module);
                // Appel à la fonction corrigée pour déterminer si la classe doit être ajoutée
                const isRegional = isModuleRegional(formateur, session.groupe, session.module);
                const semesterClass = semester ? `module-${semester.toLowerCase()}` : '';
                const regionalClass = isRegional ? 'module-regional' : '';

                const modulesPossibles = new Map();
                if (session.groupe) {
                    const subGroups = session.groupe.trim().split(/\s+/).filter(Boolean);
                    appData.affectations.forEach(a => {
                        if (a.formateur === formateur && subGroups.includes(a.groupe)) {
                            const modSemester = getModuleSemester(formateur, a.groupe, a.module);
                            const modIsRegional = isModuleRegional(formateur, a.groupe, a.module);
                            if (modSemester) {
                                modulesPossibles.set(a.module, { semester: modSemester, isRegional: modIsRegional });
                            }
                        }
                    });
                }
                
                let moduleOptionsHTML = '';
                modulesPossibles.forEach((meta, mod) => {
                    moduleOptionsHTML += `<option value="${mod}" data-semester="${meta.semester}" data-regional="${meta.isRegional}" ${mod === session.module ? 'selected' : ''}>${mod}</option>`;
                });
                
                // La classe ${regionalClass} est maintenant ajoutée directement ici
                html += `<td class="auto-resize-cell ${dayClass} ${isModuleSelected} ${semesterClass} ${regionalClass}" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                  <select class="auto-resize-select" data-type="module" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}" ${!session.groupe ? 'disabled' : ''}>
                    <option value=""></option>
                    ${moduleOptionsHTML}
                  </select>
                </td>`;
            });
        });
        html += `</tr>`;

        html += `<tr class="salle-row"><td class="type-cell">Espace</td>`;
        jours.forEach(jour => {
            seances.forEach(seance => {
                const session = formateurData[jour]?.[seance] || { groupe: '', module: '', salle: '' };
                const dayClass = dayClasses[jour];
                const isSalleSelected = session.salle ? 'selected-cell' : '';
                html += `<td class="auto-resize-cell ${dayClass} ${isSalleSelected}" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                  <select class="auto-resize-select" data-type="salle" data-jour="${jour}" data-seance="${seance}" data-formateur="${formateur}">
                    <option value=""></option>
                    ${appData.espaces.map(e => `<option value="${e}" ${e === session.salle ? 'selected' : ''}>${e}</option>`).join('')}
                  </select>
                </td>`;
            });
        });
        html += `</tr>`;
    });
    
    tbody.innerHTML = html;
    document.querySelectorAll('.auto-resize-select').forEach(resizeTextToFit);
    Object.keys(groupHours).forEach(checkGroupHours);
    setupDragAndDrop();
}


    
    let dragSrcElement = null;
    function setupDragAndDrop() {
  const draggables = document.querySelectorAll('.draggable-cell');
  draggables.forEach(item => {
    item.addEventListener('dragstart', handleDragStart, false);
    // C'est cette ligne qui cause l'erreur car handleDragEnter n'est pas défini
    item.addEventListener('dragenter', handleDragEnter, false); 
    item.addEventListener('dragover', handleDragOver, false);
    item.addEventListener('dragleave', handleDragLeave, false);
    item.addEventListener('drop', handleDrop, false);
    item.addEventListener('dragend', handleDragEnd, false);
  });
}

    function handleDragEnter(e) {
  // 'this' est l'élément de la table sur lequel le curseur entre.
  // 'dragSrcElement' est l'élément que l'on est en train de glisser.
  
  // On vérifie que l'on ne dépose pas la séance sur un autre formateur.
  // Cette vérification ajoute de la robustesse.
  if (this.dataset.formateur === dragSrcElement.dataset.formateur) {
    this.classList.add('drop-target');
  }
}

    function handleDragStart(e) {
  dragSrcElement = this;
  const formateur = this.dataset.formateur;
  const jour = this.dataset.jour;
  const seance = this.dataset.seance;
  const sessionData = timetableData[formateur][jour][seance];

  // Si on essaie de glisser une cellule vide, on annule l'opération
  if (!sessionData || !sessionData.groupe) {
      e.preventDefault();
      return;
  }

  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', JSON.stringify({ formateur, jour, seance }));
  this.classList.add('dragging');

  // --- NOUVELLE LOGIQUE POUR METTRE EN ÉVIDENCE LES EMPLACEMENTS POSSIBLES ---
  
  // On récupère toutes les cellules "groupe" du formateur concerné
  const allTrainerCells = document.querySelectorAll(`td[data-formateur="${formateur}"][data-type="groupe"]`);

  allTrainerCells.forEach(cell => {
    const targetJour = cell.dataset.jour;
    const targetSeance = cell.dataset.seance;
    
    // On ne se compare pas à soi-même
    if (targetJour === jour && targetSeance === seance) return;
    
    // On récupère la séance qui se trouve actuellement dans la cellule cible
    const targetOriginalSession = timetableData[formateur][targetJour][targetSeance];

    // Vérification en deux temps pour un ÉCHANGE (swap) :
    // 1. Est-ce que la séance glissée peut aller dans la cellule cible sans conflit externe ?
    const canSourceMoveToTarget = isSlotAvailableForSession(targetJour, targetSeance, sessionData, formateur);

    // 2. Est-ce que la séance de la cellule cible peut aller dans la cellule d'origine sans conflit externe ?
    const canTargetMoveToSource = isSlotAvailableForSession(jour, seance, targetOriginalSession, formateur);

    // Si les deux conditions sont vraies, alors l'échange est possible
    if (canSourceMoveToTarget && canTargetMoveToSource) {
       // On trouve les 3 cellules correspondantes (groupe, module, salle) pour ce créneau cible
       const correspondingCells = document.querySelectorAll(`td[data-formateur="${formateur}"][data-jour="${targetJour}"][data-seance="${targetSeance}"]`);
       correspondingCells.forEach(c => c.classList.add('drop-possible'));
    }
  });
}

    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDragEnd(e) {
  // On nettoie toutes les classes temporaires de toute la table
  document.querySelectorAll('.dragging, .drop-target, .drop-possible').forEach(function (item) {
    item.classList.remove('dragging', 'drop-target', 'drop-possible');
  });
}

    function handleDragLeave(e) {
      this.classList.remove('drop-target');
    }

    // --- FONCTION : handleDrop ---
function handleDrop(e) {
    e.stopPropagation();
    
    // Vérifier que l'élément source et l'élément cible sont différents
    if (dragSrcElement === this) {
        return false;
    }

    // Récupérer les informations de la source et de la cible
    const sourceInfo = JSON.parse(e.dataTransfer.getData('text/plain'));
    const srcFormateur = sourceInfo.formateur;
    const srcJour = sourceInfo.jour;
    const srcSeance = sourceInfo.seance;

    const targetCell = this; // 'this' est l'élément cible (où on dépose)
    const targetFormateur = targetCell.dataset.formateur;
    const targetJour = targetCell.dataset.jour;
    const targetSeance = targetCell.dataset.seance;

    // Vérification de sécurité : empêcher le déplacement entre formateurs
    if (srcFormateur !== targetFormateur) {
        showNotification("Déplacement non autorisé entre formateurs.", "warning");
        return false;
    }

    // Récupérer les sessions source et cible
    const sourceSession = JSON.parse(JSON.stringify(timetableData[srcFormateur][srcJour][srcSeance]));
    const targetSession = JSON.parse(JSON.stringify(timetableData[targetFormateur][targetJour][targetSeance]));

    // Créer un timetable temporaire pour tester les conflits
    let tempTimetable = JSON.parse(JSON.stringify(timetableData));
    tempTimetable[srcFormateur][srcJour][srcSeance] = targetSession;
    tempTimetable[targetFormateur][targetJour][targetSeance] = sourceSession;

    // Vérifier les conflits pour la session source (dans son nouvel emplacement)
    const sourceConflict = checkSessionConflict(srcJour, srcSeance, targetSession, tempTimetable, { formateur: srcFormateur });
    if (sourceConflict) {
        showNotification(`Déplacement impossible: ${sourceConflict}`, "chevauchement");
        return false;
    }

    // Vérifier les conflits pour la session cible (dans son nouvel emplacement)
    const targetConflict = checkSessionConflict(targetJour, targetSeance, sourceSession, tempTimetable, { formateur: targetFormateur });
    if (targetConflict) {
        showNotification(`Déplacement impossible: ${targetConflict}`, "chevauchement");
        return false;
    }

    // Si tout est OK, effectuer le swap dans le modèle de données principal
    timetableData[srcFormateur][srcJour][srcSeance] = targetSession;
    timetableData[targetFormateur][targetJour][targetSeance] = sourceSession;

    // Afficher un message de succès
    showNotification("Session déplacée avec succès.", "success");

    // --- ACTION CRUCIALE : Re-rendre tout le tableau ---
    // Cela recrée tous les éléments HTML, y compris les <select>.
    // Le post-traitement dans renderTimetableFromData s'occupera de déclencher
    // handleModuleChange pour appliquer les styles.
    renderTimetableFromData(timetableData);
    // --- FIN ACTION CRUCIALE ---

    // Nettoyer les classes CSS de drag-and-drop (géré aussi par handleDragEnd)
    document.querySelectorAll('.dragging, .drop-target, .drop-possible').forEach(function (item) {
        item.classList.remove('dragging', 'drop-target', 'drop-possible');
    });

    return false;
}
// --- FIN FONCTION : handleDrop ---

    function checkSessionConflict(jour, seance, sessionToCheck, timetable, exclusion) {
        if (!sessionToCheck || !sessionToCheck.groupe) return null;
        const groupesToCheck = sessionToCheck.groupe.trim().split(/\s+/).filter(Boolean);
        const salleToCheck = sessionToCheck.salle;
        for (const formateur in timetable) {
            if (formateur === exclusion.formateur) continue;
            const otherSession = timetable[formateur][jour][seance];
            if (salleToCheck && salleToCheck !== 'TEAMS' && otherSession.salle === salleToCheck) {
                return `Conflit de salle pour "${salleToCheck}" avec le formateur ${formateur}.`;
            }
            if (otherSession.groupe) {
                const autresGroupes = otherSession.groupe.trim().split(/\s+/).filter(Boolean);
                if (groupesToCheck.some(g => autresGroupes.includes(g))) {
                    return `Conflit de groupe ("${sessionToCheck.groupe}") avec le formateur ${formateur}.`;
                }
            }
        }
        return null;
    }

    function handleDragEnd(e) {
      document.querySelectorAll('.draggable-cell').forEach(function (item) {
        item.classList.remove('dragging', 'drop-target');
      });
    }

    let clipboardConfiguration = null;
    
    function openAutoGenModal() {
    const container = document.getElementById('autoGenConstraintsContainer');

    // 1. Détection des années de formation
    const anneesFormation = [...new Set(appData.groupes.map(getAnneeFormation))]
        .filter(annee => annee !== 'N/A')
        .sort();

    // ========================================================================
    // == MODIFICATION : Nouveau style minimaliste pour les boutons          ==
    // ========================================================================
    let tauxHtml = '';
    if (anneesFormation.length > 0) {
        tauxHtml = `
            <div style="margin-top: 0px;">
                <h4 style="margin-top:0; margin-bottom: 8px; color: #2c3e50; font-weight: 600;">
                    <i class="fas fa-percentage"></i> Répartition par Niveau
                </h4>
                <div id="tauxContainer" style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center; padding: 8px; border-radius: 8px;">
                    ${anneesFormation.map(annee => `
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="taux-${annee}" style="font-weight: 500; color: #34495e; min-width: auto;">
                                ${annee} :
                            </label>
                            <div style="position: relative;">
                                <input type="number" id="taux-${annee}" class="taux-input" min="0" max="100" 
                                       value="${annee === '1A' ? 100 : 0}" data-annee="${annee}" 
                                       style="width: 80px; height: 30px; padding: 9px 12px; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 1rem; background: #f8fafc; transition: all 0.3s;">
                                <span style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); font-weight: bold; color: #7f8c8d; pointer-events: none;">%</span>
                            </div>
                        </div>
                    `).join('')}
                    <div id="tauxTotal" style="margin-left: auto; text-align: right; font-weight: 700; font-size: 1.1rem; transition: color 0.3s; color: #27ae60;">
                      Total : <span id="tauxTotalValue">100</span>%
                    </div>
                </div>
            </div>
        `;
    }
        
    const bulkEditPanelHTML = `
        <div id="bulkEditPanel" style="padding: 15px; background-color: #f8fafc; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">

          
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 25px;">
                
                <!-- Colonne de gauche: Heures, TEAMS, Espaces -->
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <!-- Organisation horizontale -->
                    <div style="display: flex; gap: 20px; margin-bottom: 0px;">
                        <!-- Heures/Semaine -->
                        <div style="flex: 1;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">
                                <i class="fas fa-clock"></i> Heures/Semaine
                            </label>
                            <div style="display: flex; gap: 8px;">
                                <input type="number" id="bulkHours" value="25" 
                                       style="flex: 1; height: 35px; padding: 10px 12px; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 1rem; background: #ffffff;">
                                <button data-action="apply-hours" class="btn-primary" style="padding: 10px 16px; height: 35px;">
                                    <i class="fas fa-check"></i>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Sessions TEAMS -->
                        <div style="flex: 1;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">
                                <i class="fas fa-video"></i> Sessions TEAMS
                            </label>
                            <div style="display: flex; gap: 8px;">
                                <input type="number" id="bulkTeams" value="0" 
                                       style="flex: 1; height: 35px; padding: 10px 12px; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 1rem; background: #ffffff;">
                                <button data-action="apply-teams" class="btn-primary" style="padding: 10px 16px; height: 35px;">
                                    <i class="fas fa-check"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    ${tauxHtml}

                    <div style="margin-top: 0px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">
                            <i class="fas fa-map-marker-alt"></i> Gérer les Espaces
                        </label>
                        <div style="display: flex; gap: 8px;">
                            <select id="bulkSpaceSelect" style="flex: 1; height: 35px; padding: 7px 10px; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 1rem; background: #ffffff;">
                                ${appData.espaces.map(e => `<option value="${e}">${e}</option>`).join('')}
                            </select>
                            <button data-action="add-space" class="btn-success" style="padding: 10px 16px; height: 35px;">
                                <i class="fas fa-plus"></i>
                            </button>
                            <button data-action="remove-space" class="btn-danger" style="padding: 10px 16px; height: 35px;">
                                <i class="fas fa-minus"></i>
                            </button>
                        </div>
                    </div>

                    <h4 style="margin-top: 0px; margin-bottom: -8px; color: #2c3e50; font-weight: 600;">
                        <i class="fas fa-filter"></i> Forcer les Modules par Semestre
                    </h4>
                    <div id="semesterFilterContainer" style="display: flex; gap: 20px; align-items: center; padding: 5px; padding-left: 10px; border-radius: 8px;">
                        <label class="flex items-center gap-2 cursor-pointer" style="font-weight: 500;">
                            <input type="checkbox" id="forceS1" class="semester-checkbox h-5 w-5 rounded border-gray-300 text-blue-600" checked>
                            <span class="font-semibold" style="color: #3498db;">Semestre 1</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer" style="font-weight: 500;">
                            <input type="checkbox" id="forceS2" class="semester-checkbox h-5 w-5 rounded border-gray-300 text-green-600" checked>
                            <span class="font-semibold" style="color: #27ae60;">Semestre 2</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer" style="font-weight: 500;">
                            <input type="checkbox" id="forceAnnual" class="semester-checkbox h-5 w-5 rounded border-gray-300 text-orange-600" checked>
                            <span class="font-semibold" style="color: #e67e22;">Annuels</span>
                        </label>
                    </div>
                </div>

                <!-- Colonne de droite: Grille de sélection des indisponibilités -->
                <div>
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">
                        <i class="fas fa-calendar-times"></i> Gérer les Indisponibilités
                    </label>
                    <div style="color: #7f8c8d; font-size: 0.9rem; margin-bottom: 10px;">
                        Cliquez-glissez pour sélectionner
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 5px;">
                        <!-- === GRILLE DE SÉLECTION INVERSÉE === -->
                        <table id="bulkAvailabilityGrid" class="availability-grid-style">
                            <thead>
                                <tr>
                                    <th></th> <!-- Coin vide -->
                                    ${seances.map(s => `<th style="padding: 8px 10px; background: #f8fafc;">${s}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                ${jours.map(j => `
                                    <tr>
                                        <th style="padding: 8px 10px; background: #f8fafc;">${j}</th>
                                        ${seances.map(s => `<td class="bulk-slot" data-jour="${j}" data-seance="${s}"></td>`).join('')}
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                        <div style="display: flex; flex-direction: column; gap: 8px; justify-content: center;">
                            <button data-action="block-availability" class="btn-danger" style="padding: 10px 16px;">
                                <i class="fas fa-ban"></i> Bloquer
                            </button>
                            <button data-action="unblock-availability" class="btn-success" style="padding: 10px 16px;">
                                <i class="fas fa-check-circle"></i> Débloquer
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px; padding-top: 10px; border-top: 1px solid #e2e8f0;">
            <div id="bulkSelectionInfo" style="font-weight: 500; color: #333; font-size: 1.05rem;">Aucun formateur sélectionné.</div>
            <button id="invertSelectionBtn" class="btn-secondary" style="padding: 8px 16px; width: 177px !important; white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;">
    <i class="fas fa-exchange-alt"></i> Inverser la sélection
</button>


        </div>
        </div>
        <style>
            /* NOUVEAU STYLE DES BOUTONS - MINIMALISTE */
            .btn-primary, .btn-secondary, .btn-success, .btn-danger {
                border: none;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-weight: 500;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                background: transparent;
                border: 1px solid #d1d5db;
                color: #374151;
                box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            }
            
            .btn-primary {
                border-color: #3b82f6;
                color: #3b82f6;
            }
            
            .btn-secondary {
                border-color: #6b7280;
                color: #6b7280;
            }
            
            .btn-success {
                border-color: #10b981;
                color: #10b981;
            }
            
            .btn-danger {
                border-color: #ef4444;
                color: #ef4444;
            }
            
            .btn-primary:hover, .btn-secondary:hover, .btn-success:hover, .btn-danger:hover {
                background-color: #f9fafb;
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            }
            
            .btn-primary:active, .btn-secondary:active, .btn-success:active, .btn-danger:active {
                transform: translateY(0);
                box-shadow: none;
            }
            
            .btn-primary i, .btn-secondary i, .btn-success i, .btn-danger i {
                font-size: 0.9rem;
            }

            /* Autres styles */
            #autoGenModal {
                display: none;
                position: fixed;
                z-index: 1050;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0,0,0,0.5);
            }

            .modal-container {
                background-color: #fefefe;
                margin: 5% auto;
                padding: 30px;
                border-radius: 12px;
                box-shadow: 0 5px 30px rgba(0, 0, 0, 0.1);
                width: 90%;
                max-width: 1200px;
                position: relative;
                max-height: 85vh;
                overflow-y: auto;
                border: none;
            }

            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 1px solid #eaeaea;
                padding-bottom: 15px;
                margin-bottom: 20px;
            }

            .modal-title {
                font-size: 1.8rem;
                color: #2c3e50;
                font-weight: 600;
            }

            .close-modal {
                background: none;
                border: none;
                font-size: 1.8rem;
                cursor: pointer;
                color: #7f8c8d;
                transition: color 0.2s;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .close-modal:hover {
                background-color: #f5f5f5;
                color: #e74c3c;
            }

            /* Configuration de masse */
            .bulk-config-section {
                background-color: #f8faff;
                border-radius: 10px;
                padding: 20px;
                margin-bottom: 25px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            }

            .section-title {
                font-size: 1.4rem;
                color: #3498db;
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .section-title i {
                font-size: 1.2rem;
            }

            .bulk-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                gap: 25px;
            }

            .bulk-control-group {
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            }

            .bulk-control-group h4 {
                margin-top: 0;
                margin-bottom: 15px;
                color: #2c3e50;
                font-size: 1.1rem;
            }

            .control-row {
                display: flex;
                gap: 10px;
                margin-bottom: 10px;
                align-items: center;
            }

            .control-row label {
                min-width: 120px;
                font-weight: 500;
            }

            .bulk-input {
                flex: 1;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 6px;
                font-size: 1rem;
                transition: border-color 0.3s;
            }

            .bulk-input:focus {
                border-color: #3498db;
                outline: none;
                box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
            }

            /* Tableau de sélection en masse */
            .bulk-availability-container {
                margin-top: 10px;
            }

            .availability-grid-style {
                border-collapse: collapse;
                width: 100%;
                user-select: none;
            }

            .availability-grid-style th {
                background-color: #f2f6fc;
                padding: 6px;
                font-size: 0.85rem;
                font-weight: 600;
                color: #2c3e50;
                border: 1px solid #e0e0e0;
            }

            .availability-grid-style td {
                border: 1px solid #e0e0e0;
                text-align: center;
                padding: 0;
                background-color: white;
                transition: background-color 0.2s;
            }

            #bulkAvailabilityGrid th {
                padding: 10px 8px;
            }
            
            #bulkEditPanel {
                margin-bottom: 15px;
            }

            .constraints-table thead {
                position: sticky;
                top: 0;
                z-index: 10;
                background-color: #f8faff;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            }

            #bulkAvailabilityGrid td {
                width: 50px;
                height: 20px;
                cursor: pointer;
                position: relative;
            }

            #bulkAvailabilityGrid td:after {
                content: "";
                position: absolute;
                top: 50%;
                left: 50%;
                width: 20px;
                height: 20px;
                border-radius: 4px;
                background: #e3f2fd;
                transform: translate(-50%, -50%);
                transition: all 0.2s;
            }

            #bulkAvailabilityGrid td.selected:after {
                background: #3498db;
                width: 24px;
                height: 24px;
            }

            #bulkAvailabilityGrid td:hover:after {
                background: #bbdefb;
            }

            .formateurs-list {
                background-color: white;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            }

            .constraints-table {
                width: 100%;
                border-collapse: collapse;
                font-size: 0.95rem;
            }

            .constraints-table td {
                padding: 12px 15px;
                border-bottom: 1px solid #f0f0f0;
                vertical-align: middle;
            }

            .constraints-table tr:last-child td {
                border-bottom: none;
            }

            .constraints-table tr:hover td {
                background-color: #f9fbfe;
            }

            .formateur-name-col {
                font-weight: 600;
                min-width: 150px;
            }

            .tags-container {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                padding: 5px;
                min-height: 40px;
            }

            .space-tag {
                background: #e0f2fe;
                color: #0369a1;
                padding: 5px 12px;
                border-radius: 20px;
                font-size: 0.85rem;
                display: inline-flex;
                align-items: center;
                gap: 5px;
            }

            .remove-tag {
                background: none;
                border: none;
                color: #0369a1;
                cursor: pointer;
                font-weight: bold;
                font-size: 1rem;
                padding: 0;
                line-height: 1;
                margin-left: 5px;
                opacity: 0.7;
                transition: opacity 0.2s;
            }

            .remove-tag:hover {
                opacity: 1;
            }

            .mini-grid-container {
                padding: 5px 0;
            }

            .availability-mini-grid {
                border-collapse: collapse;
                width: 100%;
            }

            .availability-mini-grid th {
                padding: 3px 5px;
                font-weight: normal;
                font-size: 0.7rem;
                color: #7f8c8d;
            }

            .availability-mini-grid td {
                width: 20px;
                height: 10px;
                border-radius: 3px;
                cursor: pointer;
                background-color: #d5f5e3;
                position: relative;
                transition: all 0.2s;
            }

            .availability-mini-grid td:after {
                content: "";
                position: absolute;
                top: 50%;
                left: 50%;
                width: 12px;
                height: 12px;
                border-radius: 2px;
                background: #27ae60;
                transform: translate(-50%, -50%);
                transition: all 0.2s;
            }

            .availability-mini-grid td.unavailable:after {
                background: #e74c3c;
            }

            .availability-mini-grid td:hover:after {
                transform: translate(-50%, -50%) scale(1.2);
            }

            .modal-footer {
                display: flex;
                justify-content: flex-end;
                margin-top: 25px;
                padding-top: 20px;
                border-top: 1px solid #eee;
            }

            #runAutoGenerateBtn {
                padding: 12px 25px;
                font-size: 1.1rem;
                font-weight: 600;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                background: #10b981;
                color: white;
                display: flex;
                align-items: center;
                gap: 10px;
                transition: all 0.3s ease;
            }

            #runAutoGenerateBtn:hover {
                background: #059669;
                transform: translateY(-2px);
            }

            .selected-row {
                background-color: #f0f7ff !important;
                position: relative;
            }

            .selected-row:after {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 4px;
                height: 100%;
                background: #3498db;
            }

            @media (max-width: 900px) {
                .modal-container {
                    width: 95%;
                    padding: 20px;
                }
                
                .bulk-grid {
                    grid-template-columns: 1fr;
                }
                
                .constraints-table {
                    display: block;
                    overflow-x: auto;
                }
            }

            @media (max-width: 600px) {
                .control-row {
                    flex-direction: column;
                    align-items: flex-start;
                }
                
                .control-row label {
                    margin-bottom: 5px;
                }
                
                #tauxContainer {
                    flex-direction: column;
                    align-items: flex-start;
                    gap: 8px;
                }
            }

            .bulk-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                gap: 25px;
            }
            .taux-total-warning {
                color: #e74c3c !important;
            }

            /* Styles améliorés pour les inputs */
            .taux-input, #bulkHours, #bulkTeams, #bulkSpaceSelect {
                transition: all 0.3s ease;
                outline: none;
            }
            
            .taux-input:focus, #bulkHours:focus, #bulkTeams:focus, #bulkSpaceSelect:focus {
                border-color: #3498db !important;
                box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1) !important;
            }
            
            /* Style pour les labels */
            label {
                font-weight: 500;
                color: #2c3e50;
                transition: color 0.3s;
            }
            
            /* Style pour les en-têtes */
            h4 {
                color: #2c3e50;
                font-weight: 600;
                margin-bottom: 10px;
            }
        </style>
    `;

    let tableHTML = `
        <table class="constraints-table">
            <thead>
                <tr>
                    <th style="width: 20px;"><input type="checkbox" id="selectAllFormateurs"></th>
                    <th>Formateur</th>
                    <th>Heures/Sem.</th>
                    <th>Sessions TEAMS</th>
                    <th>Espaces Autorisés</th>
                    <th style="width: 220px;">Indisponibilités</th>
                </tr>
            </thead>
            <tbody>`;

    appData.formateurs.forEach(formateur => {
        tableHTML += `<tr data-formateur="${formateur}">
            <td><input type="checkbox" class="formateur-select-checkbox"></td>
            <td class="formateur-name-col">${formateur}</td>
            <td><input type="number" class="formateur-hours" value="25"></td>
            <td><input type="number" class="formateur-teams-sessions" value="0"></td>
            <td><div class="tags-container assigned-spaces-container"></div></td>
            
            <td>
                <table class="availability-grid-style availability-mini-grid">
                    
                    <tbody>
                        ${jours.map(j => `
                            <tr>
                                <th>${j.substring(0,3)}</th>
                                ${seances.map(s => `<td class="mini-slot" data-jour="${j}" data-seance="${s}" title="${j} ${s}"></td>`).join('')}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </td>
        </tr>`;
    });

    tableHTML += `</tbody></table>`;
    
    const modalContentWrapper = container.parentElement;

    const existingPanel = modalContentWrapper.querySelector('#bulkEditPanel');
    if (existingPanel) {
        existingPanel.remove();
    }
    
    container.insertAdjacentHTML('beforebegin', bulkEditPanelHTML);
    
    container.innerHTML = tableHTML;

    document.getElementById('autoGenModal').style.display = 'block';

    try {
        const savedConfigJSON = localStorage.getItem('autoGenConfig_v1');
        if (savedConfigJSON) {
            const savedConfig = JSON.parse(savedConfigJSON);
            document.querySelectorAll('#autoGenConstraintsContainer tr[data-formateur]').forEach(row => {
                const formateur = row.dataset.formateur;
                if (savedConfig[formateur]) {
                    const config = savedConfig[formateur];
                    
                    // Appliquer les valeurs
                    row.querySelector('.formateur-hours').value = config.hours || 25;
                    row.querySelector('.formateur-teams-sessions').value = config.teamsSessions || 0;
                    
                    // Appliquer les espaces autorisés
                    const spacesContainer = row.querySelector('.assigned-spaces-container');
                    spacesContainer.innerHTML = ''; // Vider les anciens
                    if(config.spaces && Array.isArray(config.spaces)) {
                       config.spaces.forEach(space => addSpaceTag(row, space));
                    }
                    
                    // Appliquer les indisponibilités
                    if(config.unavailable && Array.isArray(config.unavailable)) {
                        config.unavailable.forEach(slot => {
                            const miniSlot = row.querySelector(`.mini-slot[data-jour="${slot.jour}"][data-seance="${slot.seance}"]`);
                            if (miniSlot) miniSlot.classList.add('unavailable');
                        });
                    }
                }
            });
            showNotification("Dernière configuration chargée.", "info");
        }
    } catch(e) {
        console.error("Erreur lors du chargement de la configuration sauvegardée:", e);
        localStorage.removeItem('autoGenConfig_v1'); // Nettoyer en cas d'erreur de parsing
    }

    setupBulkEventListeners();
}

    function updateSelectionInfo() {
    const infoPanel = document.getElementById('bulkSelectionInfo');
    const selectedRows = document.querySelectorAll('#autoGenConstraintsContainer tr.selected-row');
    const count = selectedRows.length;

    if (count === 0) {
        infoPanel.textContent = 'Aucun formateur sélectionné.';
    } else {
        const names = Array.from(selectedRows).map(row => row.dataset.formateur);
        let text = `<strong>${count} formateur(s) sélectionné(s) :</strong> `;
        // Pour éviter une liste trop longue, on limite l'affichage
        if (names.length > 5) {
            text += names.slice(0, 5).join(', ') + ` et ${names.length - 5} autre(s)...`;
        } else {
            text += names.join(', ');
        }
        infoPanel.innerHTML = text;
    }
}

/**
 * Détermine l'année de formation (1A, 2A, 3A) à partir du nom d'un groupe.
 * Se base sur les 3 derniers caractères du nom.
 * @param {string} groupe - Le nom du groupe (ex: "TDI101", "DEV201").
 * @returns {string} - L'année de formation ('1A', '2A', '3A') ou 'N/A' si non identifiable.
 */
 function getAnneeFormation(groupe) {
  // Vérifie si l'entrée est valide
  if (!groupe || typeof groupe !== 'string' || groupe.length < 3) {
    return 'N/A'; // Non applicable
  }

  // Extrait les 3 derniers caractères et les convertit en nombre
  const codeAnnee = parseInt(groupe.slice(-3), 10);

  // Vérifie si la conversion a réussi
  if (isNaN(codeAnnee)) {
    return 'N/A';
  }

  // Applique la logique pour déterminer l'année
  if (codeAnnee >= 100 && codeAnnee < 200) {
    return '1A';
  } else if (codeAnnee >= 200 && codeAnnee < 300) {
    return '2A';
  } else if (codeAnnee >= 300 && codeAnnee < 400) {
    return '3A';
  } else {
    return 'Autre'; // Pour les cas non prévus
  }
}

function updateTauxTotal() {
    const tauxInputs = document.querySelectorAll('.taux-input');
    let total = 0;
    tauxInputs.forEach(input => {
        total += parseFloat(input.value) || 0;
    });

    const totalValueElement = document.getElementById('tauxTotalValue');
    const totalContainerElement = document.getElementById('tauxTotal');
    
    totalValueElement.textContent = total.toFixed(0);

    if (total.toFixed(0) !== '100') {
        totalContainerElement.classList.add('taux-total-warning');
    } else {
        totalContainerElement.classList.remove('taux-total-warning');
    }
}

    /**
     * MODIFICATION de setupBulkEventListeners
     * Ajoute la logique pour gérer les étiquettes et la suppression individuelle.
     */
    /**
 * Attache tous les écouteurs d'événements pour la modale de configuration en masse.
 * Gère la sélection des formateurs, le calendrier interactif et les boutons d'action.
 */
 function setupBulkEventListeners() {
    const modal = document.getElementById('autoGenModal');
    if (!modal) return;

    // --- Helper pour récupérer les lignes sélectionnées ---
    const getSelectedRows = () => {
        return [...modal.querySelectorAll('.formateur-select-checkbox:checked')]
            .map(checkbox => checkbox.closest('tr'));
    };

    // --- Helper pour mettre à jour l'affichage de la sélection ---
    // --- Helper pour mettre à jour l'affichage de la sélection (VERSION AMÉLIORÉE) ---
// --- Helper pour mettre à jour l'affichage de la sélection (LIMITE À 10 NOMS) ---
// --- Helper pour mettre à jour l'affichage de la sélection (AVEC COMPTEUR SÉLECTION/TOTAL) ---
const updateSelectionInfo = () => {
    const selectedRows = getSelectedRows();
    const selectedCount = selectedRows.length;
    // On compte le nombre total de checkboxes pour avoir le total de formateurs
    const totalCount = modal.querySelectorAll('.formateur-select-checkbox').length;
    const infoDiv = document.getElementById('bulkSelectionInfo');
    const selectAllCheckbox = document.getElementById('selectAllFormateurs');

    // 1. On construit la partie du texte qui indique le compteur (ex: "(5 / 20)")
    const counterText = `(${selectedCount} / ${totalCount})`;

    // 2. On met à jour le message principal
    if (selectedCount === 0) {
        infoDiv.textContent = `Aucun formateur sélectionné ${counterText}`;
    } else {
        const selectedNames = selectedRows.map(row => {
            return row.querySelector('.formateur-name-col').textContent.trim();
        });

        const DISPLAY_LIMIT = 100; // On garde la limite de 10 noms
        let namesList;

        if (selectedCount <= DISPLAY_LIMIT) {
            // Si la sélection est sous la limite, on affiche tous les noms
            namesList = selectedNames.join(', ');
        } else {
            // Sinon, on affiche les premiers noms et un compteur pour le reste
            const firstNames = selectedNames.slice(0, DISPLAY_LIMIT).join(', ');
            const remainingCount = selectedCount - DISPLAY_LIMIT;
            namesList = `${firstNames} et ${remainingCount} autre(s)`;
        }
        
        // 3. On combine la liste des noms avec le compteur à la fin
        infoDiv.textContent = `Sélection : ${namesList} ${counterText}`;
    }
    
    // Le reste de la logique pour les checkboxes et le style des lignes reste identique
    selectAllCheckbox.checked = selectedCount > 0 && selectedCount === totalCount;
    selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < totalCount;

    modal.querySelectorAll('tr[data-formateur]').forEach(row => {
        const checkbox = row.querySelector('.formateur-select-checkbox');
        if (checkbox && checkbox.checked) {
            row.classList.add('selected-row');
        } else {
            row.classList.remove('selected-row');
        }
    });
};

    // --- Gestionnaire de clics principal (délégation d'événements) ---
    modal.addEventListener('click', (event) => {
        const actionTarget = event.target.closest('[data-action]');
        if (!actionTarget) return;

        const action = actionTarget.dataset.action;
        const selectedRows = getSelectedRows();

        if (selectedRows.length === 0 && !['add-space', 'remove-space', 'block-availability', 'unblock-availability'].includes(action)) {
            // Certaines actions pourraient s'appliquer même sans sélection, mais la plupart en ont besoin
            // showNotification("Veuillez d'abord sélectionner au moins un formateur.", "warning");
            // return;
        }

        switch (action) {
            case 'apply-hours': {
                const hours = document.getElementById('bulkHours').value;
                selectedRows.forEach(row => {
                    row.querySelector('.formateur-hours').value = hours;
                });
                if(selectedRows.length > 0) showNotification(`Heures mises à jour à ${hours} pour ${selectedRows.length} formateur(s).`, 'success');
                break;
            }
            
            case 'apply-teams': {
                const teams = document.getElementById('bulkTeams').value;
                selectedRows.forEach(row => {
                    row.querySelector('.formateur-teams-sessions').value = teams;
                });
                if(selectedRows.length > 0) showNotification(`Sessions TEAMS mises à jour à ${teams} pour ${selectedRows.length} formateur(s).`, 'success');
                break;
            }

            case 'add-space': {
                const space = document.getElementById('bulkSpaceSelect').value;
                selectedRows.forEach(row => addSpaceTag(row, space));
                if(selectedRows.length > 0) showNotification(`Espace "${space}" ajouté pour ${selectedRows.length} formateur(s).`, 'success');
                break;
            }

            case 'remove-space': {
                const space = document.getElementById('bulkSpaceSelect').value;
                selectedRows.forEach(row => {
                    const tagToRemove = row.querySelector(`.space-tag[data-space="${space}"]`);
                    if (tagToRemove) tagToRemove.remove();
                });
                if(selectedRows.length > 0) showNotification(`Espace "${space}" retiré pour ${selectedRows.length} formateur(s).`, 'success');
                break;
            }
            
            case 'remove-specific-space': {
                // Gère le clic sur la petite croix d'un tag
                event.target.closest('.space-tag').remove();
                break;
            }

            case 'block-availability': {
                const slotsToBlock = modal.querySelectorAll('#bulkAvailabilityGrid td.selected');
                selectedRows.forEach(row => {
                    slotsToBlock.forEach(slot => {
                        const { jour, seance } = slot.dataset;
                        const miniSlot = row.querySelector(`.mini-slot[data-jour="${jour}"][data-seance="${seance}"]`);
                        if(miniSlot) miniSlot.classList.add('unavailable');
                    });
                });
                if(selectedRows.length > 0) showNotification(`Indisponibilités appliquées à ${selectedRows.length} formateur(s).`, 'success');
                break;
            }

            case 'unblock-availability': {
                const slotsToUnblock = modal.querySelectorAll('#bulkAvailabilityGrid td.selected');
                 selectedRows.forEach(row => {
                    slotsToUnblock.forEach(slot => {
                        const { jour, seance } = slot.dataset;
                        const miniSlot = row.querySelector(`.mini-slot[data-jour="${jour}"][data-seance="${seance}"]`);
                        if(miniSlot) miniSlot.classList.remove('unavailable');
                    });
                });
                if(selectedRows.length > 0) showNotification(`Disponibilités restaurées pour ${selectedRows.length} formateur(s).`, 'success');
                break;
            }
        }
    });
    
    // --- Gestion de la sélection des formateurs ---
    modal.addEventListener('change', (event) => {
        // Clic sur une case à cocher individuelle
        if (event.target.classList.contains('formateur-select-checkbox')) {
            updateSelectionInfo();
        }

        // Clic sur la case "Tout sélectionner"
        if (event.target.id === 'selectAllFormateurs') {
            const isChecked = event.target.checked;
            modal.querySelectorAll('.formateur-select-checkbox').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
            updateSelectionInfo();
        }
    });

    // --- Bouton Inverser la sélection ---
    const invertBtn = document.getElementById('invertSelectionBtn');
    if(invertBtn) {
        invertBtn.addEventListener('click', () => {
            modal.querySelectorAll('.formateur-select-checkbox').forEach(checkbox => {
                checkbox.checked = !checkbox.checked;
            });
            updateSelectionInfo();
        });
    }

    // --- Gestion du total des pourcentages ---
    const tauxContainer = document.getElementById('tauxContainer');
    if (tauxContainer) {
        tauxContainer.addEventListener('input', (event) => {
            if (event.target.classList.contains('taux-input')) {
                const inputs = [...tauxContainer.querySelectorAll('.taux-input')];
                const total = inputs.reduce((sum, input) => sum + (parseInt(input.value, 10) || 0), 0);
                
                const totalValueEl = document.getElementById('tauxTotalValue');
                const totalContainer = document.getElementById('tauxTotal');
                totalValueEl.textContent = total;
                
                if (total !== 100) {
                    totalContainer.classList.add('taux-total-warning');
                } else {
                    totalContainer.classList.remove('taux-total-warning');
                }
            }
        });
    }

    // --- Logique de sélection par glisser-déposer sur la grille principale ---
    const grid = document.getElementById('bulkAvailabilityGrid');
    if (grid) {
        let isMouseDown = false;
        
        grid.addEventListener('mousedown', (event) => {
            if (event.target.tagName === 'TD') {
                isMouseDown = true;
                event.target.classList.toggle('selected');
                event.preventDefault(); // Empêche la sélection de texte
            }
        });

        grid.addEventListener('mouseover', (event) => {
            if (isMouseDown && event.target.tagName === 'TD') {
                // Pour basculer, il faut se souvenir de l'état initial
                // Pour simplement sélectionner, la ligne ci-dessous suffit
                event.target.classList.add('selected');
            }
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
    }
    
    // Initialiser l'affichage
    updateSelectionInfo();
}

function addSpaceTag(row, space) {
    const container = row.querySelector('.assigned-spaces-container');
    if (!container) return;

    // Éviter les doublons
    const existing = container.querySelector(`.space-tag[data-space="${space}"]`);
    if (existing) return;

    const tag = document.createElement('span');
    tag.className = 'space-tag';
    tag.dataset.space = space;
    tag.innerHTML = `
        ${space}
        <button class="remove-tag" data-action="remove-specific-space" title="Retirer cet espace">×</button>
    `;
    container.appendChild(tag);
}

function removeSpaceTag(row, space) {
    const container = row.querySelector('.assigned-spaces-container');
    if (!container) return; // Sécurité

    const tagToRemove = container.querySelector(`.space-tag[data-space="${space}"]`);
    if (tagToRemove) {
        tagToRemove.remove(); // Supprime l'élément du DOM
    }
}

    /**
     * Fonction générique pour appliquer une modification à toutes les lignes sélectionnées.
     * @param {function(HTMLTableRowElement): void} action - La fonction à exécuter pour chaque ligne.
     */
    function applyBulkChange(action) {
        const selectedRows = document.querySelectorAll('#autoGenConstraintsContainer tr.selected-row');
        if (selectedRows.length === 0) {
            showNotification("Veuillez sélectionner au moins un formateur.", "warning");
            return;
        }
        selectedRows.forEach(action);
        showNotification(`${selectedRows.length} formateur(s) mis à jour.`, "success");
    }

    /**
     * Gère le blocage/déblocage des créneaux en masse.
     * @param {string} selection - Le créneau sélectionné (ex: 'Lundi', 'morning', 'all').
     * @param {boolean} shouldBeChecked - True pour bloquer, false pour débloquer.
     */
     function applyAvailabilityChange(shouldBlock) {
        const modal = document.getElementById('autoGenModal');
        const selectedBulkSlots = modal.querySelectorAll('#bulkAvailabilityGrid .bulk-slot.selected');
        const selectedRows = modal.querySelectorAll('tr.selected-row');

        if (selectedRows.length === 0) {
            showNotification("Veuillez sélectionner au moins un formateur.", "warning");
            return;
        }
        if (selectedBulkSlots.length === 0) {
            showNotification("Veuillez sélectionner des créneaux dans la grille.", "warning");
            return;
        }

        selectedRows.forEach(row => {
            selectedBulkSlots.forEach(slot => {
                const { jour, seance } = slot.dataset;
                const miniSlot = row.querySelector(`.mini-slot[data-jour="${jour}"][data-seance="${seance}"]`);
                if (miniSlot) {
                    miniSlot.classList.toggle('unavailable', shouldBlock);
                }
            });
        });
        
        // Nettoyer la sélection de la grille en masse après l'opération
        selectedBulkSlots.forEach(slot => slot.classList.remove('selected'));
        
        showNotification(`${selectedRows.length} formateur(s) mis à jour.`, "success");
    }


    function addUnavailabilityTag(row, jour, seance) {
        const container = row.querySelector('.assigned-unavailabilities-container');
        const alreadyExists = container.querySelector(`.unavailability-tag[data-jour="${jour}"][data-seance="${seance}"]`);
        if (!alreadyExists) {
            const tagHTML = `<span class="tag unavailability-tag" data-jour="${jour}" data-seance="${seance}">
                                ${jour.substring(0,3)} ${seance}
                                <button class="remove-tag">×</button>
                             </span>`;
            container.insertAdjacentHTML('beforeend', tagHTML);
        }
    }

    /** Supprime une étiquette d'indisponibilité. */
    function removeUnavailabilityTag(row, jour, seance) {
        const tag = row.querySelector(`.unavailability-tag[data-jour="${jour}"][data-seance="${seance}"]`);
        if (tag) tag.remove();
    }

    function setupModalEventListeners() {
        const container = document.getElementById('autoGenConstraintsContainer');

        // Actions globales
        document.getElementById('applyAllBtn')?.addEventListener('click', applyFirstRowToAll);
        document.getElementById('resetAllBtn')?.addEventListener('click', resetAllConfigurations);
        
        // Utilisation de la délégation d'événements pour les boutons dans le tableau
        container.addEventListener('click', (e) => {
            const target = e.target;
            const row = target.closest('tr');
            if (!row) return;

            // Boutons d'action par ligne
            if (target.matches('.btn-copy-config')) copyConfig(row);
            if (target.matches('.btn-paste-config')) pasteConfig(row);
            if (target.matches('.btn-reset-config')) resetConfig(row);
            
            // Boutons de disponibilité
            if (target.matches('.availability-controls button')) {
                const action = target.dataset.action;
                if (action === 'toggle-day') {
                    toggleDayAvailability(row, target.dataset.day);
                } else if (action === 'toggle-period') {
                    togglePeriodAvailability(row, target.dataset.period);
                }
            }

            // Bouton "Tout/Rien" pour les espaces
            if(target.matches('.btn-toggle-all-spaces')) {
                const spacesContainer = row.querySelector('.spaces-checkbox-container');
                const allCheckboxes = spacesContainer.querySelectorAll('input[type="checkbox"]');
                const isAnyChecked = Array.from(allCheckboxes).some(cb => cb.checked);
                allCheckboxes.forEach(cb => cb.checked = !isAnyChecked);
            }
        });
    }

    function getConfigFromRow(row) {
        const hours = row.querySelector('.formateur-hours').value;
        const teamsSessions = row.querySelector('.formateur-teams-sessions').value;
        const spaces = Array.from(row.querySelectorAll('.space-checkbox:checked')).map(cb => cb.value);
        const unavailable = Array.from(row.querySelectorAll('.availability-checkbox:checked')).map(cb => ({
            jour: cb.dataset.jour,
            seance: cb.dataset.seance
        }));
        return { hours, teamsSessions, spaces, unavailable };
    }

    function applyConfigToRow(row, config) {
        row.querySelector('.formateur-hours').value = config.hours;
        row.querySelector('.formateur-teams-sessions').value = config.teamsSessions;
        row.querySelectorAll('.space-checkbox').forEach(cb => cb.checked = config.spaces.includes(cb.value));
        row.querySelectorAll('.availability-checkbox').forEach(cb => {
            cb.checked = config.unavailable.some(u => u.jour === cb.dataset.jour && u.seance === cb.dataset.seance);
        });
    }

    function copyConfig(row) {
        clipboardConfiguration = getConfigFromRow(row);
        showNotification(`Configuration de ${row.dataset.formateur} copiée.`, 'info');
    }

    function pasteConfig(row) {
        if (clipboardConfiguration) {
            applyConfigToRow(row, clipboardConfiguration);
            showNotification(`Configuration collée sur ${row.dataset.formateur}.`, 'success');
        } else {
            showNotification('Aucune configuration dans le presse-papiers.', 'warning');
        }
    }

    function resetConfig(row) {
        const defaultConfig = {
            hours: 25,
            teamsSessions: 0,
            spaces: [],
            unavailable: []
        };
        applyConfigToRow(row, defaultConfig);
    }
    
    function applyFirstRowToAll() {
        const allRows = document.querySelectorAll('#autoGenConstraintsContainer tbody tr');
        if (allRows.length < 2) return;
        const firstRowConfig = getConfigFromRow(allRows[0]);
        if (confirm(`Voulez-vous vraiment appliquer la configuration de ${allRows[0].dataset.formateur} à tous les autres ?`)) {
            allRows.forEach((row, index) => {
                if (index > 0) applyConfigToRow(row, firstRowConfig);
            });
            showNotification('Configuration appliquée à tous les formateurs.', 'success');
        }
    }

    function resetAllConfigurations() {
        if (confirm("Êtes-vous sûr de vouloir réinitialiser toutes les configurations ?")) {
            document.querySelectorAll('#autoGenConstraintsContainer tbody tr').forEach(resetConfig);
            showNotification('Toutes les configurations ont été réinitialisées.', 'info');
        }
    }

    function toggleDayAvailability(row, day) {
        const checkboxes = row.querySelectorAll('.availability-checkbox' + (day === 'all' ? '' : `[data-jour="${day}"]`));
        const isAnyChecked = Array.from(checkboxes).some(cb => cb.checked);
        checkboxes.forEach(cb => cb.checked = !isAnyChecked);
    }

    function togglePeriodAvailability(row, period) {
        const seancesToToggle = period === 'morning' ? ['S1', 'S2'] : ['S3', 'S4'];
        const checkboxes = Array.from(row.querySelectorAll('.availability-checkbox'))
            .filter(cb => seancesToToggle.includes(cb.dataset.seance));
        const isAnyChecked = checkboxes.some(cb => cb.checked);
        checkboxes.forEach(cb => cb.checked = !isAnyChecked);
    }

    function isSlotValidForSingle(task, slot, trackers, constraints) {
        const { jour, seance } = slot;
        const formateur = task.formateur;
        const formateurConstraints = constraints[formateur];
        if (trackers.formateurSlots[`${jour}-${seance}-${formateur}`]) return false;
        if (isGroupBusy(jour, seance, task.groupe, trackers)) return false;
        if (formateurConstraints.unavailable.some(u => u.jour === jour && u.seance === seance)) return false;
        if (trackers.formateurHours[formateur] >= formateurConstraints.hours) return false;
        const allowedSpaces = formateurConstraints.spaces;
        let spaceFound = false;
        for (const space of allowedSpaces) {
            if (task.type === 'synchrone') {
                if (space === 'TEAMS' && trackers.formateurTeamsCount[formateur] < formateurConstraints.teamsSessions) {
                    spaceFound = true; break;
                }
            } else {
                if (space !== 'TEAMS' && !trackers.roomSlots[`${jour}-${seance}-${space}`]) {
                    spaceFound = true; break;
                }
            }
        }
        return spaceFound;
    }

    function findBestSlotForSingle(task, newTimetableData, trackers, constraints) {
        let bestSlot = null;
        let highestScore = -1;
        const formateur = task.formateur;
        const formateurSchedule = newTimetableData[formateur];
        for (const jour of jours) {
            for (const seance of seances) {
                const currentSlot = { jour, seance };
                if (!isSlotValidForSingle(task, currentSlot, trackers, constraints)) {
                    continue;
                }
                let score = 1;
                const seanceIndex = seances.indexOf(seance);
                const hasWorkOnDay = seances.some(s => formateurSchedule[jour][s].groupe);
                if (hasWorkOnDay) {
                    score += 10;
                }
                if (seanceIndex > 0 && formateurSchedule[jour][seances[seanceIndex - 1]].groupe) {
                    score += 50;
                }
                if (seanceIndex < seances.length - 1 && formateurSchedule[jour][seances[seanceIndex + 1]].groupe) {
                    score += 50;
                }
                if (seance === 'S3' && formateurSchedule[jour]['S1'].groupe && !formateurSchedule[jour]['S2'].groupe) {
                    score -= 40;
                }
                if (seance === 'S4' && formateurSchedule[jour]['S2'].groupe && !formateurSchedule[jour]['S3'].groupe) {
                    score -= 40;
                }
                if (score > highestScore) {
                    highestScore = score;
                    bestSlot = currentSlot;
                }
            }
        }
        return bestSlot;
    }

    function tryPlaceSingle(task, slot, newTimetableData, trackers, constraints) {
        const { jour, seance } = slot;
        const formateur = task.formateur;
        const formateurConstraints = constraints[formateur];
        let availableSpace = null;
        const allowedSpaces = [...formateurConstraints.spaces].sort(() => Math.random() - 0.5);
        for (const space of allowedSpaces) {
            if (task.type === 'synchrone') {
                if (space === 'TEAMS' && trackers.formateurTeamsCount[formateur] < formateurConstraints.teamsSessions) {
                    availableSpace = space; break;
                }
            } else {
                if (space !== 'TEAMS' && !trackers.roomSlots[`${jour}-${seance}-${space}`]) {
                    availableSpace = space; break;
                }
            }
        }
        if (availableSpace) {
            newTimetableData[formateur][jour][seance] = { groupe: task.groupe, module: task.module, salle: availableSpace };
            trackers.formateurHours[formateur] += SEANCE_DURATION;
            trackers.formateurSlots[`${jour}-${seance}-${formateur}`] = true;
            task.groupe.trim().split(/\s+/).forEach(g => trackers.groupSlots[`${jour}-${seance}-${g}`] = true);
            if (availableSpace === 'TEAMS') {
                trackers.formateurTeamsCount[formateur]++;
            } else {
                trackers.roomSlots[`${jour}-${seance}-${availableSpace}`] = true;
            }
            return true;
        }
        return false;
    }
    
    /**
 * Trouve le meilleur emplacement possible (jour, paire de séances) pour un bloc de 5h.
 * Assure qu'une MÊME SALLE est disponible pour les deux créneaux.
 * @returns {object|null} - Le meilleur slot trouvé (incluant la salle) ou null.
 */
function findBestSlotForBlock(task, newTimetableData, trackers, constraints) {
    let bestSlot = null;
    let highestScore = -1;
    const formateur = task.formateur;
    const formateurConstraints = constraints[formateur];
    const pairs = [['S1', 'S2'], ['S3', 'S4']];

    for (const jour of jours) {
        for (const pair of pairs) {
            const [s1, s2] = pair;

            // --- Vérifications de disponibilité (inchangées) ---
            const isUnavailable = formateurConstraints.unavailable.some(u => u.jour === jour && (u.seance === s1 || u.seance === s2));
            if (isUnavailable) continue;
            if (trackers.formateurSlots[`${jour}-${s1}-${formateur}`] || trackers.formateurSlots[`${jour}-${s2}-${formateur}`]) continue;
            if (isGroupBusy(jour, s1, task.groupe, trackers) || isGroupBusy(jour, s2, task.groupe, trackers)) continue;
            if (trackers.formateurHours[formateur] + (SEANCE_DURATION * 2) > formateurConstraints.hours) continue;

            // --- NOUVELLE LOGIQUE : TROUVER UNE SALLE COMMUNE ---
            let commonAvailableSpace = null;
            for (const space of formateurConstraints.spaces) {
                if (task.type === 'synchrone') {
                    if (space === 'TEAMS') {
                        commonAvailableSpace = space;
                        break; // On a trouvé TEAMS, c'est bon
                    }
                } else {
                    // La salle doit être libre sur les DEUX créneaux en même temps
                    if (space !== 'TEAMS' && !trackers.roomSlots[`${jour}-${s1}-${space}`] && !trackers.roomSlots[`${jour}-${s2}-${space}`]) {
                        commonAvailableSpace = space;
                        break; // On a trouvé une salle commune, on arrête de chercher
                    }
                }
            }
            // Si aucune salle commune n'est disponible pour ce bloc, on passe au suivant
            if (!commonAvailableSpace) continue;
            // --- FIN DE LA NOUVELLE LOGIQUE ---

            // --- Calcul du score (inchangé) ---
            let score = 50;
            const hasWorkOnDay = seances.some(s => newTimetableData[formateur][jour][s].groupe);
            if (hasWorkOnDay) score += 10;
            
            if (score > highestScore) {
                highestScore = score;
                // On stocke maintenant la salle trouvée avec le slot
                bestSlot = { jour, pair, salle: commonAvailableSpace };
            }
        }
    }
    return bestSlot;
}
    
    /**
 * Place un bloc de 5h dans l'emploi du temps en utilisant la salle spécifiée.
 * @returns {boolean} - True si le placement a réussi.
 */
function tryPlaceBlock(task, slot, newTimetableData, trackers, constraints) {
    // On récupère toutes les informations du slot, y compris la salle
    const { jour, pair, salle } = slot;
    const [s1, s2] = pair;
    const formateur = task.formateur;

    // Pas besoin de re-chercher une salle, elle a déjà été validée.
    const sessionData = { groupe: task.groupe, module: task.module, salle: salle };
    newTimetableData[formateur][jour][s1] = sessionData;
    newTimetableData[formateur][jour][s2] = sessionData;

    // Mettre à jour tous les trackers
    trackers.formateurHours[formateur] += (SEANCE_DURATION * 2);
    [s1, s2].forEach(seance => {
        trackers.formateurSlots[`${jour}-${seance}-${formateur}`] = true;
        task.groupe.trim().split(/\s+/).forEach(g => trackers.groupSlots[`${jour}-${seance}-${g}`] = true);
        if (salle !== 'TEAMS') {
            trackers.roomSlots[`${jour}-${seance}-${salle}`] = true;
        }
    });

    // Si la tâche était de type synchrone, on incrémente le compteur TEAMS du formateur
    if (task.type === 'synchrone') {
        trackers.formateurTeamsCount[formateur]++;
    }
    
    return true; // Le placement réussit toujours car la validation a été faite en amont.
}

    function createSchedulableUnits(affectations) {
        const taskMap = new Map();
        affectations.forEach(task => {
            const key = `${task.formateur}|${task.groupe}|${task.module}|${task.type}`;
            if (!taskMap.has(key)) {
                taskMap.set(key, { ...task, count: 0 });
            }
            taskMap.get(key).count++;
        });
        const fiveHourBlockTasks = [];
        const twoPointFiveHourTasks = [];
        taskMap.forEach(task => {
            const fiveHourBlocks = Math.floor(task.count / 2);
            const remainingSingles = task.count % 2;
            if (fiveHourBlocks > 0) fiveHourBlockTasks.push({ ...task, blocksToPlace: fiveHourBlocks });
            if (remainingSingles > 0) twoPointFiveHourTasks.push(task);
        });
        return { fiveHourBlockTasks, twoPointFiveHourTasks };
    }

    function prioritizeTasks(tasks, constraints) {
        const getDifficultyScore = (task) => {
            if (!task || !task.formateur) {
              console.error("Tâche invalide lors du calcul de difficulté :", task);
              return 0; 
            }
            const formateurConstraints = constraints[task.formateur];
            if (!formateurConstraints) return 0;
            const availableSlots = (jours.length * seances.length) - formateurConstraints.unavailable.length;
            return (formateurConstraints.hours / (availableSlots || 1)) * 10;
        };
        return tasks.sort((a, b) => getDifficultyScore(b) - getDifficultyScore(a));
    }

    function isGroupBusy(jour, seance, groupe, trackers) {
        const subGroups = groupe.trim().split(/\s+/).filter(g => g);
        return subGroups.some(subGroup => trackers.groupSlots[`${jour}-${seance}-${subGroup}`]);
    }
    
    /**
 * Fonction principale pour lancer la génération automatique de l'emploi du temps.
 * Extrait toutes les contraintes de l'interface, y compris la répartition par niveau,
 * puis lance un algorithme pondéré pour créer et afficher le nouvel emploi du temps.
 */
/**
 * Fonction principale pour lancer la génération automatique de l'emploi du temps.
 * Extrait toutes les contraintes de l'interface, y compris la répartition par niveau et le filtre par semestre,
 * puis lance un algorithme pondéré pour créer et afficher le nouvel emploi du temps.
 */
 /**
 * Fonction principale pour lancer la génération automatique de l'emploi du temps.
 * Extrait toutes les contraintes de l'interface, y compris la répartition par niveau et le filtre par semestre,
 * puis lance un algorithme pondéré pour créer et afficher le nouvel emploi du temps.
 */
async function runAutoGeneration() {
    console.log("Lancement de la génération automatique...");
    document.getElementById('weekLoader').style.display = 'flex';
    
    // --- ÉTAPE 1 : EXTRACTION ET VALIDATION DES CONTRAINTES DEPUIS L'INTERFACE ---

    // 1a. Extraction des contraintes par formateur
    autoGenConstraints = {};
    document.querySelectorAll('#autoGenConstraintsContainer tr[data-formateur]').forEach(row => {
        const formateur = row.dataset.formateur;
        const assignedSpaces = Array.from(row.querySelectorAll('.space-tag')).map(tag => tag.dataset.space);
        const unavailableSlots = Array.from(row.querySelectorAll('.availability-mini-grid .mini-slot.unavailable'))
            .map(slot => ({ jour: slot.dataset.jour, seance: slot.dataset.seance }));

        autoGenConstraints[formateur] = {
            hours: parseFloat(row.querySelector('.formateur-hours').value) || 0,
            teamsSessions: parseInt(row.querySelector('.formateur-teams-sessions').value, 10) || 0,
            spaces: assignedSpaces,
            unavailable: unavailableSlots
        };
    });

    // 1b. Extraction des pourcentages de répartition par niveau
    const tauxAnnees = {};
    const tauxInputs = document.querySelectorAll('.taux-input');
    let totalTaux = 0;
    tauxInputs.forEach(input => {
        const annee = input.dataset.annee;
        const taux = parseFloat(input.value) || 0;
        tauxAnnees[annee] = taux;
        totalTaux += taux;
    });

    // 1c. Extraction des filtres de semestre
    const semestresChoisis = new Set();
    if (document.getElementById('forceS1').checked) semestresChoisis.add('S1');
    if (document.getElementById('forceS2').checked) semestresChoisis.add('S2');
    if (document.getElementById('forceAnnual').checked) semestresChoisis.add('Annual');

    // 1d. Validation des contraintes
    if (Math.round(totalTaux) !== 100 && tauxInputs.length > 0) {
        showNotification("Erreur : La somme des pourcentages de répartition par niveau doit être égale à 100%.", "error");
        document.getElementById('weekLoader').style.display = 'none';
        return;
    }
    if (semestresChoisis.size === 0) {
        showNotification("Erreur : Veuillez sélectionner au moins un type de module (Semestre 1, 2 ou Annuel).", "error");
        document.getElementById('weekLoader').style.display = 'none';
        return;
    }

    // 1e. Sauvegarde de la configuration complète pour une utilisation future
    try {
        const configToSave = {
            constraints: autoGenConstraints,
            rates: tauxAnnees,
            semesters: Array.from(semestresChoisis) // On sauvegarde les semestres choisis
        };
        localStorage.setItem('autoGenConfig_v2', JSON.stringify(configToSave));
        console.log("Configuration de la génération auto sauvegardée.");
    } catch (e) {
        console.error("Erreur lors de la sauvegarde de la configuration:", e);
    }
    
    // Utiliser un setTimeout permet à l'interface (le loader) de se rafraîchir avant le calcul intensif
    setTimeout(() => {
        try {
            // --- ÉTAPE 2 : INITIALISATION DES DONNÉES POUR LA GÉNÉRATION ---
            
            let newTimetableData = {};
            let trackers = { formateurHours: {}, formateurTeamsCount: {}, roomSlots: {}, groupSlots: {}, formateurSlots: {} };

            appData.formateurs.forEach(f => {
                newTimetableData[f] = {};
                trackers.formateurHours[f] = 0;
                trackers.formateurTeamsCount[f] = 0;
                jours.forEach(j => {
                    newTimetableData[f][j] = {};
                    seances.forEach(s => newTimetableData[f][j][s] = { groupe: '', module: '', salle: '' });
                });
            });

            const affectationsAvecMeta = appData.affectations.map(aff => ({
                ...aff,
                semestre: getModuleSemester(aff.formateur, aff.groupe, aff.module),
                anneeFormation: getAnneeFormation(aff.groupe)
            }));
            
            const affectationsFiltrees = affectationsAvecMeta.filter(aff => 
                semestresChoisis.has(aff.semestre)
            );

            let { fiveHourBlockTasks, twoPointFiveHourTasks } = createSchedulableUnits(affectationsFiltrees);
            
            if (fiveHourBlockTasks.length === 0 && twoPointFiveHourTasks.length === 0) {
                 showNotification("Aucune tâche à planifier ne correspond aux filtres sélectionnés. Veuillez élargir votre sélection.", "warning");
                 document.getElementById('weekLoader').style.display = 'none';
                 return;
            }

            let unplacedTasksLog = [];

            const seuilsProbabilite = [];
            let cumul = 0;
            for (const annee in tauxAnnees) {
                if (tauxAnnees[annee] > 0) {
                    cumul += tauxAnnees[annee] / 100;
                    seuilsProbabilite.push({ annee: annee, seuil: cumul });
                }
            }

            // --- ÉTAPE 3 : ALGORITHME PRINCIPAL DE PLACEMENT DES TÂCHES ---
            
            // TEMPS 1 : PLACER LES BLOCS DE 5 HEURES EN PRIORITÉ
            console.log(`Tentative de placement de ${fiveHourBlockTasks.length} blocs de 5h...`);
            let remainingBlocks = [];
            for (const task of fiveHourBlockTasks) {
                task.anneeFormation = getAnneeFormation(task.groupe);
                const bestSlot = findBestSlotForBlock(task, newTimetableData, trackers, autoGenConstraints);
                if (bestSlot) {
                    tryPlaceBlock(task, bestSlot, newTimetableData, trackers, autoGenConstraints);
                } else {
                    // Si un bloc ne peut pas être placé, on le "casse" en deux séances de 2.5h
                    twoPointFiveHourTasks.push(task, task); 
                    unplacedTasksLog.push({task, reason: "Impossible de placer le bloc de 5h."});
                }
            }

            // TEMPS 2 : PLACER LES SÉANCES RESTANTES DE 2.5 HEURES
            console.log(`Tentative de placement de ${twoPointFiveHourTasks.length} séances de 2.5h...`);
            twoPointFiveHourTasks.forEach(t => t.anneeFormation = getAnneeFormation(t.groupe));
            const prioritizedSingles = prioritizeTasks(twoPointFiveHourTasks, autoGenConstraints);

            for (const task of prioritizedSingles) {
                const bestSlot = findBestSlotForSingle(task, newTimetableData, trackers, autoGenConstraints);
                if (bestSlot) {
                    tryPlaceSingle(task, bestSlot, newTimetableData, trackers, autoGenConstraints);
                } else {
                    unplacedTasksLog.push({task, reason: "Impossible de placer la séance de 2.5h."});
                }
            }

            // --- ÉTAPE 4 : FINALISATION ET AFFICHAGE DES RÉSULTATS ---
            
            renderTimetableFromData(newTimetableData);
            document.getElementById('autoGenModal').style.display = 'none';
            document.getElementById('weekLoader').style.display = 'none';
            
            const totalTasksOriginal = (createSchedulableUnits(affectationsFiltrees).fiveHourBlockTasks.length * 2) + createSchedulableUnits(affectationsFiltrees).twoPointFiveHourTasks.length;
            const totalUnplaced = unplacedTasksLog.reduce((acc, log) => acc + (log.task.count === 2 ? 2 : 1), 0);
            
            let report = `Génération terminée. ${totalTasksOriginal - totalUnplaced} séances sur ${totalTasksOriginal} ont été placées.`;
            
            if (unplacedTasksLog.length > 0) {
                report += ` (${unplacedTasksLog.length} tâches non placées)`;
            }

            console.warn("Tâches non placées:", unplacedTasksLog);
            showNotification(report, unplacedTasksLog.length > 0 ? 'warning' : 'success');

        } catch (error) {
            console.error("Erreur critique lors de la génération automatique:", error);
            showNotification(`Une erreur est survenue: ${error.message}`, 'error');
            document.getElementById('weekLoader').style.display = 'none';
        }
    }, 100);
}

/**
 * Trouve le meilleur emplacement possible (jour, paire de séances) pour un bloc de 5h.
 * @param {object} task - La tâche à placer.
 * @param {object} newTimetableData - L'emploi du temps en cours de construction.
 * @param {object} trackers - Les trackers de disponibilité.
 * @param {object} constraints - Les contraintes des formateurs.
 * @returns {object|null} - Le meilleur slot trouvé ou null.
 */
 function findBestSlotForBlock(task, newTimetableData, trackers, constraints) {
    let bestSlot = null;
    let highestScore = -1;
    const formateur = task.formateur;
    const formateurConstraints = constraints[formateur];
    const pairs = [['S1', 'S2'], ['S3', 'S4']]; // Les paires de séances consécutives

    for (const jour of jours) {
        for (const pair of pairs) {
            const [s1, s2] = pair;

            // --- Vérifications de validité ---
            const isUnavailable = formateurConstraints.unavailable.some(u => u.jour === jour && (u.seance === s1 || u.seance === s2));
            if (isUnavailable) continue; // Le formateur n'est pas dispo

            if (trackers.formateurSlots[`${jour}-${s1}-${formateur}`] || trackers.formateurSlots[`${jour}-${s2}-${formateur}`]) continue; // Le formateur est déjà pris
            if (isGroupBusy(jour, s1, task.groupe, trackers) || isGroupBusy(jour, s2, task.groupe, trackers)) continue; // Le groupe est déjà pris

            if (trackers.formateurHours[formateur] + (SEANCE_DURATION * 2) > formateurConstraints.hours) continue; // Dépassement d'heures

            // Vérifier s'il y a au moins une salle disponible pour les deux créneaux
            let spaceFound = false;
            for (const space of formateurConstraints.spaces) {
                if (task.type === 'synchrone') {
                    if (space === 'TEAMS') { spaceFound = true; break; }
                } else {
                    if (space !== 'TEAMS' && !trackers.roomSlots[`${jour}-${s1}-${space}`] && !trackers.roomSlots[`${jour}-${s2}-${space}`]) {
                        spaceFound = true; break;
                    }
                }
            }
            if (!spaceFound) continue;

            // --- Calcul du score de pertinence ---
            let score = 50; // Bonus de base pour un bloc de 5h
            const hasWorkOnDay = seances.some(s => newTimetableData[formateur][jour][s].groupe);
            if (hasWorkOnDay) score += 10; // Bonus si le formateur travaille déjà ce jour-là
            
            if (score > highestScore) {
                highestScore = score;
                bestSlot = { jour, pair };
            }
        }
    }
    return bestSlot;
}

/**
 * Place un bloc de 5h dans l'emploi du temps et met à jour les trackers.
 * @returns {boolean} - True si le placement a réussi, false sinon.
 */
function tryPlaceBlock(task, slot, newTimetableData, trackers, constraints) {
    const { jour, pair } = slot;
    const [s1, s2] = pair;
    const formateur = task.formateur;
    const formateurConstraints = constraints[formateur];
    
    // On trouve une salle disponible (comme dans findBestSlotForBlock)
    let availableSpace = null;
    for (const space of formateurConstraints.spaces) {
        if (task.type === 'synchrone') {
            if (space === 'TEAMS') { availableSpace = space; break; }
        } else {
            if (space !== 'TEAMS' && !trackers.roomSlots[`${jour}-${s1}-${space}`] && !trackers.roomSlots[`${jour}-${s2}-${space}`]) {
                availableSpace = space; break;
            }
        }
    }

    if (availableSpace) {
        const sessionData = { groupe: task.groupe, module: task.module, salle: availableSpace };
        newTimetableData[formateur][jour][s1] = sessionData;
        newTimetableData[formateur][jour][s2] = sessionData;

        // Mettre à jour tous les trackers
        trackers.formateurHours[formateur] += (SEANCE_DURATION * 2);
        [s1, s2].forEach(seance => {
            trackers.formateurSlots[`${jour}-${seance}-${formateur}`] = true;
            task.groupe.trim().split(/\s+/).forEach(g => trackers.groupSlots[`${jour}-${seance}-${g}`] = true);
            if (availableSpace !== 'TEAMS') {
                trackers.roomSlots[`${jour}-${seance}-${availableSpace}`] = true;
            }
        });
        return true;
    }
    return false;
}

    function setupVoiceAssistant() {
        if (!SpeechRecognition) {
            voiceAssistantBtn.style.display = 'none';
            console.warn("L'API Web Speech n'est pas supportée par ce navigateur.");
            return;
        }
        voiceAssistantBtn.addEventListener('click', toggleListening);
        recognition.onresult = (event) => {
            const transcript = event.results[event.results.length - 1][0].transcript.trim();
            updateStatus(`J'ai entendu : "${transcript}"`);
            processCommand(transcript);
        };
        recognition.onerror = (event) => {
            console.error("Erreur de reconnaissance vocale:", event.error);
            updateStatus("Désolé, je n'ai pas compris.", 3000, true);
            stopListening();
        };
        recognition.onend = () => {
            stopListening();
        };
    }
    
    function toggleListening() {
        if (voiceAssistantBtn.classList.contains('listening')) {
            recognition.stop();
        } else {
            startListening();
        }
    }

    // NOUVELLE VERSION ADAPTÉE AU BOUTON CIRCULAIRE
function startListening() {
    voiceAssistantBtn.classList.add('listening');
    // On change juste la classe de l'icône existante
    voiceAssistantBtn.querySelector('span i').className = 'fas fa-wave-square';
    updateStatus("Je vous écoute...", 0);
    recognition.start();
}

function stopListening() {
    voiceAssistantBtn.classList.remove('listening');
    // On remet la classe de l'icône par défaut
    voiceAssistantBtn.querySelector('span i').className = 'fas fa-microphone';
    setTimeout(() => assistantStatus.classList.remove('visible'), 500);
}

    function updateStatus(message, duration = 2000, isError = false) {
        assistantStatus.textContent = message;
        assistantStatus.style.backgroundColor = isError ? '#e74c3c' : 'rgba(0, 0, 0, 0.75)';
        assistantStatus.classList.add('visible');
        if (duration > 0) {
            setTimeout(() => {
                assistantStatus.classList.remove('visible');
            }, duration);
        }
    }
    
    function speak(text) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'fr-FR';
        utterance.rate = 1.1;
        speechSynthesis.cancel();
        speechSynthesis.speak(utterance);
    }

    let conversationContext = null;
    async function processCommand(command) {
        const GEMINI_API_KEY = 'AIzaSyCtvJkZ0xp7eSEIVVThjiYQ9HsK84ca_bU';
        if (GEMINI_API_KEY.includes('VOTRE_CLE')) {
            const errorMsg = "Erreur : La clé API Gemini n'a pas été configurée dans le code.";
            speak(errorMsg);
            updateStatus(errorMsg, 4000, true);
            console.error(errorMsg);
            return;
        }
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
        updateStatus('Réflexion en cours...', 0);
        if (conversationContext && conversationContext.action === 'confirm_generation') {
            if (command.toLowerCase().match(/oui|lance|vas-y|confirme|ok|d'accord/)) {
                speak("Parfait, je lance la génération immédiatement.");
                openAutoGenModal();
                setTimeout(() => document.getElementById('runAutoGenerateBtn').click(), 500);
                conversationContext = null;
                return;
            } else {
                speak("D'accord, la génération automatique est annulée.");
                conversationContext = null;
                return;
            }
        }
        const currentFormateurs = appData.formateurs.map(f => f.toUpperCase());
        const formateursListString = currentFormateurs.length > 0 
            ? `Voici la liste des formateurs valides que tu dois utiliser : ${currentFormateurs.join(', ')}.` 
            : "Aucun formateur n'est chargé pour le moment.";
        const system_prompt = `
            Tu es un assistant IA pour une application de gestion d'emplois du temps. ${formateursListString}
            Ton rôle est de convertir la requête de l'utilisateur en un objet JSON structuré et de fournir une réponse textuelle pour initier un dialogue si nécessaire.
            Intents possibles : 'afficher_edt', 'enregistrer_edt', 'generer_edt', 'definir_contrainte', 'naviguer_page', 'effacer_edt', 'inconnue'.
            Le format de ta réponse DOIT être UNIQUEMENT un objet JSON.
            Format JSON :
            {
              "intent": "nom_de_l_intention",
              "parameters": {
                "semaine": null,
                "page": null, // 'accueil', 'edition', 'avancement', 'espaces'
                "formateur": null, // DOIT être un nom de la liste fournie.
                "type_contrainte": null, // 'heures' ou 'indisponibilite'
                "valeur": null
              },
              "response": "phrase de réponse naturelle pour l'utilisateur."
            }
            Exemples :
            - Utilisateur: "Va sur la page d'avancement" -> JSON: { "intent": "naviguer_page", "parameters": {"page": "avancement"}, "response": "J'ouvre la page d'avancement." }
            - Utilisateur: "Lance la génération automatique" -> JSON: { "intent": "generer_edt", "parameters": {}, "response": "Je peux lancer la génération. Dois-je vous confirmer les contraintes actuelles avant ?" }
            - Utilisateur: "Pour MARTIN, mets 30 heures" -> JSON: { "intent": "definir_contrainte", "parameters": {"formateur": "MARTIN", "type_contrainte": "heures", "valeur": 30}, "response": "Contrainte mise à jour pour Martin : 30 heures." }
            Maintenant, analyse la requête suivante : "${command}"
        `;
        try {
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: system_prompt }] }] }),
            });
            if (!response.ok) throw new Error('Réponse de l\'API Google non valide.');
            const data = await response.json();
            const rawTextResponse = data.candidates[0].content.parts[0].text;
            const jsonText = rawTextResponse.replace(/```json/g, '').replace(/```/g, '').trim();
            const result = JSON.parse(jsonText);
            speak(result.response);
            switch (result.intent) {
                case 'afficher_edt':
                    const weekNumber = result.parameters.semaine;
                    if (weekNumber) {
                        // Logique pour trouver la date correspondant au numéro de semaine scolaire
                        const schoolYear = getSchoolYear(new Date());
                        let firstMonday = getWeekInfo(new Date(schoolYear, 8, 1)).startOfWeek;
                        let targetDate = new Date(firstMonday);
                        targetDate.setDate(firstMonday.getDate() + (weekNumber) * 7);
                        updateWeekSelection(targetDate);
                    }
                    break;
                case 'enregistrer_edt':
                    saveTimetable();
                    break;
                case 'effacer_edt':
                    resetTimetable();
                    break;
                case 'generer_edt':
                    handleGenerationCommand();
                    break;
                case 'definir_contrainte':
                    handleConstraintCommand(result.parameters);
                    break;
                case 'naviguer_page':
                    const page = result.parameters.page;
                    const pageMap = {
                        'accueil': 'admin.html',
                        'edition': 'edition.html',
                        'avancement': 'avancement.html',
                        'espaces': 'espaces.html'
                    };
                    if (page && pageMap[page]) {
                        window.location.href = pageMap[page];
                    }
                    break;
                default:
                    console.log("Intent non reconnu par l'IA.");
                    break;
            }
        } catch (error) {
            console.error("Erreur de communication avec l'API Gemini:", error);
            const errorMessage = "Désolé, une erreur est survenue lors de la communication avec mon intelligence.";
            speak(errorMessage);
            updateStatus(errorMessage, 4000, true);
        }
    }

    function handleGenerationCommand() {
        openAutoGenModal();
        setTimeout(() => {
            let constraintsSummary = "Je suis prêt à lancer la génération. ";
            const constraintRows = document.querySelectorAll('#autoGenConstraintsContainer tr[data-formateur]');
            if (constraintRows.length > 0) {
                const firstRow = constraintRows[0];
                const formateur = firstRow.dataset.formateur;
                const heures = firstRow.querySelector('.formateur-hours').value;
                constraintsSummary += `À titre d'exemple, pour ${formateur}, le maximum est de ${heures} heures. Dois-je lancer la génération avec les réglages actuels ?`;
            } else {
                constraintsSummary += "Dois-je continuer ?";
            }
            speak(constraintsSummary);
            conversationContext = {
                action: 'confirm_generation'
            };
        }, 500);
    }

    function handleConstraintCommand(params) {
        if (!params.formateur) {
            speak("Veuillez spécifier un nom de formateur valide.");
            return;
        }
        openAutoGenModal();
        setTimeout(() => {
            const formateurRow = document.querySelector(`#autoGenConstraintsContainer tr[data-formateur="${params.formateur.toUpperCase()}"]`);
            if (!formateurRow) {
                speak(`Désolé, je ne trouve pas le formateur nommé ${params.formateur}.`);
                return;
            }
            if (!params.type_contrainte) {
                formateurRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                formateurRow.style.backgroundColor = '#fff9c4';
                return;
            }
            switch (params.type_contrainte) {
                case 'heures':
                    const hoursInput = formateurRow.querySelector('.formateur-hours');
                    if (hoursInput) {
                        hoursInput.value = params.valeur;
                        hoursInput.style.backgroundColor = '#a7ffeb';
                        setTimeout(() => hoursInput.style.backgroundColor = '', 2000);
                    }
                    break;
                case 'indisponibilite':
                    const [jour, seance] = params.valeur.split(/\s+/);
                    const checkbox = formateurRow.querySelector(`input[data-jour*="${jour}"][data-seance="${seance}"]`);
                    if (checkbox) {
                        checkbox.checked = true;
                        checkbox.parentElement.style.backgroundColor = '#ffcdd2';
                        setTimeout(() => checkbox.parentElement.style.backgroundColor = '', 2000);
                    }
                    break;
            }
        }, 500);
    }

    function getOccupiedRooms(jour, seance, currentSelect) {
      const occupied = new Set();
      const allSalleSelects = document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="salle"]`);
      
      allSalleSelects.forEach(select => {
        // On vérifie les autres menus, pas celui qu'on est en train d'éditer.
        // On ne compte que les salles qui ont une valeur et qui ne sont pas "TEAMS".
        if (select !== currentSelect && select.value && select.value !== 'TEAMS') {
          occupied.add(select.value);
        }
      });
      return occupied;
    }

    /**
     * Met à jour les options d'un menu déroulant pour n'afficher que les salles disponibles.
     * @param {HTMLSelectElement} selectElement - Le menu déroulant à mettre à jour.
     */
    function updateSalleOptions(selectElement) {
      const jour = selectElement.dataset.jour;
      const seance = selectElement.dataset.seance;
      const currentValue = selectElement.value; // On sauvegarde la sélection actuelle

      // 1. Obtenir les salles déjà prises sur ce créneau
      const occupiedRooms = getOccupiedRooms(jour, seance, selectElement);

      // 2. Vider les options actuelles
      selectElement.innerHTML = '';

      // 3. Recréer les options en filtrant les salles
      const emptyOption = document.createElement('option');
      emptyOption.value = '';
      selectElement.appendChild(emptyOption); // Toujours garder une option vide

      appData.espaces.forEach(espace => {
        // Une salle est disponible si:
        // - Elle n'est pas dans la liste des salles occupées.
        // - OU, elle est la salle actuellement sélectionnée dans CE menu (pour ne pas la faire disparaître).
        if (!occupiedRooms.has(espace) || espace === currentValue) {
          const option = document.createElement('option');
          option.value = espace;
          option.textContent = espace;
          selectElement.appendChild(option);
        }
      });

      // 4. Restaurer la sélection initiale
      selectElement.value = currentValue;
    }

    /**
 * Récupère la liste de tous les groupes occupés pour un créneau donné,
 * en tenant compte des groupes fusionnés.
 * @param {string} jour - Le jour du créneau.
 * @param {string} seance - La séance du créneau.
 * @param {HTMLSelectElement} currentSelect - Le menu déroulant en cours de modification pour l'exclure de la vérification.
 * @returns {Set<string>} Un Set contenant les noms de chaque groupe individuel occupé.
 */
function getOccupiedGroups(jour, seance, currentSelect) {
    const occupied = new Set();
    const allGroupSelects = document.querySelectorAll(`select[data-jour="${jour}"][data-seance="${seance}"][data-type="groupe"]`);

    allGroupSelects.forEach(select => {
        // On ne vérifie que les autres menus déroulants, pas celui sur lequel on a cliqué.
        if (select !== currentSelect && select.value) {
            // Un champ peut contenir plusieurs groupes (ex: "G1 G2"), on les sépare.
            const subGroups = select.value.trim().split(/\s+/);
            subGroups.forEach(g => {
                if (g) occupied.add(g);
            });
        }
    });
    return occupied;
}

/**
 * Met en évidence les options de groupe non disponibles dans un menu déroulant.
 * @param {HTMLSelectElement} selectElement - Le menu déroulant de groupe à styliser.
 */
function styleGroupOptions(selectElement) {
    const jour = selectElement.dataset.jour;
    const seance = selectElement.dataset.seance;

    // 1. Obtenir les groupes déjà pris sur ce créneau.
    const occupiedGroups = getOccupiedGroups(jour, seance, selectElement);

    // 2. Parcourir chaque option du menu déroulant pour la styliser.
    for (const option of selectElement.options) {
        if (!option.value) continue; // Ignorer l'option vide

        // On vérifie si l'un des sous-groupes de l'option est dans la liste des groupes occupés.
        const optionSubGroups = option.value.trim().split(/\s+/);
        const isOccupied = optionSubGroups.some(g => occupiedGroups.has(g));

        // 3. Appliquer ou retirer le style en fonction de la disponibilité.
        if (isOccupied) {
            option.style.color = 'red';
            option.style.fontWeight = 'bold';
            option.textContent = `${option.value} (Pris)`; // Ajoute une indication textuelle
        } else {
            // Il est crucial de réinitialiser le style pour les options qui redeviennent disponibles.
            option.style.color = ''; // Couleur par défaut
            option.style.fontWeight = ''; // Poids par défaut
            option.textContent = option.value; // Texte original
        }
    }
}

// Fonction pour formater une date au format français
function formatFrenchDate(date) {
        return date.toLocaleDateString('fr-FR', { 
            day: '2-digit', 
            month: 'short'
        });
    }
    
    // Fonction pour obtenir la liste des semaines sauvegardées
    async function getSavedWeeks() {
        try {
            // CORRECTION: On appelle l'API qui liste les EDT de l'utilisateur
            const response = await fetch('../api/data/get_all_timetables.php');
            if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
            
            const savedTimetables = await response.json(); // C'est un tableau d'objets {semaine: ..., emploiDuTemps: ...}
            
            const weeks = savedTimetables.map(tt => {
                const weekInfo = parseWeekValue(tt.semaine);
                if (!weekInfo) return null;
                return {
                    value: tt.semaine,
                    label: `S${weekInfo.weekNumber}`,
                    dates: `${formatFrenchDate(weekInfo.startOfWeek)} - ${formatFrenchDate(weekInfo.endOfWeek)}`
                };
            }).filter(Boolean); // Filtrer les nuls

            weeks.sort((a, b) => b.value.localeCompare(a.value)); // Tri du plus récent au plus ancien
            return weeks;

        } catch (error) {
            console.error("Erreur lors de la récupération des semaines:", error);
            return []; 
        }
    }
    
    // Fonction pour parser la valeur de semaine
    function parseWeekValue(weekValue) {
        const [year, week] = weekValue.split('-W');
        if (!year || !week) return null;
        
        const schoolYear = parseInt(year);
        const weekNumber = parseInt(week);
        
        // Calculer la date de début de semaine
        const firstDayOfSeptember = new Date(schoolYear, 8, 1);
        let dayOfWeek = firstDayOfSeptember.getDay();
        let firstMonday = new Date(firstDayOfSeptember);
        
        if (dayOfWeek !== 1) {
            const offset = (dayOfWeek === 0) ? 1 : 8 - dayOfWeek;
            firstMonday.setDate(firstDayOfSeptember.getDate() + offset);
        }
        
        const startOfWeek = new Date(firstMonday);
        startOfWeek.setDate(firstMonday.getDate() + (weekNumber - 1) * 7);
        startOfWeek.setHours(0, 0, 0, 0);
        
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6);
        
        return {
            schoolYear: schoolYear,
            weekNumber: weekNumber,
            startOfWeek: startOfWeek,
            endOfWeek: endOfWeek
        };
    }
    
   // NOUVELLE FONCTION (asynchrone) pour afficher le menu déroulant
async function showWeekDropdown() {
    const menu = document.getElementById('weekImportMenu');
    menu.innerHTML = '<div style="padding:10px; text-align:center;">Chargement des semaines...</div>';
    menu.classList.add('show');
    
    // Attendre la réponse du serveur
    const savedWeeks = await getSavedWeeks();
    
    if (savedWeeks.length === 0) {
        menu.innerHTML = '<div style="padding:10px; text-align:center; color:#777;">Aucune semaine sauvegardée sur le serveur.</div>';
        return;
    }
    
    menu.innerHTML = '';
    
    // Filtrer pour exclure la semaine actuellement affichée
    const filteredWeeks = savedWeeks.filter(w => w.value !== currentWeekValue);
    
    if (filteredWeeks.length === 0) {
        menu.innerHTML = '<div style="padding:10px; text-align:center; color:#777;">Aucune autre semaine à importer.</div>';
        return;
    }
    
    filteredWeeks.forEach(week => {
        const weekElement = document.createElement('div');
        weekElement.className = 'week-import-item';
        // Affichage amélioré avec l'année
        const year = week.value.split('-W')[0];
        weekElement.innerHTML = `
            <div>
                <span class="week-import-label">${week.label} (${year})</span>
                <span class="week-import-dates" style="display:block; font-size:0.8em; color:#666;">${week.dates}</span>
            </div>
        `;
        weekElement.dataset.week = week.value;
        // On rend le clic asynchrone également
        weekElement.onclick = () => importWeekData(week.value);
        menu.appendChild(weekElement);
    });
}
    
    // NOUVELLE FONCTION (asynchrone) pour importer les données d'une semaine
    async function importWeekData(sourceWeekValue) {
        if (sourceWeekValue === currentWeekValue) {
            showNotification("Vous ne pouvez pas importer la semaine active sur elle-même.", "warning");
            return;
        }

        const weekInfo = parseWeekValue(sourceWeekValue);
        const sourceLabel = `S${weekInfo.weekNumber}`;
        
        if (!confirm(`Voulez-vous écraser l'emploi du temps actuel avec celui de la semaine ${sourceLabel} ?`)) return;

        const loader = document.getElementById('weekLoader');
        loader.style.display = 'flex';
        
        try {
            // CORRECTION 1: On récupère les données de la semaine source via l'API sécurisée
            const response = await fetch(`../api/data/get_timetable.php?semaine=${sourceWeekValue}`);
            const result = await response.json();

            if (!result.success) throw new Error(result.message || 'Impossible de charger la semaine source.');
            
            // Les données de l'emploi du temps importé
            const importedData = result.data;
            
            // CORRECTION 2: On met à jour la variable globale et on sauvegarde via l'API
            timetableData = importedData;
            await saveTimetable(); // On attend que la sauvegarde soit terminée
            
            // On rafraîchit l'affichage
            renderTimetableFromData(timetableData);
            showNotification(`EDT de ${sourceLabel} importé et enregistré pour la semaine actuelle !`, "success");

        } catch (error) {
            console.error("Erreur lors de l'importation:", error);
            showNotification(`Erreur d'importation: ${error.message}`, "error");
        } finally {
            loader.style.display = 'none';
            document.getElementById('weekImportMenu').classList.remove('show');
        }
    }
    
// MODIFIEZ checkSessionAndLoad pour qu'elle ressemble à ça
async function checkSessionAndLoad() {
        try {
            const response = await fetch('../api/auth/verify_session.php');
            const result = await response.json();

            if (!result.success) {
                window.location.href = 'login.html';
                return;
            }

            // Initialisation de l'interface utilisateur
            populateUserInfo(result.userData);
            setupProfileMenu();
            setupEventListeners();
            setupCustomCalendar();
            
            // Chargement des données et initialisation du calendrier
            loadInitialData(); // Cela va charger les données de base PUIS initialiser le calendrier
            
        } catch (error) {
            console.error('Session check failed:', error);
            window.location.href = 'login.html';
        }
    }

    // On remplace l'ancien listener par un appel à notre nouvelle fonction
    document.addEventListener('DOMContentLoaded', () => {
        checkSessionAndLoad();
        document.getElementById('notificationClose').addEventListener('click', () => {
            document.getElementById('notification').classList.add('hide');
        });
    });
    
    function loadInitialData() {
    fetch('../api/data/get_base_data.php')
        .then(response => response.json())
        .then(result => {
            // Log amélioré pour le débogage
            console.log("Données de base reçues du serveur:", result);

            appData = { formateurs: [], groupes: [], fusionGroupes: [], espaces: [], affectations: [] };

            if (result.success && result.data) {
                appData = result.data;

                // Vérification plus explicite
                if (!appData.formateurs || appData.formateurs.length === 0) {
                    showNotification("Fichier traité, mais aucun formateur trouvé. Vérifiez le contenu de votre fichier Excel.", "warning");
                    console.warn("La liste des formateurs est vide après le chargement des données. Assurez-vous que la feuille et la colonne sont correctement nommées dans le fichier Excel.");
                } else {
                    console.log(`${appData.formateurs.length} formateurs chargés.`);
                }
            } else {
                showNotification(result.message || 'Aucune donnée de base trouvée sur le serveur. Veuillez charger un fichier Excel.', "warning");
                console.warn(result.message || 'Aucune donnée de base trouvée.');
            }

            updateWeekSelection(new Date()); 
            generateTimetable(); 
        })
        .catch(error => {
            console.error('Erreur critique lors du chargement des données de base:', error);
            showNotification("Impossible de communiquer avec le serveur pour charger les données.", "error");
            appData = { formateurs: [], groupes: [], fusionGroupes: [], espaces: [], affectations: [] };
            generateTimetable();
        });
}


    function getInitials(name) {
        if (!name) return '--';
        const words = name.trim().split(' ');
        if (words.length === 1) return words[0].substring(0, 2).toUpperCase();
        return (words[0][0] + words[words.length - 1][0]).toUpperCase();
    }

    function populateUserInfo(userData) {
    if (!userData) return;
    
    // Remplir les initiales sur le bouton principal
    const initialsEl = document.getElementById('profile-initials');
    if (initialsEl) initialsEl.textContent = getInitials(userData.nom);
    
    // Remplir le nom complet et l'email dans l'en-tête du dropdown
    const nameEl = document.getElementById('dropdown-user-name');
    const emailEl = document.getElementById('dropdown-user-email');
    if (nameEl) nameEl.textContent = userData.nom;
    if (emailEl) emailEl.textContent = userData.email;
}

/**
 * Met en place les écouteurs pour le menu de profil.
 */
// Remplacez votre fonction setupProfileMenu par celle-ci

function setupProfileMenu() {
    const profileButton = document.getElementById('profile-button');
    const profileDropdown = document.getElementById('profile-dropdown');

    if (profileButton && profileDropdown) {
        // Ouvre/ferme le menu quand on clique sur le bouton de profil
        profileButton.addEventListener('click', (event) => {
            // Empêche le clic de se propager à la fenêtre, ce qui fermerait le menu immédiatement
            event.stopPropagation(); 
            profileDropdown.classList.toggle('show');
        });
        
        // Ferme le menu si on clique n'importe où ailleurs sur la page
        window.addEventListener('click', (event) => {
            // On vérifie que le menu est ouvert ET que le clic n'est pas à l'intérieur du menu
            if (profileDropdown.classList.contains('show') && !profileDropdown.contains(event.target)) {
                profileDropdown.classList.remove('show');
            }
        });
    }
}
    /**
 * Vérifie si un créneau (jour, séance) est disponible pour une séance donnée,
 * en vérifiant les conflits potentiels de groupe et de salle avec les autres formateurs.
 * @param {string} jour - Le jour à vérifier.
 * @param {string} seance - La séance à vérifier.
 * @param {object} sessionToCheck - La séance ({groupe, salle}) que l'on souhaite placer.
 * @param {string} excludeFormateur - Le formateur qui effectue le glisser, à exclure de la vérification.
 * @returns {boolean} - True si le créneau est disponible, false sinon.
 */
function isSlotAvailableForSession(jour, seance, sessionToCheck, excludeFormateur) {
    // Si la session à vérifier est vide, le créneau est toujours "disponible" pour elle.
    if (!sessionToCheck || !sessionToCheck.groupe) return true;

    const groupesToCheck = sessionToCheck.groupe.trim().split(/\s+/).filter(Boolean);
    const salleToCheck = sessionToCheck.salle;

    // Parcourir tous les formateurs du tableau
    for (const formateur in timetableData) {
        // On saute le formateur qui est en train de déplacer un élément
        if (formateur === excludeFormateur) continue;

        const otherSession = timetableData[formateur][jour][seance];
        if (!otherSession || !otherSession.groupe) continue; // On ignore les créneaux vides des autres

        // 1. Vérification du conflit de salle
        if (salleToCheck && salleToCheck !== 'TEAMS' && otherSession.salle === salleToCheck) {
            return false; // Conflit de salle trouvé
        }

        // 2. Vérification du conflit de groupe
        const autresGroupes = otherSession.groupe.trim().split(/\s+/).filter(Boolean);
        if (groupesToCheck.some(g => autresGroupes.includes(g))) {
            return false; // Conflit de groupe trouvé
        }
    }

    // Si on arrive ici, aucun conflit n'a été trouvé avec les autres formateurs
    return true;
}

    /**
     * Détermine le semestre d'un module en se basant sur les affectations.
     * @param {string} formateur - Le nom du formateur.
     * @param {string} groupe - Le nom du ou des groupes (ex: "G1" ou "G1 G2").
     * @param {string} module - Le nom du module.
     * @returns {string|null} - 'S1', 'S2', 'Annual', ou null si non trouvé.
     */
     function getModuleSemester(formateur, groupe, module) {
        // Si une des informations essentielles manque, on ne peut rien faire.
        if (!formateur || !groupe || !module) {
            return null;
        }

        // Gère les cas où plusieurs groupes sont dans la même cellule (ex: "TDI101 TDI102")
        const subGroups = groupe.trim().split(/\s+/).filter(Boolean);

        // On cherche l'affectation qui correspond. On s'arrête à la première trouvée.
        for (const subGroup of subGroups) {
            const affectation = appData.affectations.find(a =>
                a.formateur === formateur &&
                a.groupe === subGroup &&
                a.module === module
            );

            if (affectation) {
                const s1Hours = parseFloat(affectation.s1_heures) || 0;
                const s2Hours = parseFloat(affectation.s2_heures) || 0;

                if (s1Hours > 0 && s2Hours > 0) return "Annual";
                if (s1Hours > 0) return "S1";
                if (s2Hours > 0) return "S2";
            }
        }
        
        // Si on n'a rien trouvé, on retourne null.
        return null;
    }

    function showNotification(message, type) {
    console.log(`[${type.toUpperCase()}] ${message}`);
    // Remplacez ceci par votre véritable implémentation de notifications
}
    /**
 * Détermine si un module est régional en se basant sur les affectations.
 * @param {string} formateur - Le nom du formateur.
 * @param {string} groupe - Le nom du ou des groupes.
 * @param {string} module - Le nom du module.
 * @returns {boolean} - True si le module est régional, false sinon.
 */

  </script>
</body>
</html>